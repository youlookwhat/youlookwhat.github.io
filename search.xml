<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[为 GitHub 项目生成独立主页]]></title>
    <url>%2F2019%2F04%2F09%2Fgithub-pages-readme%2F</url>
    <content type="text"><![CDATA[生成主页步骤： 进入项目的设置页 Settings 选择 GitHub Pages 选择主题 Change theme 确定选择 效果页面：https://jingbin.me/CloudReader 所遇问题 图片显示不出来？使用&lt;img /&gt;标签失效，必须使用正规的引入图片的方式：![]()图片尺寸太大？ - 图片处理网站：https://www.fotor.com/create/design 图片链接失效？注意使用正确的图片链接，之前使用的是：https://github.com/youlookwhat/CloudReader/blob/master/file/images.png发现这个链接是有问题的，点击download进去，正确的链接应该是：https://raw.githubusercontent.com/youlookwhat/CloudReader/master/file/images.png 参考 https://www.jianshu.com/p/1b37016d8db6]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>开源项目</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis 框架实战]]></title>
    <url>%2F2019%2F04%2F03%2Fmybatis-practice%2F</url>
    <content type="text"><![CDATA[我们容易忽视慢变量，但慢变量才是牵引历史进程的火车头。 - 何帆/变量 Mybatis 持久层：简化工作量、灵活 Spring 粘合剂：整合框架 AOP IOC DI SpringMvc 表现层：方便前后端数据的传输 Mybatis: 1.是对jdbc的封装， 2.将sql语句放在映射文件中(xml)， 3.自动将输入参数映射到sql语句的动态参数上， 4.自动将sql语句执行的结果映射成java对象 入门示例： 1.创建项目mubatis-012.导入jar: mybatis-3.2.8 mysql-connect log4j-1.2.17 3.加入配置文件(1)db.properties 1234jdbc.driver=com.mysql.cj.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/mysql_0219jdbc.username = rootjdbc.password = 123456 (2)log4j.propertieshttps://blog.csdn.net/sinat_30185177/article/details/73550377 123log4j.rootLogger=DEBUG,A1log4j.logger.org.mybatis=DEBUG... (3) mybatis核心配置文件：mybatis-config.xml (4) BlogMapper.xml 包:com.jingbin.mybatis.mapper 4.编写接口：BlogMapper5.创建pojo：Blog6.创建工具类：MyBatisUtil7.编写测试类：123456testSelectBlog发现要连接数据库，学习mysql内容学习配置好了后：运行报错：Invalid bound statement (not found): mapper.BlogMapper.selectBlog解决：https://www.cnblogs.com/cailijuan/p/9505244.html1)使用创建接口的方式2)不是用接口的方式 8.列名和属性名不一致的情况数据库里的列名为author_id,属性名为authorId。在BlogMapper.xml里： 1.使用别名 select author_id as authorId from Blog where id=#{id} 2.使用 resultMap 12345678&lt;resultMap type="Blog" id="blogResultMap"&gt; &lt;id column="id" property="id" jdbcType="INTEGER"/&gt; &lt;result column="author_id" property="authorId" jdbcType="INTEGER"/&gt;&lt;/resultMap&gt;&lt;select id="selectBlog" parameterType="Integer" resultMap="blogResultMap"&gt; select * from blog where id = #&#123;id&#125;&lt;/select&gt; 9.模糊查询之#和$的区别模糊查询：根据博客名字查询博客列表 1)使用#传参2)使用$传参 #是占位符？，$是字符串拼接。 mybatis定义： 使用$。如果参数是单指类型(简单类型)，并且只有一个参数，则花括号里只能写value占位。 使用$可以直接将%写里面，可能有sql注入的风险，建议最好使用#。参数是字符串要使用 ‘’ 当参数表示表名或列名的时候，只能使用$ 12345&lt;!-- 使用 $ 不区分大小写的查询 lower--&gt; &lt;select id="selectBlogByTitle2" parameterType="string" resultType="Blog"&gt; select * from blog where lower(title) like lower('%$&#123;value&#125;%') &lt;/select&gt;&lt;/mapper&gt; 10.查询排序需求：按照某一列排序 select * from blog order by CONVERT(${value} USING gbk) gbk:输入中文时排序成功，否则会失败。且使用gbk规避魅族(gb2313)不排序问题。 11.分页-多参数传递需求：查询分页数据 1）使用索引 按照参数的顺序，从0开始 select * from blog limit #{0}, #{1} 2）使用注解 注解的value值要和mapper的占位参数一致。 12select * from blog limit #&#123;offset&#125;, #&#123;pageSize&#125;List&lt;Blog&gt; selectBlogByPage2(@Param(value = "offset") int offset, @Param(value = "pageSize") int pageSize); 3）使用map(常用) 注意：mapper中的参数占位符要和测试中的map的key一一对应 12345678select * from blog limit #&#123;offset&#125;, #&#123;pageSize&#125;// 测试SqlSession session = MyBatisUtil.getSqlSession();BlogMapper blogMapper = session.getMapper(BlogMapper.class);Map&lt;String, Object&gt; objectMap = new HashMap&lt;&gt;();objectMap.put("offset", 0);objectMap.put("pageSize", 2);List&lt;Blog&gt; blogList = blogMapper.selectBlogByPage3(objectMap); 12.插入功能和获取刚刚插入的id 1)插入记录 需求：新增一个博客记录 123456789101112131415161718&lt;insert id="insertBlog" parameterType="Blog"&gt; insert into `blog`( `name`, `age`, `title`, `author_id`, `featured` ) values ( #&#123;name&#125;, #&#123;age&#125;, #&#123;title&#125;, #&#123;author_id&#125;, #&#123;featured&#125; ) &lt;/insert&gt; // 提交session.commit(); 2）获取自增id方式1：在mapper中配置insert节点的属性 useGeneratedKeys和keyProperty节点1&lt;insert id="insertBlog" parameterType="Blog" useGeneratedKeys="true" keyProperty="id"/&gt; 方式2：在全局配置文件中配置setting1234567&lt;!--定义数据库链接配置--&gt; &lt;properties resource="db.properties"/&gt; &lt;!--具体的insert也得配置 keyProperty节点--&gt; &lt;settings&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;/settings&gt; 方式3：适用于没有自增主键的数据库 1234567891011121314151617181920212223242526272829303132333435363738&lt;insert id="insertBlogOracle" parameterType="Blog"&gt; &lt;selectKey resultType="java.lang.Integer" order="BEFORE" keyProperty="id"&gt; select seq.nextval as id from dual &lt;/selectKey&gt; insert into `blog`( `name`, `age`, `title`, `author_id`, `featured` ) values ( #&#123;name&#125;, #&#123;age&#125;, #&#123;title&#125;, #&#123;author_id&#125;, #&#123;featured&#125; ) &lt;/insert&gt; &lt;insert id="insertBlogMysql" parameterType="Blog"&gt; &lt;selectKey resultType="java.lang.Integer" order="AFTER" keyProperty="id"&gt; SELECT LAST_INSERT_ID() &lt;/selectKey&gt; insert into `blog`( `name`, `age`, `title`, `author_id`, `featured` ) values ( #&#123;name&#125;, #&#123;age&#125;, #&#123;title&#125;, #&#123;author_id&#125;, #&#123;featured&#125; ) &lt;/insert&gt; 13.修改功能和修改部分字段注意的问题1234567891011&lt;update id="updateBlog" parameterType="Blog"&gt; update `blog` set `name` = #&#123;name&#125;, `age` = #&#123;age&#125;, `title` = #&#123;title&#125;, `author_id` = #&#123;author_id&#125;, `featured` = #&#123;featured&#125; where `id` = #&#123;id&#125; &lt;/update&gt; 注意：如果没有为对象设置所有的要修改的属性，那么未设置的属性会用成员变量的默认值填充。解决：方式1：数据库查一遍，再返回的数据修改。缺点：又执行了一遍数据库操作方式2：查询语句里增加if else。 14.删除记录123&lt;delete id="deleteBlogById"&gt; delete from blog where id=#&#123;id&#125;&lt;/delete&gt; 动态sql批量删除：使用动态sql实现if、[choose、when、otherwise]、where、set、trim、foreach、sql片段 15.if需求： 1.查询已激活的并且博客的名字是包含某个查询字符串的记录 2.如果用户没有输入任何查询字符串，那么就显示所有已激活的记录 // 如果用户输入了查询字符串select * from blogwhere state = ‘ACTIVE’and title like ‘%o%’ // 用户没有输入查询字符串select * from blogwhere state = ‘ACTIVE’ 12345select * from blogwhere state = 'ACTIVE' &lt;if test="value != null and value!=''"&gt; and title like value[%%] 具体见代码&lt;/if&gt; 16.choose、when、otherwise需求： 1、查询已激活的 2、如果用户输入了标题的查询关键字，则根据关键字查询 3、否则根据blog风格样式查询 4、如果什么都没有输入，则显示推荐的博客 123456789&lt;select id="selectActiveBlogByTitleOrStyle" parameterType="Blog" resultType="Blog"&gt; select * from blog where state = 'ACTIVE' &lt;choose&gt; &lt;when test="title != null and title!=''"&gt;and lower(title) like lower(#&#123;title&#125;)&lt;/when&gt; &lt;when test="style != null and style!=''"&gt;and style = #&#123;style&#125;&lt;/when&gt; &lt;otherwise&gt; and featured = true&lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 17.where需求：多条件查询，根据状态，标题，是否被推荐自动修补查询条件，查询语句中的where关键字使用标签替代，不能省略 and or 关键字 1234567891011121314&lt;select id="selectBlogByCondition" parameterType="Blog" resultType="Blog"&gt; select * from blog &lt;where&gt; &lt;if test="state != null and state!=''"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test="title != null and title!=''"&gt; and lower(title) like lower(#&#123;title&#125;) &lt;/if&gt; &lt;if test="featured != null"&gt; and featured = #&#123;featured&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 18.set需求：按需修改，修改执行的列，未指定的不修改set 会自动去掉if语句后面的逗号 12345678910111213&lt;update id="updateBlogByCondition" parameterType="Blog"&gt; update `blog` &lt;set&gt; &lt;if test="name != null"&gt;`name` = #&#123;name&#125;,&lt;/if&gt; &lt;if test="age != null"&gt;`age` = #&#123;age&#125;,&lt;/if&gt; &lt;if test="title != null"&gt;`title` = #&#123;title&#125;,&lt;/if&gt; &lt;if test="author_id != null"&gt;`author_id` = #&#123;author_id&#125;,&lt;/if&gt; &lt;if test="featured != null"&gt;`featured` = #&#123;featured&#125;,&lt;/if&gt; &lt;if test="state != null"&gt;`state` = #&#123;state&#125;,&lt;/if&gt; &lt;if test="style != null"&gt;`style` = #&#123;state&#125;,&lt;/if&gt; &lt;/set&gt; where `id` = #&#123;id&#125;&lt;/update&gt; 19.trim123456789101112131415161718192021222324252627282930&lt;select id="selectBlogByConditionTrim" parameterType="Blog" resultType="Blog"&gt; select * from blog -- prefixOverrides 去掉前面的 and 或 or &lt;trim prefix="where" prefixOverrides="and | or"&gt; &lt;if test="state != null and state!=''"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test="title != null and title!=''"&gt; and lower(title) like lower(#&#123;title&#125;) &lt;/if&gt; &lt;if test="featured != null"&gt; and featured = #&#123;featured&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt;&lt;update id="updateBlogByConditionTrim" parameterType="Blog"&gt; update `blog` -- suffixOverrides 去掉后面的 , &lt;trim prefix="set" suffixOverrides=","&gt; &lt;if test="name != null"&gt;`name` = #&#123;name&#125;,&lt;/if&gt; &lt;if test="age != null"&gt;`age` = #&#123;age&#125;,&lt;/if&gt; &lt;if test="title != null"&gt;`title` = #&#123;title&#125;,&lt;/if&gt; &lt;if test="author_id != null"&gt;`author_id` = #&#123;author_id&#125;,&lt;/if&gt; &lt;if test="featured != null"&gt;`featured` = #&#123;featured&#125;,&lt;/if&gt; &lt;if test="state != null"&gt;`state` = #&#123;state&#125;,&lt;/if&gt; &lt;if test="style != null"&gt;`style` = #&#123;state&#125;,&lt;/if&gt; &lt;/trim&gt; where `id` = #&#123;id&#125;&lt;/update&gt; 20.foreach需求：批量删除 12345678910111213141516171819 &lt;!-- parameterType 与 collection 一致--&gt;&lt;delete id="deleteBlogList" parameterType="list"&gt; delete from blog where id in &lt;foreach collection="list" item="item" open="(" close=")" separator=","&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/delete&gt;@Testpublic void testDeleteBlogList() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); List&lt;Integer&gt; asList = Arrays.asList(1, 2); int count = blogMapper.deleteBlogList(asList); // 提交 session.commit(); session.close(); System.out.println("更新了" + count + "条记录");&#125; 21.sql片段123456789101112131415161718&lt;!--sql片段--&gt;&lt;sql id="columnBase"&gt; `id`, `name`, `age`, `title`, `author_id`, `featured`, `state`, `style`&lt;/sql&gt;&lt;!--通过id查询博客--&gt;&lt;select id="selectBlog" parameterType="Integer" resultType="Blog"&gt; select &lt;include refid="columnBase"/&gt; from blog where id = #&#123;id&#125;&lt;/select&gt; 22 23.逆向功工程-代码的生成使用 Mybatis 官方工具直接生成对应的mapper文件全部生成 - 无实际意义，具体项目中不适用 24.缓存 - mybatis的一级缓存一级缓存：是session级别的缓存，一级缓存默认存在。当在同一个session范围内执行查询的时候，如果执行相同的查询，那么第二次查询会从缓存中获取数据。 1234567891011121314151617/** * mybatis的一级缓存 */@Testpublic void testSelectBlogCacheOne1() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); Blog blog1 = blogMapper.selectBlog(3); System.out.println("结果已查询" + blog1); Blog blog2 = blogMapper.selectBlog(3); System.out.println("结果已查询：从缓存中获取数据" + blog2); session.close(); System.out.println("session关闭");&#125; 25.缓存 - 一级缓存被刷新的情况如果两次查询中间有增删改操作，sql session缓存区会被自动清空，说明下一次查询会重新执行sql语句。 123456789101112131415161718192021/** * mybatis的一级缓存,中间有增删改会刷新 */@Testpublic void testSelectBlogCacheOne2() &#123; SqlSession session = MyBatisUtil.getSqlSession(); BlogMapper blogMapper = session.getMapper(BlogMapper.class); Blog blog1 = blogMapper.selectBlog(3); System.out.println("结果已查询" + blog1); blog1.setFeatured(true); blogMapper.updateBlog(blog1); Blog blog2 = blogMapper.selectBlog(3); System.out.println("结果已查询：从新执行查询" + blog2); session.commit(); session.close(); System.out.println("session关闭");&#125; 26.缓存 - 开启二级缓存默认不开启。如果在不同的session范围内执行相同的数据查询，那么每次查询将会执行独立的数据库检索过程。 12345678910111213141516171819/** * mybatis的二级缓存 */@Testpublic void testSelectBlogCacheLevelTwo1() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); Blog blog1 = blogMapper1.selectBlog(3); System.out.println("结果已查询" + blog1); session1.close(); SqlSession session2 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper2 = session2.getMapper(BlogMapper.class); Blog blog2 = blogMapper2.selectBlog(3); System.out.println("结果已查询：从缓存中获取数据" + blog2); session2.close(); System.out.println("session关闭");&#125; 开启二级缓存1.在mapper文件中设置 2.在实体类中实现序列化接口 12345678910111213141516171819202122232425public class Blog implements Serializable &#123; private static final long serialVersionUID = 1L;&#125; /** * mybatis的二级缓存 */@Testpublic void testSelectBlogCacheLevelTwo1() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); Blog blog1 = blogMapper1.selectBlog(3); System.out.println("结果已查询" + blog1); session1.close(); // Cache Hit Ratio [mapper.BlogMapper]: 0.5 SqlSession session2 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper2 = session2.getMapper(BlogMapper.class); Blog blog2 = blogMapper2.selectBlog(3); System.out.println("结果已查询：从缓存中获取数据" + blog2); session2.close(); System.out.println("session关闭");&#125; 27.缓存 - 二级缓存被刷新的情况和一级缓存相同，中间有增删改则二级缓存会被清空 123456789101112131415161718192021/** * mybatis的二级缓存 缓存被刷新 */@Testpublic void testSelectBlogCacheLevelTwo2() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); Blog blog1 = blogMapper1.selectBlog(3); blog1.setFeatured(true); blogMapper1.updateBlog(blog1); System.out.println("结果已查询" + blog1); session1.close(); SqlSession session2 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper2 = session2.getMapper(BlogMapper.class); Blog blog2 = blogMapper2.selectBlog(3); System.out.println("缓存被刷新，重新查询" + blog2); session2.close(); System.out.println("session关闭");&#125; 28.嵌套查询 - 一对一和多对一高级结果映射一、关联映射(适用于一对一和多对一的情况) 1).创建pojo(1)在Blog中创建Author对象 1private Author author; (2)创建Author的pojo 2).配置mapper BlogMapper.java 123456789&lt;resultMap type="Blog" id="blogResultMap"&gt; &lt;id column="id" property="id" jdbcType="INTEGER"&gt;&lt;/id&gt; &lt;association property="author" column="author_id" javaType="Author" select="me.jing.mapper.AuthorMapper.selectAuthorById"&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;select id="selectBlogById" parameterType="int" resultMap="blogResultMap"&gt; select * from blog where id = #&#123;id&#125;&lt;/select&gt; AuthorMapper.java 123456789&lt;resultMap type="Author" id="authorResultMap"&gt; &lt;id column="id" property="id" jdbcType="INTEGER"/&gt; &lt;result column="favourite_section" property="favouriteSection" jdbcType="VARCHAR"/&gt;&lt;/resultMap&gt;&lt;select id="selectAuthorById" parameterType="int" resultMap="authorResultMap"&gt; select * from author where id = #&#123;id&#125;&lt;/select&gt; 3) 接口 (1) Blog 1Blog selectBlogById(Integer id); (2) Author 1Author selectAuthorById(Integer id); 4) 测试 查询Blog列表时，执行的sql语句是 1+n，但是如果blog关联的author有重复的数据，那么从一级缓存中查询。 12345678910111213 /** * 通过id查具体的博客，查询时 再拿到作者id 去作者表查具体的作者信息 */@Testpublic void testSelectBlogById() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); Blog blog = blogMapper1.selectBlogById(3); session1.close(); System.out.println("结果已查询" + blog);&#125; 29.嵌套查询 - 显示信息列表12345678910111213141516&lt;select id="selectBlogList" resultMap="blogResultMap"&gt; select * from blog&lt;/select&gt;List&lt;Blog&gt; selectBlogList();@Testpublic void testSelectBlogList() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); List&lt;Blog&gt; blogs = blogMapper1.selectBlogList(); session1.close(); System.out.println("结果已查询" + blogs);&#125; 30.嵌套查询-一对多的配置 31.嵌套查询-一对多的查询配置执行流程：1.先执行单表查询，2.再利用单表查询的结果继续执行其他单表查询，3.最后组装结果映射。 通过post的id 查询post表的内容，同时通过此id查询评论表 comment 里的数据列表,即这篇文章的评论列表 sql: 1234567891011create table post(id int,blog_id int,author_id int,section varchar(20),subject varchar(20),draft varchar(20));insert into post(id,blog_id,author_id,section,subject,draft) values('1','3','15','section','subject','draft');create table comment(id int,name varchar(20),comment varchar(20));insert into comment(id,name,comment,post_id) values('1','评论name','我觉得很棒 评论','1'); PostMapper.xml 12345678910&lt;resultMap type="Post" id="postResultMap"&gt; &lt;id column="id" property="id" jdbcType="INTEGER"&gt;&lt;/id&gt; &lt;collection property="commentList" column="id" javaType="ArrayList" ofType="Comment" select="me.jing.mapper.CommentMapper.selectCommentListByPostId"&gt;&lt;/collection&gt;&lt;/resultMap&gt;&lt;select id="selectPostById" parameterType="int" resultMap="postResultMap"&gt; select * from post where id = #&#123;id&#125;&lt;/select&gt; CommentMapper.xml 123456789101112&lt;resultMap type="Comment" id="commentResultMap"&gt; &lt;id column="id" property="id" jdbcType="INTEGER"&gt;&lt;/id&gt;&lt;/resultMap&gt;&lt;!--通过post_id查询评论列表--&gt;&lt;select id="selectCommentListByPostId" parameterType="int" resultMap="commentResultMap"&gt; select * from comment where post_id = #&#123;postId&#125;&lt;/select&gt;&lt;select id="selectCommentById" parameterType="int" resultMap="commentResultMap"&gt; select * from comment where id = #&#123;id&#125;&lt;/select&gt; 测试： 123456789101112 /** * 通过post的id 查询post表的内容， * 同时通过此id查询评论表 comment 里的数据列表,即这篇文章的评论列表 */@Testpublic void selectPostById() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); PostMapper mapper = session1.getMapper(PostMapper.class); Post post = mapper.selectPostById(1); System.out.println("结果已查询" + post); session1.close();&#125; 32.高级结果映射-嵌套结果1).先执行关联查询，一次性将所有数据都查询出来2).再将所有查询出来的列组织成嵌套的结果对象 1234SELECT * FROMblog bLEFT JOIN author aON b.author_id = a.id; 12345678910111213141516SELECT b.id as blog_id, b.title as blog_title, b.author_id as blog_author_id, b.state as blog_state, b.featured as blog_featured, b.style as blog_style, a.id as author_id, a.username as author_username, a.password as author_password, a.email as author_email FROM blog bLEFT JOIN author aON b.author_id = a.id; BlogMapper.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;resultMap id="blogResultMapNested" type="Blog"&gt; &lt;id column="blog_id" property="id"/&gt; &lt;result column="blog_title" property="title"/&gt; &lt;result column="blog_state" property="state"/&gt; &lt;result column="blog_featured" property="featured"/&gt; &lt;result column="blog_style" property="style"/&gt; &lt;!--&lt;result column="blog_author_id" property="author_id"/&gt;--&gt; &lt;association property="author" column="blog_author_id" javaType="Author"&gt; &lt;id column="author_id" property="id"/&gt; &lt;result column="author_username" property="username"/&gt; &lt;result column="author_password" property="password"/&gt; &lt;result column="author_email" property="email"/&gt; &lt;/association&gt;&lt;/resultMap&gt;&lt;!--32.高级结果映射-嵌套结果--&gt;&lt;select id="selectBlogListNested" resultMap="blogResultMapNested"&gt; SELECT b.id as blog_id, b.title as blog_title, b.author_id as blog_author_id, b.state as blog_state, b.featured as blog_featured, b.style as blog_style, a.id as author_id, a.username as author_username, a.password as author_password FROM blog b LEFT JOIN author a ON b.author_id = a.id;&lt;/select&gt;/** * 嵌套查询 */List&lt;Blog&gt; selectBlogListNested();/** * 嵌套查询 */@Testpublic void testSelectBlogListNested() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); List&lt;Blog&gt; blogs = blogMapper1.selectBlogListNested(); session1.close(); System.out.println("结果已查询2:" + blogs);&#125; 33.为什么要做扩展结果集|34.扩展结果的实现1).mapper BlogCustomMapper.xml 123456789101112131415161718&lt;sql id="baseColumn"&gt; b.id, b.`title`, b.`author_id`, b.`state`, b.`featured`, b.`style`, a.username as authorUsername&lt;/sql&gt;&lt;select id="selectBlogById" parameterType="int" resultType="BlogCustom"&gt; select &lt;include refid="baseColumn"/&gt; from blog b left join author a on b.author_id = a.id where b.id = #&#123;id&#125;&lt;/select&gt; BlogCustomMapper.java 123public interface BlogCustomMapper &#123; BlogCustom selectBlogById(Integer id);&#125; 2)vo.BlogCustom.java 123456789101112131415161718192021222324252627282930/** * 扩展Blog */public class BlogCustom extends Blog &#123; private static final long serialVersionUID = 1L; private String authorUsername; public String getAuthorUsername() &#123; return authorUsername; &#125; public void setAuthorUsername(String authorUsername) &#123; this.authorUsername = authorUsername; &#125; @Override public String toString() &#123; return "BlogCustom&#123;" + "authorUsername='" + authorUsername + '\'' + '&#125;'; &#125;&#125;&lt;!--定义别名--&gt;&lt;typeAliases&gt; &lt;!--&lt;typeAlias type="pojo.Blog" alias="Blog"/&gt;--&gt; &lt;package name="me.jing.pojo"/&gt; &lt;package name="me.jing.pojo.vo"/&gt;&lt;/typeAliases&gt; 3)测试 12345678910111213/** * 通过id查具体的博客，查询时 再拿到作者id 去作者表查具体的作者 username */@Testpublic void testSelectBlogById() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogCustomMapper mapper = session1.getMapper(BlogCustomMapper.class); BlogCustom blog = mapper.selectBlogById(3); session1.close(); System.out.println("结果已查询" + blog);&#125; 35.高级结果映射 - 构造方式映射1234567891011121314151617181920212223242526272829303132333435Bolg.xmlpublic Blog(Integer id, String title) &#123; this.id = id; this.title = title; System.out.println("构造函数调用-----");&#125;&lt;!--构造方法映射--&gt;&lt;resultMap id="blogResultMapConstructor" type="Blog"&gt; &lt;constructor&gt; &lt;idArg column="id" javaType="int"/&gt; &lt;arg column="title" javaType="string"/&gt; &lt;/constructor&gt;&lt;/resultMap&gt;&lt;select id="selectBlogByIdConstructor" parameterType="int" resultMap="blogResultMapConstructor"&gt; select * from blog where id = #&#123;id&#125;&lt;/select&gt; /** * 构造方式映射 */Blog selectBlogByIdConstructor(Integer id); /** * 构造方式映射 */@Testpublic void testSelectBlogByIdConstructor() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); Blog blog = blogMapper1.selectBlogByIdConstructor(3); session1.close(); System.out.println("结果已查询:" + blog);&#125; 36.鉴别器123456789101112CREATE TABLE `vehicle`( `id` INT(11) NOT NULL AUTO_INCREMENT, `vin` VARCHAR(50) COLLATE utf8_bin DEFAULT NULL, `year` YEAR(4) DEFAULT NULL, `make` VARCHAR(50) COLLATE utf8_bin DEFAULT NULL, `model` VARCHAR(50) COLLATE utf8_bin DEFAULT NULL, `color` VARCHAR(50) COLLATE utf8_bin DEFAULT NULL, `vehicle_type` INT(11) DEFAULT NULL, `door_count` INT(11) DEFAULT NULL, `all_wheel_drive` TINYINT(1) DEFAULT NULL, PRIMARY KEY(`id`) ) ENGINE=INNODB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 COLLATE=utf8_bin; 1234567891011121314151617181920VehicleMapper.xml&lt;resultMap type="Vehicle" id="vehicleResultMap"&gt; &lt;id column="id" property="id" jdbcType="INTEGER"/&gt; &lt;discriminator javaType="int" column="vehicle_type"&gt; &lt;case value="1" resultType="Car"&gt; &lt;result column="door_count" property="doorCount"/&gt; &lt;/case&gt; &lt;case value="2" resultType="Suv"&gt; &lt;result column="all_wheel_drive" property="allWheelDrive"/&gt; &lt;/case&gt; &lt;/discriminator&gt;&lt;/resultMap&gt;&lt;select id="selectVehicleById" parameterType="int" resultMap="vehicleResultMap"&gt; select * from vehicle where id = #&#123;id&#125;&lt;/select&gt;Vehicle selectVehicleById(Integer id); pojo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class Vehicle &#123; private Integer id; private Integer vehicle_type; private String vin; private String make; private String model; private String color; private Boolean all_wheel_drive;&#125;public class Suv extends Vehicle &#123; // 全轮驱动 awd private Boolean allWheelDrive; public Suv() &#123; &#125; public Boolean getAllWheelDrive() &#123; return allWheelDrive; &#125; public void setAllWheelDrive(Boolean allWheelDrive) &#123; this.allWheelDrive = allWheelDrive; &#125; @Override public String toString() &#123; return "Suv&#123;" + "allWheelDrive=" + allWheelDrive + '&#125;'; &#125;&#125;public class Car extends Vehicle &#123; // 门的数量 private Integer doorCount; public Integer getDoorCount() &#123; return doorCount; &#125; public void setDoorCount(Integer doorCount) &#123; this.doorCount = doorCount; &#125; @Override public String toString() &#123; return "Car&#123;" + "doorCount=" + doorCount + '&#125;'; &#125;&#125; 测试： 1234567891011121314151617181920212223242526 /** * 鉴别器 */@Testpublic void testSelectVehicleById() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); VehicleMapper mapper = session1.getMapper(VehicleMapper.class); Vehicle vehicle = mapper.selectVehicleById(1); Vehicle vehicle2 = mapper.selectVehicleById(2); if (vehicle instanceof Car) &#123; Car car = (Car) vehicle; Suv suv = (Suv) vehicle2; System.out.println("car:" + car); System.out.println("suv:" + suv); &#125; else &#123; Car car = (Car) vehicle2; Suv suv = (Suv) vehicle; System.out.println("car:" + car); System.out.println("suv:" + suv); &#125; System.out.println("vehicle:" + vehicle); System.out.println("vehicle2:" + vehicle2); session1.close();&#125; 37.延迟加载 - 不配置延迟加载的情况测试一：没有配置任何选项，执行两遍查询，性能比较低 无论是否查询blog的任意属性，都会执行author的任何查询，就是说 始终会执行两次查询。 123456789101112131415161718查询blog----Opening JDBC ConnectionCreated connection 504858437.Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1e178745]==&gt; Preparing: select * from blog where id = ? ==&gt; Parameters: 3(Integer)====&gt; Preparing: select * from author where id = ? ====&gt; Parameters: 15(Integer)&lt;==== Total: 1&lt;== Total: 1Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1e178745]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1e178745]Returned connection 504858437 to pool.查询blog的title属性----Android开发艺术探索查询blog的author属性----景彬结果已查询 38.延迟加载 - 配置lazyloadingenabled测试二：如果不查询blog的任意属性，那么不会执行author的查询 配置了全局属性： 12345&lt;settings&gt; &lt;!--&lt;setting name="useGeneratedKeys" value="true"/&gt;--&gt; &lt;!--延迟加载 配置lazyloadingenabled--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;/settings&gt; 测试： 12345678910111213141516171819/** * 测试延迟加载 * 没有配置 lazyLoadingEnabled 时，会始终执行两次查询 */@Testpublic void testSelectBlogByIdLazyLoading() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); System.out.println("查询blog----"); Blog blog = blogMapper1.selectBlogById(3); session1.close();// System.out.println("查询blog的title属性----");// System.out.println(blog.getTitle());// System.out.println("查询blog的author属性----");// System.out.println(blog.getAuthor().getUsername()); System.out.println("结果已查询");&#125; 日志打印： 1234567891011查询blog----Opening JDBC ConnectionCreated connection 210156003.Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]==&gt; Preparing: select * from blog where id = ? ==&gt; Parameters: 3(Integer)&lt;== Total: 1Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]Returned connection 210156003 to pool.结果已查询 39.延迟加载 - 测试用例1和2的比较40.延迟加载 - 积极的延迟加载延迟加载：用属性就加载，不用就不加载。积极的延迟加载：只要用属性，就把所有要查询的属性sql全部执行一遍。 测试三：只要查询bolg的任意属性，都会执行author数据的查询 配置了全局属性(同测试2的配置)： 12345&lt;settings&gt; &lt;!--&lt;setting name="useGeneratedKeys" value="true"/&gt;--&gt; &lt;!--延迟加载 配置lazyloadingenabled--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt;&lt;/settings&gt; 测试： 12345678910111213141516171819/** * 测试延迟加载 * 没有配置 lazyLoadingEnabled 时，会始终执行两次查询 */@Testpublic void testSelectBlogByIdLazyLoading() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); System.out.println("查询blog----"); Blog blog = blogMapper1.selectBlogById(3); session1.close(); System.out.println("查询blog的title属性----"); System.out.println(blog.getTitle());// System.out.println("查询blog的author属性----");// System.out.println(blog.getAuthor().getUsername()); System.out.println("结果已查询");&#125; 41.延迟加载 - 非积极延迟加载测试四：延迟加载，并且是非积极的。如果需要访问blog的非author属性，则不执行关联的author查询。 配置了全局属性： 配置后，没有调用 blog.getAuthor() 属性，就只会执行一次，调用 blog.getAuthor() 属性才回再执行查询author表一次。 12345678&lt;!--具体的insert也得配置 keyProperty--&gt;&lt;settings&gt; &lt;setting name="useGeneratedKeys" value="true"/&gt; &lt;!--延迟加载 配置lazyloadingenabled--&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &lt;!--非积极的延迟加载--&gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt;&lt;/settings&gt; 测试： 123456789101112131415161718 /** * 测试延迟加载 */@Testpublic void testSelectBlogByIdLazyLoading() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); System.out.println("查询blog----"); Blog blog = blogMapper1.selectBlogById(3); session1.close(); System.out.println("查询blog的title属性----"); System.out.println(blog.getTitle());// System.out.println("查询blog的author属性----");// System.out.println(blog.getAuthor().getUsername()); System.out.println("结果已查询");&#125; 打印： 12345678910111213查询blog----Opening JDBC ConnectionCreated connection 210156003.Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]==&gt; Preparing: select * from blog where id = ? ==&gt; Parameters: 3(Integer)&lt;== Total: 1Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]Returned connection 210156003 to pool.查询blog的title属性----Android开发艺术探索结果已查询 测试五： 配置了全局属性 同配置四 延迟加载，并且是不积极的。如果访问了blog的author属性，则执行关联的author查询 测试： 123456789101112131415161718/** * 测试延迟加载 */@Testpublic void testSelectBlogByIdLazyLoading() &#123; SqlSession session1 = MyBatisUtil.getSqlSession(); BlogMapper blogMapper1 = session1.getMapper(BlogMapper.class); System.out.println("查询blog----"); Blog blog = blogMapper1.selectBlogById(3); session1.close(); System.out.println("查询blog的title属性----"); System.out.println(blog.getTitle()); System.out.println("查询blog的author属性----"); System.out.println(blog.getAuthor().getUsername()); System.out.println("结果已查询");&#125; 打印： 123456789101112131415161718192021222324查询blog----Opening JDBC ConnectionCreated connection 210156003.Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]==&gt; Preparing: select * from blog where id = ? ==&gt; Parameters: 3(Integer)&lt;== Total: 1Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]Returned connection 210156003 to pool.查询blog的title属性----Android开发艺术探索查询blog的author属性----Opening JDBC ConnectionChecked out connection 210156003 from pool.Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]==&gt; Preparing: select * from author where id = ? ==&gt; Parameters: 15(Integer)&lt;== Total: 1Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@c86b9e3]Returned connection 210156003 to pool.景彬结果已查询]]></content>
      <categories>
        <category>Java后端</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 使用规范(内部培训笔记)]]></title>
    <url>%2F2019%2F03%2F31%2Fmysql-tip%2F</url>
    <content type="text"><![CDATA[袋鼠云数据库使用基本规范。 一般操作 高峰期不进行DDL操作，不进行大表全表扫描； 进行更新或删除时，一万以下条数据最好使用 分批更新(计数 如 i 累加到500)（存储方式） 设计库 原则：不同业务按库划分 使用：innodb 存储引擎 设计表 一定要有主键 强烈建议字段为 NOT NULL，并设置默认值 禁止储存图片、文件、视频等 使用 tingint 代替 ENUM 禁止使用外键 少用拆分 BLOB、TEXT字段 控制 字段数量/尽可能小的字段/命名规范 字段类型 Tinyint[UNSIGNED] - 无负整数 （从 0 到 255 的整型数据。存储大小为 1 字节。） DECIIMAL - 精确数值，不是Float/Double int(3) - 后面的数字无意义 索引 index表名字段 联合索引字段建议不超过5个 单表索引数量5个以内 使用自增id作为主键 编写sql update/delete 不使用limit，必须添加where 使用prepared、statement，提成性能，避免SQL注入 禁止使用 % 模糊查询(全表) 表中记录数 count(*) 用 join 链接替代 嵌套查询 尽量不使用 hints 查询拒绝 select * ，避免对索引字段使用 函数或计算操作 1where new_id = "123456" (where upper(id)) 如果 new_id 是 varchar 则使用 new_id = &quot;123456&quot; 比使用 new_id = 123456 的效率高很多倍 使用 where upper(id) 的效率很低]]></content>
      <categories>
        <category>Java后端</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库基础]]></title>
    <url>%2F2019%2F03%2F30%2Fmysql-basics%2F</url>
    <content type="text"><![CDATA[我坚信在行动之前，必须先有足够的观察和知识。 - 奇异博士 持久化操作：保存到数据库 主键：用户表里的id，唯一标识 外键：另一个表里引用的用户id，外键 下载mysql 配置环境 更改密码：a12345678 Navicat Premium for Mac的破解教程 注意时间戳是今天的时间-2019-02-20 12:00:00 命令行操作(一般来说关键字都用大写)： 12alias mysql=/usr/local/mysql/bin/mysqlalias mysqladmin=/usr/local/mysql/bin/mysqladmin 启动mysql mysql // 更换密码： mysqladmin -u root -p password 登录： mysql -u root -p 数据库操作 ;是结束符 1.创建数据库create database mysql_0219; 2.查看所有数据库show databases; 3.使用数据库use mysql_0219; 4.删除数据库drop database mysql_0219; 5.查看数据库状态status (注意编码：utf-8) 表的创建与管理: 1.创建表create table t_user1(id int,name varchar(20),age int,birthday date); 2.修改表alter table t_user1 rename t_user2; 3.查看具体表desc t_user2; 4.查看所有表show tables; 5.删除drop table t_user2; 6.表中添加字段 12alter table 表名称 add 字段名称 字段类型alter table t_user1 add sex varchar(3); 7.修改表中的字段 123alter table t_user1 change name user_name varchar(3);// 更改表的类型名称 布尔为 tinyint(1)alter table t_user1 modify user_name varchar(2); 8.删除表重的字段alter table t_user1 drop birthday; 表数据更新： 1.数据插入insert into t_user1(id,user_name,age,sex) values(&#39;1&#39;,&#39;ad&#39;,&#39;22&#39;,&#39;男&#39;); 2.查看数据select * from t_user1; 3.数据更新 1234单条update t_user1 set user_name=&apos;admin&apos; where id=1;多条update t_user1 set age=33,sex=&apos;女&apos; where id=1; 4.删除数据 12delete from t_user1 where id =2;delete from t_user1;(清空表) 约束条件非空约束 唯一约束 主键约束 主外键约束 图形化连接: 使用 Navicat for MySQL 输入密码：a123456789 新建查询创建 非空约束：1234567891011CREATE TABLE t_user2(id int,name VARCHAR(2) not null);show TABLES;INSERT INTO t_user2(id,name) VALUES(1,23);-- INSERT INTO t_user2(id,name) VALUES(1,null);SELECT * FROM t_user2; 唯一约束：12345678910CREATE TABLE t_user3(id int,name VARCHAR(30) not null,email VARCHAR(20) UNIQUE -- 唯一约束，邮箱不允许重复);INSERT INTO t_user3(id,name,email) VALUES(1,23,'110@email.com');INSERT INTO t_user3(id,name,email) VALUES(2,333,'111@email.com');SELECT * FROM t_user3; 主键约束：12345678910DROP TABLE t_user3;CREATE TABLE t_user3(id INT PRIMARY KEY AUTO_INCREMENT, -- 主键唯一不能为null，自增name VARCHAR(30) not null,email VARCHAR(20) UNIQUE -- 唯一约束，邮箱不允许重复);INSERT INTO t_user3(name,email) VALUES(23,'110@email.com');INSERT INTO t_user3(name,email) VALUES(2223,'112220@email.com'); 主外键约束：一般不会建，不能单独删除这个约束表。1234567891011121314151617CREATE TABLE t_user(id INT PRIMARY KEY AUTO_INCREMENT, -- 主键不能为 null，且不能重复，自增name VARCHAR(30) not null);CREATE TABLE t_order(id INT PRIMARY KEY AUTO_INCREMENT, -- 主键不能为 null，且不能重复，自增order_name VARCHAR(30),user_id int,CONSTRAINT user_id_fk FOREIGN key (user_id) REFERENCES t_user(id) -- 添加外键);INSERT INTO t_user(name) VALUES('amdin');SELECT * FROM t_user;INSERT INTO t_order(order_name,user_id) VALUES('订单1',1);INSERT INTO t_order(order_name,user_id) VALUES('订单2',2);// 报错SELECT * FROM t_order; Mysql的备份与恢复备份导出数据库： mysqldump -u root -p mysql_0219&gt;/Users/jingbin/Documents/LearningFile/S-Mybatis/mysql_0219.sql; 一、Mac os导出Mysql数据库 1.打开终端， 2.执行： cd 要导出到的目录 （如：cd /Users/jingbin/Documents/LearningFile/mysql） 3.执行： 1234 alias mysqldump=/usr/local/mysql/bin/mysqldump mysqldump -u root -p 要导出的数据库名&gt;名字随意.sql （如：mysqldump -u root -p mysql_0219&gt;mysql_0219.sql;） 输入数据密码此时，会在/Users/jingbin/Documents/LearningFile/mysql中发现已经导出的.sql文件：mysql_0219.sql。 导出数据库里对应的表： 1mysqldump -u root -p mysql_0219 t_user&gt;mysql_0219_user.sql; 恢复123456create database mysql_back;use mysql_back;show tables;source /Users/jingbin/Documents/LearningFile/mysql/mysql_0219_user.sqlshow tables;select * from t_user;]]></content>
      <categories>
        <category>Java后端</category>
      </categories>
      <tags>
        <tag>MySql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven基础]]></title>
    <url>%2F2019%2F03%2F29%2Fmaven-basics%2F</url>
    <content type="text"><![CDATA[真正的价值并不在人生的舞台上，而在我们扮演的角色中。 - 席勒/画家 Maven基础 Mac中host设置方法 IntelliJ IDEA 2018 破解过程 jdk1.8 File Encodings 全部utf-8 企业做法 - Maven 新建 maven 普通项目 quickstart web项目 webapp GAV坐标：GroupId 组织 ArtifactId 项目 Version 版本 新建的时候，setting.xml第一次需要新建，并配置本地仓库地址 配置自动导入，maven - inporting Maven install 打包部署 建web项目： Maven - webapp 默认建立没有java目录 - 手动创建Java目录 web项目打包格式：war 不适合给三方团队使用。 关联web容器： 顶部导航栏 - Add Configuration - 加号 - Tomcat Server local 下载tomcat : http://tomcat.apache.org/download-80.cgi 部署： 顶部导航栏 - Add Configuration - 加号 - Tomcat Server local - Deployment - 加号 “/web_war”？“/” 不用改 maven - install - 开始键部署 多模块开发： 父子项目 - 选择站点模式 - site-simple 目的：让父项目来管理所有子项目的jar包 server引用dao的代码： 123456&lt;!--导入dao--&gt;&lt;dependency&gt; &lt;groupId&gt;me.jing&lt;/groupId&gt; &lt;artifactId&gt;jd-dao&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt;&lt;/dependency&gt; 直接右键 - Run]]></content>
      <categories>
        <category>Java后端</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度]]></title>
    <url>%2F2019%2F03%2F27%2Fcomplexity-analysis-next%2F</url>
    <content type="text"><![CDATA[在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。 最好情况时间复杂度（best case time complexity）、 最坏情况时间复杂度（worst case time complexity）、 平均情况时间复杂度（average case time complexity）、 均摊时间复杂度（amortized time complexity） 最好、最坏情况时间复杂度首先看这段代码： 123456789// n 表示数组 array 的长度int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123; if (array[i] == x) pos = i; &#125; return pos;&#125; 比较明显：这段代码的复杂度是 O(n)，其中，n 代表数组的长度。 优化一下： 123456789101112// n 表示数组 array 的长度int find(int[] array, int n, int x) &#123; int i = 0; int pos = -1; for (; i &lt; n; ++i) &#123; if (array[i] == x) &#123; pos = i; break; &#125; &#125; return pos;&#125; 要查找的变量 x 可能出现在数组的任意位置 如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。 但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。 所以，不同的情况下，这段代码的时间复杂度是不一样的。 为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。 最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。 同理，最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。 平均情况时间复杂度借助刚才查找变量 x 的例子来给你解释: 要查找的变量 x 在数组中的位置，有 n+1 种情况：在数组的 0～n-1 位置中和不在数组中。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即： (1+2+3+…+n+n)/(n+1) = n(n+3)/2(n+1) 我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。 但是计算过程稍微有点儿问题。究竟是什么问题呢？我们刚讲的这 n+1 种情况，出现的概率并不是一样的。我带你具体分析一下。 我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。 因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样： 这个值就是概率论中的加权平均值，也叫作期望值，所以平均时间复杂度的全称应该叫加权平均时间复杂度或者期望时间复杂度。 引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。 实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。 均摊时间复杂度大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。 123456789101112131415161718// array 表示一个长度为 n 的数组// 代码中的 array.length 就等于 nint[] array = new int[n];int count = 0;void insert(int val) &#123; if (count == array.length) &#123; int sum = 0; for (int i = 0; i &lt; array.length; ++i) &#123; sum = sum + array[i]; &#125; array[0] = sum; count = 1; &#125; array[count] = val; ++count;&#125; 我先来解释一下这段代码。这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并清空数组，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。 最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。 最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。 那平均时间复杂度是多少呢？答案是 O(1)。我们还是可以通过前面讲的概率论的方法来分析。 假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是： 至此为止，前面的最好、最坏、平均时间复杂度的计算，理解起来应该都没有问题。但是这个例子里的平均复杂度分析其实并不需要这么复杂，不需要引入概率论的知识。这是为什么呢？我们先来对比一下这个 insert() 的例子和前面那个 find() 的例子，你就会发现这两者有很大差别。 首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()第一个区别于 find() 的地方。 我们再来看第二个不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。 所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。 针对这种特殊的场景，我们引入了一种更加简单的分析方法：摊还分析法，通过摊还分析得到的时间复杂度我们起了一个名字，叫均摊时间复杂度。 那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？ 我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。你都理解了吗？ 均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。为了方便你理解、记忆，我这里简单总结一下它们的应用场景。如果你遇到了，知道是怎么回事儿就行了。 对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。 尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，但其实我个人认为，均摊时间复杂度就是一种特殊的平均时间复杂度，我们没必要花太多精力去区分它们。你最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。]]></content>
      <categories>
        <category>数据结构与算法之美</category>
      </categories>
      <tags>
        <tag>数据结构与算法之美</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？]]></title>
    <url>%2F2019%2F03%2F26%2Fcomplexity-analysis%2F</url>
    <content type="text"><![CDATA[T(n) = O(f(n)) 大 O 复杂度表示法12345678int cal(int n) &#123; int sum = 0; int i = 1; for (; i &lt;= n; ++i) &#123; sum = sum + i; &#125; return sum;&#125; 总的执行时间就是T(n) = (2n+2)*unit_time。记为：T(n) = O(n)； 所有代码的执行时间 T(n) 与每行代码的执行次数成正比。 1234567891011int cal(int n) &#123; int sum = 0; int i = 1; int j = 1; for (; i &lt;= n; ++i) &#123; j = 1; for (; j &lt;= n; ++j) &#123; sum = sum + i * j; &#125; &#125;&#125; 执行时间 T(n) = (2n2+2n+3)* unit_time。记为：T(n) = O(n2) 大 O 复杂度表示法： T(n) = O(f(n)) T(n): 表示代码执行的时间；n: 表示数据规模的大小；f(n): 表示每行代码执行的次数总和；O: 表示代码的执行时间T(n)与f(n)表达式成正比。 大 O 复杂度表示法时间上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度，简称时间复杂度。 时间复杂度分析 1.只关注循环执行次数最多的一段代码 2.加法法则：总复杂度等于量级最大的那段代码的复杂度 3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 几种常见时间复杂度实例分析虽然代码千差万别，但是常见的复杂度量级并不多。我稍微总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。 复杂度量级(按数量级递增) 多项式量级 常量阶 O(1) 对数阶 O(log n) 线性阶 O(n) 线性代数阶 O(nlogn) 平方阶 O(n²)、立方阶O(n³)…k次方阶O(n^{k}) 非多项式量级 指数阶 O(2^n) 阶乘积 O(n!) 1.O(1)首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。 123int i = 8;int j = 6;int sum = i + j; 我稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。 2.O(logn)、O(nlogn)对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。 1234i=1;while (i &lt;= n) &#123; i = i * 2;&#125; 根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。 从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的： 2^0 * 2^1 * 2^2 ... 2^k ... 2^n = m 3 n 所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。 现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？ 1234i=1;while (i &lt;= n) &#123; i = i * 3;&#125; 根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为 O(log3n)。 实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？ 我们知道，对数之间是可以互相转换的，log3n 就等于 log32 log2n，所以 O(log3n) = O(C log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：在采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。 如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。 3.O(m+n)、O(m*n)我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。老规矩，先看代码！ 123456789101112131415int cal(int m, int n) &#123; int sum_1 = 0; int i = 1; for (; i &lt; m; ++i) &#123; sum_1 = sum_1 + i; &#125; int sum_2 = 0; int j = 1; for (; j &lt; n; ++j) &#123; sum_2 = sum_2 + j; &#125; return sum_1 + sum_2;&#125; 从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。 针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)T2(n) = O(f(m) f(n))。 空间复杂度前面我讲过，时间复杂度的全称是渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系。类比一下，空间复杂度全称就是渐进空间复杂度（asymptotic space complexity），表示算法的存储空间与数据规模之间的增长关系。 举个例子： 1234567891011void print(int n) &#123; int i = 0; int[] a = new int[n]; for (i; i &lt;n; ++i) &#123; a[i] = i * i; &#125; for (i = n-1; i &gt;= 0; --i) &#123; print out a[i] &#125;&#125; 跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。 我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。 内容小节复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。]]></content>
      <categories>
        <category>数据结构与算法之美</category>
      </categories>
      <tags>
        <tag>数据结构与算法之美</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐几款常用的Chrome插件]]></title>
    <url>%2F2019%2F03%2F25%2Fchrome-plugin%2F</url>
    <content type="text"><![CDATA[天空既在我们的头上又在我们的脚下。 - 梭罗/作家 1.广告终结者用来清除网页上乱七八糟的广告，比如网站的竞价广告的显示，使自己想要的结果显示在前面。 2.The Great Suspender开很多页面时，用来释放很久没有浏览过的标签页，点击后再加载网页。 3.JSONView格式化json，如果是get请求，返回的json数据会结构清晰的显示在网页上。 4.Octotree看GitHub时，用来查看项目的目录结构，这个插件普及有段时间了。 5.Imagus添加后，将鼠标移到有图片链接的地方，就会显示图片大图。 6.捕捉网页截图 - FireShot的可以自动滚动截图，保存GitHub每日趋势图和自己仓库图等很有作用。 7.Dark Reader网页的黑夜模式。将网页的白底变成黑底，适合长时间看博客文章，找很久了。]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin | 2.Kotlin基础]]></title>
    <url>%2F2019%2F03%2F24%2Fkotlin-basics%2F</url>
    <content type="text"><![CDATA[上篇：《Kotlin | 1.定义和目的》 声明函数、变量、类、枚举以及类型 Kotlin中的控制结构 智能转换 抛出和处理异常 函数学习 函数和变量函数123456789101112131415/** * 求最大值 * if是表达式而不是语句，表达式有值，语句没有。 * java中所有的控制结构都是语句 * kotlin中除了循环以外大多数控制结构都是表达式 */ private fun max(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b &#125; /** * 如果函数体写在花括号中，我们说这个函数有代码块体。 * 如果直接返回了一个表达式体，他就有表达式体。 */ fun max2(a: Int, b: Int): Int = if (a &gt; b) a else b 变量可变变量和不可变变量 val - 不可变引用。 相当于Java的final变量。 var - 可变引用。 普通的Java变量。 在定义了val变量的代码块执行期间，val变量只能进行唯一一次初始化。但是，如果编译器能确保只有唯一一条初始化语句被执行，可以根据条件使用不同的值来初始化它： 1234567val message:Stringif (CanPerformOperation())&#123; message = "Success" // ...&#125; else&#123; message = "Failed"&#125; 注意：尽管val引用自身是不可变的，但是它指向的对象可能是可变的。例如： 12val languages = arrayListOf("Java") // 声明不可变引用languages.add("Kotlin") // 改变引用指向的对象 错误：类型不匹配 12var answer = 42answer = "no answer" 字符串模板1234567var a1 = 1val s1 = "a is $a1"a1 = 3// 模板中的任意表达式val s2 = "$&#123;s1.replace("is", "was")&#125;,but no is $a1"// a was 1, but now is 3Log.e("s2", s2) 和许多脚本语言一样，只需要在变量名称前加上 $ ，就可以在字符串字面值中引用局部变量。引用”$”需要转义“\$” 类和属性类在Kotlin中，public是默认的可见性，所以你能省略它。12345678public class Person &#123; private final String name; public Person(String name) &#123; this.name = name; &#125;&#125; —&gt; 1class Person(private val name: String) 属性123456789101112class PersonProperty &#123; // 只读属性：生成一个字段和一个简单的getter val name: String = "kotlin_hahaha" // 可写属性：一个字段、一个getter和一个setter var isMarried: Boolean = false fun set() &#123; isMarried = true &#125;&#125; 自定义访问器1234567891011121314151617/** * Created by jingbin on 2018/11/18. * 自定义访问器 * 也可以使用函数返回，实现和性能没有差别，唯一的差别是可读性 * 通常来说： * 如果描述的是类的特征(属性)，应该把它声明成属性。 */class Rectangle(val height: Int, val width: Int) &#123; // 函数表达式 可以赋值 val isSquare: Boolean // 声明属性的getter get() &#123; return height == width &#125;&#125; Kotlin源码布局：目录和包 1.把类和函数的声明放在包中，可以同级 123456789101112131415class Rectangle(val height: Int, val width: Int) &#123; // 函数表达式 可以赋值 val isSquare: Boolean // 声明属性的getter get() &#123; return height == width &#125;&#125;fun createRandomRectangle(): Rectangle &#123; val random = Random() return Rectangle(random.nextInt(), random.nextInt())&#125; Kotlin不区分导入的是类还是函数，而且，它允许使用import关键字导入任何种类的声明。可以直接导入顶层函数的名称。 2.导入其他包中的函数 1234// 导入函数的名称import com.kotlin.jingbin.kotlinapp.classproperty.createRandomRectangle// 导入其他包中的函数LogUtil.e(createRandomRectangle().isSquare) 包层级和java类似。 表示和处理选择: 枚举和”when”when结构，java中switch结构的替代品，但是更强大。智能转换。 枚举1.声明简单的枚举类123enum class SimpleColor &#123; RED, ORANGE&#125; 2.声明一个带属性的枚举类1234567891011121314enum class Color( // 声明枚举常量的属性 val r: Int, val g: Int, val b: Int) &#123; // 在每一个常量创建的时候指定属性值 RED(255, 0, 0), ORANGE(255, 165, 0), WELLOW(255, 255, 0), GREEN(0, 255, 0), BULE(0, 0, 255), INDIGO(75, 0, 130), VIILET(238, 130, 238);// 分号 fun rgb() = (r * 256 + g) * 256 + b&#125; 3.使用“when”处理枚举类1234567891011121314/** * 使用when处理枚举类: * 直接返回一个“when"表达式 */ fun getMnemonic(color: Color) = &#123; when (color) &#123; RED -&gt; "Richard" ORANGE -&gt; "Of" WELLOW -&gt; "Haha" // 合并多个选项 BULE, GREEN -&gt; "望穿" VIILET, INDIGO -&gt; "秋水" &#125; &#125; when1、在 when 结构中使用任意对象12345678910fun mix(c1: Color, c2: Color) = &#123; // when 表达式的实参可以是任何对象，它被检查是否与分支条件对等 when (setOf(c1, c2)) &#123; setOf(Color.RED, Color.YELLOW) -&gt; Color.ORANGE setOf(Color.BLUE, Color.YELLOW) -&gt; Color.GREEN setOf(Color.BLUE, Color.VIOLET) -&gt; Color.INDIGO // 如果没有任何其他分支匹配这里就会执行 else -&gt; throw Exception("Dirty color") &#125; &#125; 2、不带参数的 when12345678910fun minOptimized(c1: Color, c2: Color) = &#123; // 没有实参传给 when when &#123; (c1 == Color.RED &amp;&amp; c2 == Color.YELLOW) || (c2 == Color.RED &amp;&amp; c1 == Color.YELLOW) -&gt; Color.ORANGE (c1 == Color.BLUE &amp;&amp; c2 == Color.YELLOW) || (c2 == Color.BLUE &amp;&amp; c1 == Color.YELLOW) -&gt; Color.GREEN (c1 == Color.BLUE &amp;&amp; c2 == Color.VIOLET) || (c2 == Color.BLUE &amp;&amp; c1 == Color.VIOLET) -&gt; Color.INDIGO else -&gt; throw Exception("Dirty color") &#125; &#125; 3、智能转换：合并类型检查和转换1234567891011121314151617181920212223242526// 3.1表达式层次结构 interface Expr // 简单的值对象类，只有一个属性value，实现了Expr接口 class Num(val value: Int) : Expr // sum运算的实参可以是任何Expr: Num或者另一个Sum class Sum(val left: Expr, val right: Expr) : Expr /** * 3.2 使用 if 层叠对表达式求值 * 在 Kotlin 中，如果你检查过一个变量是某种类型，后面就不再需要转换它，可以就把它当作你检查过的类型使用。 * 事实上编译器为你执行了类型转换，我们把这种行为称为智能转换。 * */ fun eval(e: Expr): Int &#123; // is - instanceOf if (e is Num) &#123; // 显示的转换成类型 Num是多余的 val num = e as Num return num.value &#125; if (e is Sum) &#123; // 变量 e 被智能转换了类型 return eval(e.left) + eval(e.right) &#125; throw IllegalAccessException("Unknown expression") 4、重构：用“when”代替“if”123456789101112131415161718192021/** * Kotlin 中没有三元运算符，因为if有返回值 * 意味着: 可以用表达式语法重写eval函数，去掉return语句和花括号，使用if表达式作为函数体 */ // 4.1 使用用返回值的 if 表达式 fun eval2(e: Expr): Int = if (e is Num) &#123; e.value &#125; else if (e is Sum) &#123; eval2(e.right) + eval2(e.left) &#125; else &#123; throw IllegalAccessException("Unknown expression") &#125; // 4.2 使用 when 代替 if 层叠 fun eval3(e: Expr): Int = when (e) &#123; is Num -&gt; e.value is Sum -&gt; eval3(e.right) + eval3(e.left) else -&gt; throw IllegalAccessException("Unknown expression") &#125; 5、代码块作为 “if” 和 “when” 的分支1234567891011121314151617181920/** * 一个函数要么具有不是代码块的表达式函数体， * 要么具有包含显示return语句的代码块函数体 */ // 在分支中含有混合操作的 when fun evalWithLogging(e: Expr): Int = when (e) &#123; is Num -&gt; &#123; LogUtil.e("num: $&#123;e.value&#125;") e.value &#125; is Sum -&gt; &#123; val left = this.evalWithLogging(e.left) val right = this.evalWithLogging(e.right) LogUtil.e("Sum: $left + $right") // 代码块中最后的表达式就是结果 left + right &#125; else -&gt; throw IllegalAccessException("Unknown expression") &#125; 迭代事物: “when”循环和“for”循环1、“while” 循环Kotlin 有 while 循环和 do-while 循环，他们的语法和Java中相应的循环没有什么区别 2、迭代数字：区间和数列123456789101112131415161718192021222324 /** * 区间：区间本质上就是两个值之间的间隔，这两个值通常是数字：一个起始值，一个结束值。 * 使用 .. 运算符来表示区间 * 数列：你能用整数区间做的最基本的事情就是循环迭代其中所有的值。 * 如果你能迭代区间中所有的值，这样的区间被称作数列。 * */ val oneToTen = 1..10 // 使用 when 实现 Fizz-Buzz 游戏 fun fizzBuzz(i: Int) = when &#123; i % 15 == 0 -&gt; "FizzBuzz" i % 3 == 0 -&gt; "Fizz" i % 5 == 0 -&gt; "Buzz" else -&gt; "$i" &#125; for (i in 1..100) &#123;// LogUtil.e(fizzBuzz(i)) &#125; // 倒序 只计偶数 [使用 until 函数可以标识：不包含指定结束值的半闭合区间] for (i in 100 downTo 0 step 2) &#123; LogUtil.e(fizzBuzz(i)) &#125; 3、迭代map123456789101112131415161718// 使用 TreeMap 让键排序 val binaryReps = TreeMap&lt;Char, String&gt;() // 创建字符区间 包括 F for (c in 'A'..'F') &#123; // 把 ASCII 码转换成二进制 val binaryString = Integer.toBinaryString(c.toInt()) binaryReps[c] = binaryString &#125; // 迭代 map ，把键和值赋值给两个变量 for ((letter, binary) in binaryReps) &#123; LogUtil.e("$letter = $binary") &#125; // 迭代集合时 使用下标 val list = arrayListOf("10", "11", "1001") for ((index, element) in list.withIndex()) &#123; LogUtil.e("$index = $element") &#125; 4、使用 “in” 检查集合和区间的成员123456789101112131415161718192021222324252627282930313233343536 // 1.使用 in 检查区间的成员 fun isLetter(c: Char) = c in 'a'..'z' || c in 'A'..'Z' fun isNoDigitic(c: Char) = c !in '0'..'9' // 2.用 in 检查作为when分支 fun recognize(c: Char) = when (c) &#123; in '0'..'9' -&gt; "In's a digit!" in 'a'..'z', in 'A'..'Z' -&gt; "In's a letter!" else -&gt; "I don't know.." &#125;``` ### Kotlin中的异常```kotlin// val 不能再赋值，相当于 final val percentage = 0 if (percentage !in 0..100) &#123; throw IllegalAccessException("A percentage value must be between 0 and 100: $percentage") &#125; /** * 和所有其他类一样，不必使用 new 关键字来创建异常实例。 * 和java不同的是，Kotlin中throw结构是一个表达式，能作为另一个表达式的一部分使用： */ val number = 8 val percentage2 = if (number in 0..100) &#123; number &#125; else &#123; // throw 是一个表达式 throw IllegalAccessException("A percentage value must be between 0 and 100: $percentage") &#125; val bufferedReader = BufferedReader(StringReader("239")) 1、try catch 和 finally12345678910111213// 不必显式地知道这个函数可能抛出的异常 fun readNumber(reader: BufferedReader): Int? &#123; try &#123; val line = reader.readLine() return Integer.parseInt(line) // 异常类型在右边 &#125; catch (e: NumberFormatException) &#123; return null &#125; finally &#123; reader.close() &#125; &#125; 2、try 作为表达式12345678910fun readNumber2(reader: BufferedReader) &#123; val number = try &#123; // 没有任何异常发生时 使用这个值 Integer.parseInt(reader.readLine()) &#125; catch (e: NumberFormatException) &#123;// return // 发生异常时的情况下使用 null null &#125; &#125; 总结 fun 关键字用来声明函数。Val关键字和var关键字分别用来声明只读变量和可变变量。 字符串模板帮组你避免繁琐的字符串拼接。在变量名称前加上 $ 前缀或者用 ${} 包围一个表达式，来把值注入到字符串中。 值对象类在Kotlin中以简洁的方式表示。 熟悉的if现在是带返回值的表达式。 when表达式类似于Java中的switch但功能更强大。 在检查过变量具有某种类型之后不必显示地转换它的类型:编译器使用智能转换字段帮你完成。 for、while、和 do-while 循环与java类似，但是for循环现在更加方便，特别是当你需要迭代map的时候，又或是迭代集合需要下标的时候。 简洁的语法 1..5 会创建一个区间。区间和数列允许Kotlin在for循环中使用统一的语法和同一套抽象机制，并且还可以使用in运算符和!in运算符来检查值是否属于某个区间。 Kotlin中的异常处理和java非常相似，除了Kotlin不要求你声明函数可以抛出异常。]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin | 1.定义和目的]]></title>
    <url>%2F2019%2F03%2F22%2Fkotlin-define%2F</url>
    <content type="text"><![CDATA[书籍：《Kotlin实战》 本章内容包括： Kotlin 的基本示范 Kotlin 语言的主要特征 Android 和服务端开发的可能性 Kotlin 与其他语言的区别 用 Kotlin 编写并运行代码 Kotlin和Java一样是一种静态类型的编程语言。编译时即可检查代码正确性。动态语言：Groovy,JRuby。 根据上下问判断变量类型： val x=1 性能、可靠性、可维护性、工具支持。 支持函数式编程风格，不强制使用： 函数类型，允许函数接受其他函数作为参数，或者返回其他函数。 lambda表达式 数据类，提供了创建不可变值对象的简明语法 标准库中包含了丰富的API集合，让你用函数式编程风格操作对象和集合。 自动检查空指针： val s: String? = null 可以为null，也会检查，禁止可能导致的空指针 val s2: String = “” 不能为null 避免类型转换异常： 12if(value is String) 检查类型 println(value.toUpperCase()) 调用该类型的方法 源代码文件存放在后缀名为.kt的文件中，编辑器生成.class文件。 AndriodSdudio中使用：“Setting(设置) - Plugins(插件) - Install JetBrains Plugin - Kotlin”]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android Span在项目中的几种使用方式]]></title>
    <url>%2F2019%2F03%2F21%2Fandroid-span%2F</url>
    <content type="text"><![CDATA[1.改变文字颜色 2.改变文字大小 3.改变文字颜色 并 添加点击事件 4.增加边框和改变颜色及字体大小 1.改变文字颜色 ForegroundColorSpan 1234567891011121314151617181920212223242526/** * 自定义颜色 * * @param content 全部文本 * @param keyWord 需要变色的关键字 * @param color 颜色 */public static SpannableStringBuilder getSpan(String content, String keyWord, int color) &#123; SpannableStringBuilder span = null; if (content == null) &#123; span = new SpannableStringBuilder(""); return span; &#125; else &#123; int startIndex = 0; int endIndex = 0; if (keyWord != null) &#123; startIndex = content.indexOf(keyWord); endIndex = content.indexOf(keyWord) + keyWord.length(); span = new SpannableStringBuilder(content); if (startIndex != -1 &amp;&amp; startIndex &lt;= endIndex) &#123; span.setSpan(new ForegroundColorSpan(getResoure().getColor(color)), startIndex, endIndex, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; &#125; return span; &#125;&#125; 2.改变文字大小 AbsoluteSizeSpan 123456789101112131415161718192021222324252627/** * 设置单个字符串的文字大小 * * @param content 全部文字 * @param keyWord 需要改变的文本 * @param spValue 需要设置的文本大小 */public static SpannableStringBuilder getSizeSpan(String content, String keyWord, float spValue) &#123; SpannableStringBuilder span = null; if (TextUtils.isEmpty(content)) &#123; span = new SpannableStringBuilder(""); return span; &#125; else &#123; int startIndex = 0; int endIndex = 0; if (keyWord != null) &#123; startIndex = content.indexOf(keyWord); endIndex = content.indexOf(keyWord) + keyWord.length(); span = new SpannableStringBuilder(content); if (startIndex != -1 &amp;&amp; startIndex &lt;= endIndex) &#123; float px = DensityAppUtil.sp2px(spValue); span.setSpan(new AbsoluteSizeSpan((int) px), startIndex, endIndex, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; &#125; return span; &#125;&#125; 3.改变文字颜色 并 添加点击事件 ClickableSpan 1234567891011121314151617181920212223242526272829public class ButtonSpan extends ClickableSpan &#123; View.OnClickListener onClickListener; private Context context; private int colorId; public ButtonSpan(Context context, View.OnClickListener onClickListener) &#123; this(context, onClickListener, R.color.color_theme); &#125; public ButtonSpan(Context context, View.OnClickListener onClickListener, int colorId) &#123; this.onClickListener = onClickListener; this.context = context; this.colorId = colorId; &#125; @Override public void updateDrawState(TextPaint ds) &#123; ds.setColor(context.getResources().getColor(colorId)); ds.setUnderlineText(false); &#125; @Override public void onClick(View widget) &#123; if (onClickListener != null) &#123; onClickListener.onClick(widget); &#125; &#125;&#125; 设置：123456789101112131415// content为全部的字符串，keyWord为需要改变的字符串SpannableString spannableString = new SpannableString(content);ButtonSpan span = new ButtonSpan(v.getContext(), new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; // do something.. &#125; &#125;&#125;, R.color.color_theme);spannableString.setSpan(span, content.indexOf(keyWord), content.indexOf(keyWord + keyWord.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);//不设置 没有点击事件titleTop.setMovementMethod(LinkMovementMethod.getInstance());//设置点击后的颜色为透明titleTop.setHighlightColor(Color.TRANSPARENT);titleTop.setText(spannableString); 4.增加边框和改变颜色及字体大小 ReplacementSpan 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TagSpan extends ReplacementSpan &#123; // span width private int mSize; // text and background wireframe color private int mColor; // tag text size private int mTextSizePx; // background radius private int mRadiusPx; // background wireframe right margin private int mRightMarginPx; public TagSpan(int color, int textSizePx, int radiusPx, int rightMarginPx) &#123; mColor = color; mTextSizePx = textSizePx; mRadiusPx = radiusPx; mRightMarginPx = rightMarginPx; &#125; @Override public int getSize(@NonNull Paint paint, CharSequence text, int start, int end, Paint.FontMetricsInt fm) &#123; mSize = (int) paint.measureText(text, start, end) + mRightMarginPx; return mSize; &#125; @Override public void draw(@NonNull Canvas canvas, CharSequence text, int start, int end, float x, int top, int y, int bottom, Paint paint) &#123; drawTagRect(canvas, x, y, paint); drawTagText(canvas, text, start, end, y, paint); &#125; private void drawTagRect(Canvas canvas, float x, int y, Paint paint) &#123; paint.setColor(mColor); paint.setAntiAlias(true); Paint.FontMetricsInt fontMetrics = paint.getFontMetricsInt(); final float strokeWidth = paint.getStrokeWidth(); RectF oval = new RectF(x + strokeWidth + 0.5f, y + fontMetrics.ascent, x + mSize + strokeWidth + 0.5f - mRightMarginPx, y + fontMetrics.descent); paint.setStyle(Paint.Style.STROKE); canvas.drawRoundRect(oval, mRadiusPx, mRadiusPx, paint); &#125; private void drawTagText(Canvas canvas, CharSequence text, int start, int end, int y, Paint paint) &#123; paint.setTextSize(mTextSizePx); paint.setColor(mColor); paint.setAntiAlias(true); paint.setTextAlign(Paint.Align.CENTER); Paint.FontMetrics fontMetrics = paint.getFontMetrics(); final int textCenterX = (mSize - mRightMarginPx / 2) / 2; int textBaselineY = (int) (y - fontMetrics.descent / 2); final String tag = text.subSequence(start, end).toString(); canvas.drawText(tag, textCenterX, textBaselineY, paint); &#125;&#125; 调用静态方法：1234567891011121314151617181920212223242526272829/** * 增加边框和改变颜色及字体大小 * * @param content 内容 * @param keyWord 关键字 * @param color 颜色 * @param sp 字体sp，需转换为对应的px */public static SpannableStringBuilder getSpan(String content, String keyWord, int color, int sp) &#123; SpannableStringBuilder span = null; if (content == null) &#123; span = new SpannableStringBuilder(""); return span; &#125; else &#123; int startIndex = 0; int endIndex = 0; if (!TextUtils.isEmpty(keyWord)) &#123; startIndex = content.indexOf(keyWord); endIndex = content.indexOf(keyWord) + keyWord.length(); span = new SpannableStringBuilder(content); if (startIndex != -1 &amp;&amp; startIndex &lt;= endIndex) &#123; // 圆角 右边距 span.setSpan(new TagSpan(color, (int) sp, 4, 8), startIndex, endIndex, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE); &#125; &#125; return span; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>span</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git commit 规范]]></title>
    <url>%2F2019%2F03%2F20%2Fgit-commit%2F</url>
    <content type="text"><![CDATA[与道人之短，勿说己之长；人骂之一笑，人誉之一笑。 - 齐白石/国画大师 git提交估计也快上万次了，每次不知道怎么写好，今天在网上找到一套规范然后加上常用的一些，总结出来一套 Git commit 规范，没有强制的规定，主要是翻阅以前的日志会更清晰。 type: description type 是 commit 的类别，只允许如下几种标识： fix: 修复bug add: 新功能 update: 更新 refactor : 某个已有功能重构 perf : 性能优化 style : 代码格式改变 test: 增加测试代码 docs : 文档改变 revert: 撤销上一次的commit build: 构建工具或构建过程等的变动，如：关联包升级等 description 是对本次提交的简短描述： 不超过50个字符。 推荐以动词开头，如： 设置、修改、增加、删减、撤销等]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TabLayout的几种用法]]></title>
    <url>%2F2019%2F03%2F19%2Fandroid-tablayout%2F</url>
    <content type="text"><![CDATA[1.结合ViewPager使用 2.点击滑动选中，类似RadioGroup的效果 3.点击滑动到屏幕中央，并再次点击可取消 1.结合ViewPager使用这是最常见的用法了，实现也比较简单。 布局文件：123456789101112131415&lt;android.support.design.widget.TabLayout android:id="@+id/tab_book" android:layout_width="match_parent" android:layout_height="38dp" app:tabBackground="@drawable/ripple_tab_bg" app:tabIndicatorColor="@color/colorTheme" app:tabSelectedTextColor="@color/colorTheme" app:tabTextColor="@color/colorTabText" /&gt;&lt;android.support.v4.view.ViewPager android:id="@+id/vp_book" android:layout_width="match_parent" android:layout_height="match_parent"&gt;&lt;/android.support.v4.view.ViewPager&gt; 对应的Activity页面：123456789101112131415161718192021222324252627282930313233343536public class WanFragment extends BaseFragment&lt;NoViewModel,FragmentBookBinding&gt; &#123; private ArrayList&lt;String&gt; mTitleList = new ArrayList&lt;&gt;(3); private ArrayList&lt;Fragment&gt; mFragments = new ArrayList&lt;&gt;(3); @Override public void onActivityCreated(@Nullable Bundle savedInstanceState) &#123; super.onActivityCreated(savedInstanceState); showLoading(); initFragmentList(); MyFragmentPagerAdapter myAdapter = new MyFragmentPagerAdapter(getChildFragmentManager(), mFragments, mTitleList); bindingView.vpBook.setAdapter(myAdapter); // 左右预加载页面的个数 bindingView.vpBook.setOffscreenPageLimit(2); myAdapter.notifyDataSetChanged(); bindingView.tabBook.setTabMode(TabLayout.MODE_FIXED); bindingView.tabBook.setupWithViewPager(bindingView.vpBook); showContentView(); &#125; @Override public int setContent() &#123; return R.layout.fragment_book; &#125; private void initFragmentList() &#123; mTitleList.clear(); mTitleList.add("玩安卓"); mTitleList.add("知识体系"); mTitleList.add("导航数据"); mFragments.add(BannerFragment.newInstance()); mFragments.add(TreeFragment.newInstance()); mFragments.add(NaviFragment.newInstance()); &#125;&#125; 设置后就可以达到切换滑动的效果。 2.点击滑动选中，类似RadioGroup的效果 不过它与RadioGroup不同在于它有下划线可以滑动，更动感…，如果产品经理要求这样实现，就可以派上用场了。 布局文件：12345678910111213141516171819202122232425262728293031323334353637383940&lt;android.support.design.widget.TabLayout android:id="@+id/tl_search" android:layout_width="match_parent" android:layout_height="30dp" android:background="@color/colorTheme" app:tabGravity="center" app:tabIndicatorColor="@color/colorWhite" app:tabMode="fixed" app:tabSelectedTextColor="@color/colorWhite" app:tabTextAppearance="@style/MyTabLayoutTextAppearance" app:tabTextColor="@color/colorWhiteHalf"&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="玩安卓" android:textColor="@color/colorWhite" android:textSize="12sp" /&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="干货 | 安卓" android:textColor="@color/colorWhite" android:textSize="12sp" /&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="干货 | 全部" android:textColor="@color/colorWhite" android:textSize="12sp" /&gt; &lt;android.support.design.widget.TabItem android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="网页" android:textColor="@color/colorWhite" android:textSize="12sp" /&gt; &lt;/android.support.design.widget.TabLayout&gt; 当然也可以在Activit动态添加，其中的一些颜色设置等就不细说了~：12345for (String bean : list) &#123; MyTabLayout.Tab tab = binding.tlSearch.newTab(); tab.setText(bean.getName()); binding.tlSearch.addTab(tab); &#125; 然后再监听点击的时候做处理：12345678910111213141516binding.tlSearch.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; // 选中 逻辑操作 (再次点击不会触发) &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; &#125;&#125;); 3.点击滑动到屏幕中央，并再次点击可取消 这样的效果很实用，很多App都会有这样的效果，以前我都是用HorizontalScrollView来实现的，设置点击的item滑动到屏幕中央。 后来想想TabLayout继承自HorizontalScrollView，选中也会自动滚动并居中，于是就选用了它来实现，相对于直接使用HorizontalScrollView代码量更少。 布局文件：1234567&lt;android.support.design.widget.TabLayout android:id="@+id/tl_tag" android:layout_width="match_parent" android:layout_height="40dp" app:tabIndicatorHeight="0dp" app:tabMode="scrollable" app:tabSelectedTextColor="@color/color_theme" /&gt; Activity里控制：123456789101112// 添加自定义Tabfor (int i = 0; i &lt; result.size(); i++) &#123; TabLayout.Tab tab = bindingView.tlTag.newTab(); bindingView.tlTag.addTab(tab.setCustomView(getTabView(result.get(i).getName())));&#125;// 默认 手动设置 position=0的Tab不选中if (bindingView.tlTag.getTabAt(0) != null &amp;&amp; bindingView.tlTag.getTabAt(0).getCustomView() != null) &#123; bindingView.tlTag.getTabAt(0).getCustomView().setSelected(false);&#125;// 添加监听addTagListener(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657 // 哪个tag被选择过private int tagSelectPosition = 0;// 是否被选中private boolean tagSelect = false;// 主要处理取消选中的状态private void addTagListener() &#123; bindingView.tlTag.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; @Override public void onTabSelected(TabLayout.Tab tab) &#123; // // 切换到此tab，则设置已选中position和选中的状态 tagSelectPosition = tab.getPosition(); tagSelect = true; // do something.. &#125; @Override public void onTabUnselected(TabLayout.Tab tab) &#123; &#125; @Override public void onTabReselected(TabLayout.Tab tab) &#123; // // Tab再次被点击会走这里 // 之前手动 [取消] 的tab角标 初始值为0 if (tagSelectPosition == tab.getPosition()) &#123; if (tagSelect) &#123; // tab之前被选中，则手动取消 if (bindingView.tlTag.getTabAt(tab.getPosition()) != null &amp;&amp; bindingView.tlTag.getTabAt(tab.getPosition()).getCustomView() != null) &#123; tagSelectPosition = tab.getPosition(); tagSelect = false; bindingView.tlTag.getTabAt(tab.getPosition()).getCustomView().setSelected(false); // do something.. &#125; &#125; else &#123; // tab之前被取消，则手动将其选中 if (bindingView.tlTag.getTabAt(tab.getPosition()) != null &amp;&amp; bindingView.tlTag.getTabAt(tab.getPosition()).getCustomView() != null) &#123; tagSelectPosition = tab.getPosition(); tagSelect = true; // do something.. &#125; &#125; &#125; else &#123; // 一般不会触发，以防万一 if (bindingView.tlTag.getTabAt(tab.getPosition()) != null &amp;&amp; bindingView.tlTag.getTabAt(tab.getPosition()).getCustomView() != null) &#123; tagSelectPosition = tab.getPosition(); tagSelect = true; // do something.. &#125; &#125; &#125; &#125;);&#125; 相关代码第一部分：WanFragment.java第二部分：SearchActivity.java 完整Demo项目：https://github.com/youlookwhat/CloudReader 第三部分因为是公司项目，暂时只有上面的代码片段，已包含所有的相关代码，如果有问题请留言，我会重新整理在Demo里。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android MVC、MVP、MVVM、MVP-databinding 架构单元示例]]></title>
    <url>%2F2019%2F03%2F18%2Fandroid-mvc-mvp-mvvm%2F</url>
    <content type="text"><![CDATA[生命不必每时每刻都要冲刺，低沉时就当是放一个悠长假期。 - 北川悦吏子/编剧 GitHub地址：ProjectPatternStudy 基本Android项目都采用MVC、MVP、MVVM架构，个人认为软件架构没有绝对的优劣之分，大家都各有利弊。 如果页面比较单一，采用MVC也未尝不可； 如果需要稳定性高，解耦性强就可以选用MVP，使M层与V层分离，结构更清晰； 如果想尝鲜(其实已经有段时间了)，少写接口，高效，也可以使用MVVM； 阮一峰《MVC，MVP 和 MVVM 的图示》总结的非常简练，这里相当于扩展了一下，对于不太懂的人可能会用处更大。 MVP-databinding：是使用MVP架构，但是布局使用databinding设置值，也是行之有效的一种，也可以满足你的需求。 MVCModel-View-Controller，最常见的软件架构之一。 视图（View）：用户界面。 控制器（Controller）：业务逻辑 模型（Model）：数据保存 如Avtivity里的一个点击事件：1234567891011121314151617181920/** * 将业务逻辑封装在Model里, 但C(Activity)层可以和Model直接交互, 交互完后根据显示结果来调整V层(如 显示数据) */EssayModel essayModel = new EssayModel(LoadDataActivity.this);essayModel.getEssay(3, new EssayModel.OnEssayListener() &#123; @Override public void onSuccess(List&lt;Essay&gt; list) &#123; /** * 直接使用list,得到List的逻辑都放在mode层 */ if (list != null &amp;&amp; list.get(0) != null) &#123; tvViewUpdata.setText("MVC 更新数据: " + list.get(0).getTitle()); &#125; &#125; @Override public void onError() &#123; &#125;&#125;); 如果一个页面比较简单，只有简单的几个操作，也不会经常去改可以使用此方式；如果页面逻辑比较复杂，接口请求都有好几个，那么不建议使用MVC，因为代码会全部堆积在一个Activity里面，会显得非常之冗余。 MVPMVP 模式将 Controller 改名为 Presenter，同时改变了通信方向。 通过P层将Model层与View层解耦，同时P与V、P与M可以相互通信。下面举个登录的例子：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class UserLoginActivity extends AppCompatActivity implements IUserLoginView &#123; @BindView(R.id.et_username) EditText etUsername; @BindView(R.id.et_password) EditText etPassword; @BindView(R.id.bt_login) Button btLogin; @BindView(R.id.bt_clear) Button btClear; @BindView(R.id.progress) ProgressBar progress; @BindView(R.id.activity_user_login) RelativeLayout activityUserLogin; private UserLoginPresenter userLoginPresenter = new UserLoginPresenter(this); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_user_login); ButterKnife.bind(this); setTitle("用户登录（MVP）"); initListener(); &#125; private void initListener() &#123; btLogin.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; userLoginPresenter.login(); &#125; &#125;); btClear.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; userLoginPresenter.clear(); &#125; &#125;); &#125; @Override public String getUserName() &#123; return etUsername.getText().toString().trim(); &#125; @Override public String getPassword() &#123; return etPassword.getText().toString().trim(); &#125; @Override public void clearUserName() &#123; etUsername.setText(""); &#125; @Override public void clearPassword() &#123; etPassword.setText(""); &#125; @Override public void showLoading() &#123; progress.setVisibility(View.VISIBLE); &#125; @Override public void hindLoading() &#123; progress.setVisibility(View.GONE); &#125; @Override public void toMainActivity() &#123; Toast.makeText(this, "login success , to MainActivity!", Toast.LENGTH_SHORT).show(); &#125; @Override public void showFailedError() &#123; Toast.makeText(this, "login failed!", Toast.LENGTH_SHORT).show(); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Created by jingbin on 2016/11/3. * Presenter是用作Model和View之间交互的桥梁，那么应该有什么方法呢？ * 其实也是主要看该功能有什么操作，比如本例，两个操作:login和clear。 */public class UserLoginPresenter &#123; // view private IUserLoginView iUserLoginView; // model private UserBiz mUserBiz; private Handler mHandler = new Handler(); public UserLoginPresenter(IUserLoginView iUserLoginView) &#123; this.iUserLoginView = iUserLoginView; this.mUserBiz = new UserBiz(); &#125; public void login() &#123; //view iUserLoginView.showLoading(); // model mUserBiz.login(iUserLoginView.getUserName(), iUserLoginView.getPassword(), new OnLoginListener() &#123; @Override public void loginSuccess(User user) &#123; // 需要在UI线程中执行 mHandler.post(new Runnable() &#123; @Override public void run() &#123; iUserLoginView.toMainActivity(); iUserLoginView.hindLoading(); &#125; &#125;); &#125; @Override public void loginFailed() &#123; // 需要在UI线程中执行 mHandler.post(new Runnable() &#123; @Override public void run() &#123; iUserLoginView.hindLoading(); iUserLoginView.showFailedError(); &#125; &#125;); &#125; &#125;); &#125; public void clear() &#123; iUserLoginView.clearUserName(); iUserLoginView.clearPassword(); &#125;&#125; 12345678910111213141516171819202122public interface IUserLoginView &#123; // login说明了要有用户名、密码，那么对应两个方法： String getUserName(); String getPassword(); void clearUserName(); void clearPassword(); // 再者login是个耗时操作，我们需要给用户一个友好的提示，一般就是操作ProgressBar，所以再两个： void showLoading(); void hindLoading(); // login当然存在登录成功与失败的处理，我们主要看成功我们是跳转Activity，而失败可能是去给个提醒： void toMainActivity(); void showFailedError();&#125; 用户点击登录，触发点击事件，然后通过P层userLoginPresenter，调用登录的方法login()，方法里面会通过Model层mUserBiz.login()去做一些数据请求操作的处理，然后得到相应的数据返回。这里看到Model层的数据处理操作放在P层里，是不与V层直接交互的。然后M层得到数据后回调，P层根据相应的数据，显示不同的UI，如toMainActivity,showFailedError等，这样V层只会出现一些基本的显示逻辑的处理。 MVVMMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。 12345678910111213141516171819202122232425262728293031323334353637/** * 简单的MVVM + data-binding案例: * 以点击一下按钮然后年龄会+2 为例 * * @author jingbin */public class ChangeAgeActivity extends AppCompatActivity &#123; private ChangeAgeViewModel viewModel; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); ActivityChangeAgeBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_change_age); setTitle("MVVM + data-binding"); viewModel = ViewModelProviders.of(this).get(ChangeAgeViewModel.class); binding.setViewModel(viewModel); binding.setButtonname("年龄+2"); /**监听年龄的变化*/ viewModel.desc.observe(this, new Observer&lt;String&gt;() &#123; @Override public void onChanged(@Nullable String desc) &#123; Log.e("desc", desc); &#125; &#125;); binding.btAge.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; viewModel.change(); &#125; &#125;); &#125;&#125; 12345678910111213141516171819202122232425/** * @author jingbin */public class ChangeAgeViewModel extends AndroidViewModel &#123; final MutableLiveData&lt;String&gt; desc = new MutableLiveData&lt;&gt;(); public final ObservableField&lt;String&gt; age = new ObservableField&lt;&gt;(); public ChangeAgeViewModel(@NonNull Application application) &#123; super(application); age.set(String.valueOf(23)); &#125; void change() &#123; String value = age.get(); if (!TextUtils.isEmpty(value)) &#123; Integer integer = Integer.valueOf(value); // 改变age的值 布局里的值直接改变 age.set(String.valueOf(integer + 2)); desc.setValue("年龄改变:" + age.get()); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools"&gt; &lt;!-- View + ViewModel--&gt; &lt;data&gt; &lt;variable name="viewModel" type="com.example.jingbin.projectstru.mvvm.ChangeAgeViewModel" /&gt; &lt;variable name="buttonname" type="String" /&gt; &lt;/data&gt; &lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:orientation="vertical" android:padding="25dp"&gt; &lt;TextView android:id="@+id/tv_mvvm" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="年龄" android:textColor="@color/colorPrimary" /&gt; &lt;TextView android:id="@+id/tv_age" android:layout_width="wrap_content" android:layout_height="wrap_content" android:layout_marginTop="10dp" android:layout_marginBottom="10dp" android:text="@&#123;viewModel.age&#125;" /&gt; &lt;Button android:id="@+id/bt_age" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="@&#123;buttonname&#125;" /&gt; &lt;/LinearLayout&gt;&lt;/layout&gt; 可以看出，MVVM比MVP少了对应View的接口文件，这样更简洁了，而且，改变ViewModel里的值，则xml文件对应的值也会对应改变。如果通过手动setText()，则ViewModel里的值也会得到改变。通过这一层关系，我们可以通过数据去操控View里的显示，所以才可以去除掉对应View的接口文件。 MVP-databinding基本实现了MVC，MVP，MVVM后，我发现它们各自有各自的优缺点。MVC：简单，单一页面可以实现。但是不利于复杂页面。MVP：解耦，结构清晰。但文件较多，每一个页面基本要新建P层和V层的文件，同时还会有findViewById操作。MVVM：解耦，结构相对清晰，文件相对MVP较少。但如果页面显示比较复杂，需要通过多个值去控制页面的显示，或者页面一个值的显示 要通过多种逻辑去处理得到结果，个人感觉还是不太适用。(其中的ViewModel与对应宿主的生命周期相同，从而内存泄漏问题比MVP处理较好这里先不做讨论) MVP-databinding：处理方式与MVP相同，只是使用了databinding的优势，databinding节省了类似findViewById和数据绑定的时间，从此代码里就没有findViewById和ButterKnife之类的代码了，而且也不会有通过多个值去控制页面的显示这样不好操作的情况了。当然文件还是会多一些。 1234567891011121314151617181920212223242526272829303132333435363738/** * MVP + data-binding * * @author jingbin */public class MvpDataBindingActivity extends AppCompatActivity implements ChangeAgeView &#123; private ActivityMvpDataBindingBinding binding; private ChangeAgePresenter presenter; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); binding = DataBindingUtil.setContentView(this, R.layout.activity_mvp_data_binding); setTitle("MVP + data-binding"); presenter = new ChangeAgePresenter(this); binding.setButtonname("年龄+2"); binding.btAge.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; presenter.changeAge(binding.getUser()); &#125; &#125;); &#125; @Override public void showContentView(UserBean user) &#123; binding.setUser(user); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); presenter.clear(); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435/** * @author jingbin * @date 2019/02/26 */public class ChangeAgePresenter &#123; private ChangeAgeView changeInterface; private UserModel userModel; public ChangeAgePresenter(ChangeAgeView changeInterface) &#123; this.changeInterface = changeInterface; // 初始化 changeInterface.showContentView(new UserBean("小白", 23)); &#125; /** * 改变年龄 */ public void changeAge(UserBean myUser) &#123; if (userModel == null) &#123; userModel = new UserModel(); &#125; userModel.changeAge(myUser, 2, new UserModel.ChangeInterface() &#123; @Override public void success(UserBean user) &#123; changeInterface.showContentView(user); &#125; &#125;); &#125; public void clear() &#123; userModel = null; &#125;&#125; 参考资料 张鸿洋：浅谈 MVP in Android 阮一峰: MVC，MVP 和 MVVM 的图示 Jensen: Android中的MVC和MVP(分析+实例) CSDN: 认清Android框架 MVC，MVP和MVVM 12345678910111213141516171819202122232425262728293031323334projectstru├─ MainActivity.java├─ mvc│ ├─ LoadDataActivity.java│ ├─ bean│ │ └─ Essay.java│ └─ model│ ├─ EssayModel.java│ └─ MainModel.java├─ mvp│ ├─ UserLoginActivity.java│ ├─ bean│ │ └─ User.java│ ├─ model│ │ ├─ IUserBiz.java│ │ ├─ OnLoginListener.java│ │ └─ UserBiz.java│ ├─ presenter│ │ └─ UserLoginPresenter.java│ └─ view│ └─ IUserLoginView.java├─ mvpdatabindind│ ├─ MvpDataBindingActivity.java│ ├─ bean│ │ └─ UserBean.java│ ├─ model│ │ └─ UserModel.java│ ├─ presenter│ │ └─ ChangeAgePresenter.java│ └─ view│ └─ ChangeAgeView.java└─ mvvm ├─ ChangeAgeActivity.java └─ ChangeAgeViewModel.java End对应项目：ProjectPatternStudy 😁此文仅个人总结，如有不当之处，请留言告知。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>mvvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-WebView与JS交互实例]]></title>
    <url>%2F2019%2F01%2F12%2Fwebview-js-interaction%2F</url>
    <content type="text"><![CDATA[纸上觉来终觉浅，绝知此事要躬行。 - 陆游/诗人(宋) 正文一切基于项目WebViewStudy来说明，都是最小单元案例，可作为参考研究，本文从几个方面来讲解： 1、Java调用WebView里的js代码(传递参数) 2、WebView里的js代码调用Java本地方法(传递参数) 3、外部注入js代码 4、WebView长按事件 相关JS代码：123456789101112131415161718192021222324252627&lt;html&gt;&lt;head&gt; &lt;title&gt;js调用android原生代码&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=gb2312"&gt; &lt;meta id="viewport" name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,minimal-ui"&gt; &lt;script type="text/javascript"&gt; function javacalljs()&#123; document.getElementById("content").innerHTML += "&lt;br\&gt;java调用了js函数，无参"; &#125; &lt;!--这里取到的是 android端传过来的数据--&gt; function javacalljswithargs(data)&#123; document.getElementById("content").innerHTML += ("&lt;br\&gt;"+data); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;br/&gt;&lt;br/&gt; &lt;li&gt;&lt;a onClick="window.injectedObject.startFunction()"&gt;点击调用java代码&lt;/a&gt;&lt;/li&gt; &lt;!--可以将android端传过来的数据，处理后,放在这里再传给android端--&gt; &lt;li&gt;&lt;a onClick="window.injectedObject.startFunction('我是网页传出来的数据')"&gt;点击调用java代码并传递参数&lt;/a&gt;&lt;/li&gt;&lt;br/&gt;&lt;div id="content"&gt;内容显示&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Java调用WebView里的js代码(传递参数)// 告诉WebView启用JavaScript执行。默认的是false。ws.setJavaScriptEnabled(true);1、如果点击调用就直接执行就好：1234// 无参数调用webView.loadUrl("javascript:javacalljs()");// 传递参数调用webView.loadUrl("javascript:javacalljswithargs('" + "android传入到网页里的数据，有参" + "')"); 2、如果是显示后就调用，注意放在html显示完成之后MyWebViewClient.java12345678@Override public void onPageFinished(WebView view, String url) &#123; // 无参数调用 webView.loadUrl("javascript:javacalljs()"); // 传递参数调用 webView.loadUrl("javascript:javacalljswithargs('" + "android传入到网页里的数据，有参" + "')"); super.onPageFinished(view, url); &#125; 12345678910/** * 4.4以上可用 evaluateJavascript 效率高 */private void load(String jsCode) &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123; evaluateJavascript(jsCode, null); &#125; else &#123; loadUrl(jsCode); &#125;&#125; WebView里的js代码调用Java本地方法(传递参数)这里有一个js点击方法:12&lt;li&gt;&lt;a onClick="window.injectedObject.startFunction()"&gt;点击调用java代码&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a onClick="window.injectedObject.startFunction('我是网页传出来的数据')"&gt;点击调用java代码并传递参数&lt;/a&gt;&lt;/li&gt; 实现与js交互接口：1webView.addJavascriptInterface(new MyJavascriptInterface(this), "injectedObject"); 这里的”injectedObject”对应js里的”window.injectedObject.startFunction()”，其中MyJavascriptInterface.java:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Created by jingbin on 2016/11/17. * js通信接口 */public class MyJavascriptInterface &#123; private Context context; public MyJavascriptInterface(Context context) &#123; this.context = context; &#125; /** * 前端代码嵌入js： * imageClick 名应和js函数方法名一致 * * @param src 图片的链接 */ @JavascriptInterface public void imageClick(String src) &#123; Log.e("imageClick", "----点击了图片"); Log.e("src", src); &#125; /** * 前端代码嵌入js * 遍历&lt;li&gt;节点 * * @param type &lt;li&gt;节点下type属性的值 * @param item_pk item_pk属性的值 */ @JavascriptInterface public void textClick(String type, String item_pk) &#123; if (!TextUtils.isEmpty(type) &amp;&amp; !TextUtils.isEmpty(item_pk)) &#123; Log.e("textClick", "----点击了文字"); Log.e("type", type); Log.e("item_pk", item_pk); &#125; &#125; /** * 网页使用的js，方法无参数 */ @JavascriptInterface public void startFunction() &#123; Log.e("startFunction", "----无参"); &#125; /** * 网页使用的js，方法有参数，且参数名为data * * @param data 网页js里的参数名 */ @JavascriptInterface public void startFunction(String data) &#123; Log.e("startFunction", "----有参" + data); &#125;&#125; 且对标里面的两个方法：1234567891011121314151617/** * 网页使用的js，方法无参数 */@JavascriptInterfacepublic void startFunction() &#123; Log.e("startFunction", "----无参");&#125;/** * 网页使用的js，方法有参数，且参数名为data * * @param data 网页js里的参数名 */@JavascriptInterfacepublic void startFunction(String data) &#123; Log.e("startFunction", "----有参" + data);&#125; 外部注入js代码有时候我们得到一个网页，这个网页并不是我们订制的，里面没有我们调用的js代码，这时候我们可在前端直接注入js的。比如 网页里面有图片，我们点击图片想要查看图片和保存图片到本地，这时候网页并没有实现这个js方法供我们调用，但是我们可以注入js代码，来实现这个需求。 在html加载完成之后，我们调用这段js:12345678// 这段js函数的功能就是，遍历所有的img节点，并添加onclick函数，函数的功能是在图片点击的时候调用本地java接口并传递url过去webView.loadUrl("javascript:(function()&#123;" + "var objs = document.getElementsByTagName(\"img\");" + "for(var i=0;i&lt;objs.length;i++)" + "&#123;" + "objs[i].onclick=function()&#123;window.injectedObject.imageClick(this.getAttribute(\"src\"));&#125;" + "&#125;" + "&#125;)()"); 这时候再看MyJavascriptInterface.java里的imageClick方法：1234567891011/** * 前端代码嵌入js： * imageClick 名应和js函数方法名一致 * * @param src 图片的链接 */@JavascriptInterfacepublic void imageClick(String src) &#123; Log.e("imageClick", "----点击了图片"); Log.e("src", src);&#125; src即为图片链接，可以作为显示和下载用。 WebView长按事件12345678910111213141516171819202122232425262728293031webView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; final WebView.HitTestResult hitTestResult = webView.getHitTestResult(); // 如果是图片类型或者是带有图片链接的类型 if (hitTestResult.getType() == WebView.HitTestResult.IMAGE_TYPE || hitTestResult.getType() == WebView.HitTestResult.SRC_IMAGE_ANCHOR_TYPE) &#123; // 弹出保存图片的对话框 new AlertDialog.Builder(WebViewActivity.this) .setItems(new String[]&#123;"查看大图", "保存图片到相册"&#125;, new DialogInterface.OnClickListener() &#123; @Override public void onClick(DialogInterface dialog, int which) &#123; String picUrl = hitTestResult.getExtra(); //获取图片 Log.e("picUrl", picUrl); switch (which) &#123; case 0: break; case 1: break; default: break; &#125; &#125; &#125;) .show(); return true; &#125; return false; &#125;&#125;); 参考资料 android webview js交互 第一节 （java和js交互）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android-应用被作为第三方浏览器打开]]></title>
    <url>%2F2018%2F12%2F15%2Fthird-party-browser%2F</url>
    <content type="text"><![CDATA[前言微信里的文章页面，可以选择“在浏览器打开”。现在很多应用都内嵌了WebView，那是否可以使自己的应用作为第三方浏览器打开此文章呢？如图： 就像图中这样，让自己的应用出现在列表里。这篇文章就是为了实现这个功能。 项目代码地址：WebViewStudy 正文实现其实很简单：在Manifest文件中，给想要接收跳转的Activity添加配置：12345678910111213141516171819&lt;activity android:name=".WebViewActivity" android:configChanges="orientation|screenSize" android:hardwareAccelerated="true" android:launchMode="singleTask" android:screenOrientation="portrait" android:theme="@style/WebViewTheme"&gt; &lt;!--需要添加下面的intent-filter配置--&gt; &lt;intent-filter tools:ignore="AppLinkUrlError"&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;!--使用http，则只能打开http开头的网页--&gt; &lt;data android:scheme="https" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 然后在 WebViewActivity 中获取相关传递数据：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class WebViewActivity extends AppCompatActivity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_web_view); getIntentData(); initTitle(); initWebView(); webView.loadUrl(mUrl); // 处理 作为三方浏览器打开传过来的值 getDataFromBrowser(getIntent()); &#125; /** * 使用singleTask启动模式的Activity在系统中只会存在一个实例。 * 如果这个实例已经存在，intent就会通过onNewIntent传递到这个Activity。 * 否则新的Activity实例被创建。 */ @Override protected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); getDataFromBrowser(intent); &#125; /** * 作为三方浏览器打开传过来的值 * Scheme: https * host: www.jianshu.com * path: /p/1cbaf784c29c * url = scheme + "://" + host + path; */ private void getDataFromBrowser(Intent intent) &#123; Uri data = intent.getData(); if (data != null) &#123; try &#123; String scheme = data.getScheme(); String host = data.getHost(); String path = data.getPath(); String text = "Scheme: " + scheme + "\n" + "host: " + host + "\n" + "path: " + path; Log.e("data", text); String url = scheme + "://" + host + path; webView.loadUrl(url); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; 以上是核心代码，有几点需要说明的： 1、设置启动模式：launchMode=&quot;singleTask&quot; 2、getDataFromBrowser()方法会在onCreate和onNewIntent方法中调用。 解释：在实际使用中，有这样的场景：我们在微信中“通过浏览器”打开自己的应用，然后将自己的应用切到后台。重复上面的操作，会一直创建应用的实例，这样肯定是不好的，为了避免这种情况我们设置启动模式为：launchMode=&quot;singleTask&quot;。 使用singleTask启动模式的Activity在系统中只会存在一个实例。如果这个实例不存在，新的Activity实例被创建。如果这个实例已经存在，那么在Activity回退栈中，所有位于该Activity上面的Activity实例都将被销毁掉（销毁过程会调用Activity生命周期回调），这样使得singleTask Activity实例位于栈顶。与此同时，Intent会通过onNewIntent传递到这个SingleTask Activity实例。 - &lt;深入讲解Android中Activity launchMode&gt; 这就是为什么要在onNewIntent中调用的原因，当此Activity已存在时，值会通过onNewIntent传递过来。 继续拓展也许大家用知乎进行过类似的操作，会发现有这样一个效果：当知乎没有开启时，在其他应用打开知乎后，关闭页面会回到知乎的主页面。正常是不会有出现这样的情况的，我们需要简单设置一下。 1、在主页面设置静态变量，初始化时改变静态变量的值12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; // 是否开启了主页，没有开启则会返回主页 public static boolean isLaunch = false; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initView(); isLaunch = true; &#125; @Override protected void onDestroy() &#123; super.onDestroy(); isLaunch = false; &#125; 2、当WebViewActivity关闭时判断是否打开主页面12345678910111213/** * 直接通过三方浏览器打开时，回退到首页 */public void handleFinish() &#123; if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; finishAfterTransition(); &#125; else &#123; finish(); &#125; if (!MainActivity.isLaunch) &#123; MainActivity.start(this); &#125;&#125; 结语其实这相当于Activity隐式跳转，其中点击网页中的电话跳转到手机的拨号盘也是这样的原理，DeepLink也基本是这个逻辑。 设想这样一种情况：我们通过浏览器拉起自己的应用，不一定要打开WebView，也可以打开原生的页面，只需要传过来的数据里有此页面想要的数据即可。其实很多应用都这样做了。 End 下载体验：https://fir.im/webviewstudy 最后再附一遍项目地址😆：WebViewStudy]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《云阅2.0》一款同时看玩安卓和干货集中营资讯的App]]></title>
    <url>%2F2018%2F11%2F06%2Fcloudreader-app-introduce%2F</url>
    <content type="text"><![CDATA[一、云阅2.0 《云阅》一个仿网易云音乐UI，使用Gank.Io及豆瓣Api开发的开源项目在云阅发布第一版之后，大约经过了近两年的时间，不断的更新迭代，现在已经完成了2.0，相比第一版它改变了很多： 1、新增功能 玩安卓完整模块(首页、知识体系、导航数据、收藏文章和网址) 糗事百科段子内容 webview 新增分享，复制，刷新，浏览器打开，添加到收藏功能 侧边栏新增 账号登录、我的收藏、退出应用功能 增加Room的使用 2、优化&amp;修复 网络请求升级到Retrofit2.x，稳定运行 保存图片优化 webview大幅完善，具体详见WebViewStudy 解决应用退出后台，点击图标重新启动问题 升级gradle到3.0以上 Andoird性能优化 - 布局优化 修复可能存在的内存泄漏问题 具体见更新日志-云阅 二、交流 期间有很多人提了很多Issues，有很多表示喜欢的，说已经使用了一年多了，很感谢。还有指出问题的，比如提到说MVVM架构不规范及内存泄漏问题，还有一部分请教问题的，尽量解决大家的问题，同时提升自己，但有些时候由于自己本身工作的原因，没有多余的时间解决问题还请大家多见谅。 关于MVVM架构的问题之前和大家说了，是我理解的有点偏差，可能大部分的架构是MVP - databinding，也有比较典型的MVVM - datadinding，比如登录页面LoginActivity。感觉MVVM有些情况并没有很好的解决日常开发的问题。对于MVC，MVP，MVVM，我们都应该理解它们的含义，并在具体的情况使用合适的架构，比如一个简单的页面就没太大的必要去写MVVM，那样只会多一些class文件，也许一个MVC就解决的很好。 因为我平时也是用这个软件来看一些技术的动态，随着干货集中营更新的不频繁，玩安卓也越来越完善后，便实现了玩安卓的大部分功能，没有实现的只有少部分接口了，比如TODO，搜索部分，搜索后期也会完善，TODO因为平时自己用奇妙清单觉得很好用，感觉再写一个用处不大，之后要做的话就是结合文章一起做了，比如看到一篇好文章想什么时间来学就添加一个TODO，不过这是之后的事了。 三、2.0 之后的计划 如果应用中使用到的Api(玩安卓、干货集中营和豆瓣开放Api)可以继续使用的话，以后的样式ui基本就是这样子了，期间也会加一些实用的功能，如监控剪切板的内容打开链接等。我会一直维护这个项目，有什么问题可以随时交流，但今后的重心可能不会于此。 此应用虽然基础的UI是仿网易云音乐界面，但是具体的一些细节，如电影部分和玩安卓的主页面等都是花了很长时间慢慢调试才达到这样相对美观的效果，其中包含文字颜色，图标及一些图片的选择。这对于一个业余的开发者来讲很耗时间，其中参考了ui设计网站里的一部分设计图，可以说考虑ui方面的展示比写代多码付出了几倍的时间。 不久后可能会出一款全栈的App，并自己设计UI，而不是使用其他软件的UI，仿xxx系列只是初期的阶段，正如模仿刘德华，张学友之类的，模仿始终是模仿，活在其他人的影子之下，最终实现一款完全属于自己的App才是我们的目标。 四、最后 如果大家感兴趣可以前往下载：https://fir.im/cloudreader有什么问题可以随时交流： email: jingbin127@163.com 个人主页：http://jingbin.me 项目地址： CloudReader]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>cloudreader</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android DeepLink介绍与使用]]></title>
    <url>%2F2018%2F07%2F02%2Fdeeplink-intro-use%2F</url>
    <content type="text"><![CDATA[前段时间公司让调研一下DeepLink，说以后会用到，之前看了很久，并做了个demo，现整理一下，方便以后查阅，如果有幸帮助到其他人就更好了。 基本概念Deep Link，又叫deep linking，中文翻译作深层链接。 简单地从用户体验来讲，Deep Link，就是可以让你在手机的浏览器/Google Search上点击搜索的结果，便能直接跳转到已安装的应用中的某一个页面的技术。 对于不懂技术的运营人员来说就是一个分享功能，而从技术层面上去简单理解是实现将某APP用户带到另外APP相对应的内容页面，实现APP之间无缝跳转！ 商业价值相信大家或多或少看到过这样的页面： 底部有一个“App内打开”，点击后如果安装过应用直接跳到应用的对应页面，如果没安装则跳到下载应用页。 Deeplink（深度链接）对于已经安装APP，指向特定的页面，和上面说的一致。 Deferred deeplink（ 延迟深度链接）相比deeplink，它增加了判断APP是否被安装，用户匹配的2个功能； 1.当用户点击链接的时候判断APP是否安装，如果用户没有安装时，引导用户跳转到应用商店下载应用。 2.用户匹配功能，当用户点击链接时和用户启动APP时，分别将这两次用户Device Fingerprint（设备指纹信息）传到服务器进行模糊匹配，使用户下载且启动APP时，直接打开相应的指定页面。 通过上面的2个技术方案，不仅：①可以让被分享者更快更便捷的回到APP，且回到指定的活动页面，而且：②可以引导未安装APP的用户下载APP、③分享者和被分享者的关系链会通过设备指纹信息记录下来，在业务场景中给出相应的奖励。 使用deeplink前后对比： 基本使用 具体见Demo：WebViewStudy HTML页面：deeplink.html1&lt;a href="[scheme]://[host]/[path]?[query]"&gt;启动应用程序&lt;/a&gt; 示例：1&lt;a href="will://link/testId"&gt;立即打开（直接打开）&amp;gt;&amp;gt;&lt;/a&gt; AndroidManifest.xml123456789101112&lt;!--用于DeepLink，html跳到此页面 scheme_Adr: 'will://link/testid',--&gt; &lt;activity android:name=".DeepLinkActivity"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.VIEW" /&gt; &lt;category android:name="android.intent.category.DEFAULT" /&gt; &lt;category android:name="android.intent.category.BROWSABLE" /&gt; &lt;data android:host="link" android:scheme="will" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;/application&gt; MyWebViewClient.class123456789101112131415161718192021222324@SuppressWarnings("deprecation")@Overridepublic boolean shouldOverrideUrlLoading(WebView view, String url) &#123; if (TextUtils.isEmpty(url)) &#123; return false; &#125; try &#123; // 用于DeepLink测试 if (url.startsWith("will://")) &#123; Uri uri = Uri.parse(url); Log.e("---------scheme", uri.getScheme() + "；host: " + uri.getHost() + "；Id: " + uri.getPathSegments().get(0)); &#125; Intent intent1 = new Intent(); intent1.setAction("android.intent.action.VIEW"); Uri uri = Uri.parse(url); intent1.setData(uri); intent1.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mActivity.startActivity(intent1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return true;&#125; DeepLinkActivity.java12345678910111213141516171819/** * 从deep link中获取数据 * 'will://share/传过来的数据' */ private void getDataFromBrowser(TextView textView) &#123; Uri data = getIntent().getData(); try &#123; String scheme = data.getScheme(); String host = data.getHost(); List&lt;String&gt; params = data.getPathSegments(); // 从网页传过来的数据 String testId = params.get(0); String text = "Scheme: " + scheme + "\n" + "host: " + host + "\n" + "params: " + testId; Log.e("ScrollingActivity", text); textView.setText(text); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 页面具体显示：123Scheme：willhost：linkparams：testId 实现原理DeepLink用到的核心技术就是：URL SCHEMES。不论是IOS还是Android。URL Schemes 有两个单词： URL，我们都很清楚，http://www.apple.com 就是个 URL，也叫它链接或网址； Schemes，表示的是一个 URL 中的一个位置——最初始的位置，即 ://之前的那段字符。比如 http://www.apple.com 这个网址的 Schemes 是 http。 我们可以像定位一个网页一样，用一种特殊的 URL 来定位一个应用甚至应用里某个具体的功能。而定位这个应用的，就应该这个应用的 URL 的 Schemes 部分，也就是开头儿那部分。但是需要注意的是应用的URL Schemes 并不唯一，也就是说一个应用可以“起多个名“，不同应用的URL Schemes也可能因为名字一样发生冲突。 Android系统级应用，有一些已经定义了URL Schemes，比如短信是 sms:、通话是tel:、email是mailto:，在定义自己APP的URL Schemes的时候要避免跟系统应用名称一样。123&lt;a href="tel:15088888888"&gt;电话&lt;/a&gt;&lt;a href="sms:15088888888"&gt;短信&lt;/a&gt;&lt;a href="mailto:15088888888@qq.com"&gt;邮件&lt;/a&gt; 与URL一样，URL Schemes也可以通过传参打开特定的APP界面。 URL：http://images.google.com/images?q=关键字 URL Schemes：weixin://dl/moments（打开微信朋友圈） Applink基本介绍官网文档：Verify Android App Links Android App Links是一种特殊的Deep Links，它使Android系统能够直接通过网站地址打开应用程序对应的内容页面，而不需要用户选择使用哪个应用来处理网站地址。 要添加Android App Links到应用中，需要在应用里定义通过Http(s)地址打开应用的intent filter，并验证你确实拥有该应用和该网站。如果系统成功验证到你拥有该网站，那么系统会直接把URL对应的intent路由到你的应用。 为了验证你对应用和网站的所有权，以下两个步骤是必须的： 1.在AndroidManifest里要求系统自动进行App Links的所有权验证。这个配置会告诉Android系统去验证你的应用是否属于在intent filter内指定的URL域名。 2.在以下链接地址里，放置一个数字资产链接的Json文件，声明你的网址和应用之间的关系： https://domain.name/.well-known/assetlinks.json 与Deep Links的区别 Deep Links 是一种允许用户进入应用某个特定Activity的intent filter。点击这类链接时，系统可能会弹出一个选择列表，让用户在一堆能够处理这类链接的应用里(包括你的)选择一个来处理该链接。图一展示了这样一种情况：用户点击了一个地图相关的链接，系统弹出一个选择列表，让用户选择是要使用地图应用来处理，还是使用Chrome浏览器来处理。 App Links 是一种基于你的网站地址且验证通过的Deep Links。因此，点击一个这样的链接会直接打开你的应用(如果已经安装)，系统将不会弹出选择列表。当然，后续用户可以更改配好设置，来指定由哪个应用程序处理这类链接。 下面这个列表描述更多差异： item Deep Links App Links Intent URL Scheme https, http，或者自定义 需为http或https Intent Action 任意Action 需为android.intent.action.VIEW Intent Category 任意Category 需为android.intent.category.BROWSABLE和android.intent.category.DEFAULT 链接验证 不需要 需要在网站上放置一个数字资产链接，并能够通过HTTPS访问 用户体验 可能会弹出一个选择列表给用户选择用哪个应用处理连接 没有弹框，系统直接打开你的应用处理网站连接 兼容性 所有Android版本 Android 6.0及以上 总结一下 1.APP要想被其他APP直接打开，自身得支持，让自己具备被人打开的能力。（URL Schemes） 2.APP要想打开其他的APP，自身也得支持。（判断设备是否安装、各种跳转的处理） 应该来讲，deeplink技术比较适用于独立电商、金融理财APP，一方面这类APP的广告内容可以是平台的商品（产品），链接后直接进入相关商品（产品）的详情页，另一方面，这类APP在打开后是会产生后续的交易行为。 这种方式只能用于系统处理URL的intent的情况，若URL本身没有抛给系统处理，而是直接在应用内打开了，那就无法直接拉起应用。 由于大部分应用，如微博、微信、第三方浏览器(包括Chrome)，都不会将URL抛给系统处理(对scheme进行屏蔽)，因此App Links生效的情况就很有限了，比如只能从记事本应用、短信应用这些进行跳转。总体来说，实属鸡肋。 京东及淘宝的CPS即是使用此方式实现的。京东CPS商品推广接入流程Android 阿里百川cps SDK接入流程 一些常用APP的URL Schemes知乎：回答 zhihu://answers/{id}用户页 zhihu://people/{id}微信：weixin://dl/scan 扫一扫weixin://dl/feedback 反馈weixin://dl/moments 朋友圈weixin://dl/settings 设置weixin://dl/notifications 消息通知设置weixin://dl/chat 聊天设置weixin://dl/general 通用设置weixin://dl/officialaccounts 公众号weixin://dl/games 游戏weixin://dl/help 帮助weixin://dl/feedback 反馈weixin://dl/profile 个人信息weixin://dl/features 功能插件 腾讯微博：TencentWeibo://淘宝：taobao://支付宝：alipay://微博：sinaweibo://weico微博：weico://QQ浏览器：mqqbrowser://uc浏览器：ucbrowser://海豚浏览器：dolphin://搜狗浏览器：SogouMSE://百度地图：baidumap://Chrome：googlechrome://优酷：youku://京东：openapp.jdmoble://人人：renren://美团：imeituan://1号店：wccbyihaodian://我查查：wcc://有道词典：ddictproapp://点评：dianping://微盘：sinavdisk://豆瓣fm：doubanradio://网易公开课：ntesopen://名片全能王：camcard://淘宝宝贝搜索：taobao://http://s.taobao.com/?q=[prompt]淘宝店铺搜索：taobao://http://shopsearch.t 参考链接 Deep Link是什么 深度链接（Deeplink）技术助力APP运营，实现病毒式用户增长 现在很火的app上的deeplink技术，到底是什么？ 5 分钟搞懂 Android DeepLink Android AppLinks 接入 Android M的App Links实现详解 移动DeepLink的前生今世]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>deeplink</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 内存泄漏分析与优化]]></title>
    <url>%2F2018%2F06%2F27%2Fmemory-leak-analysis%2F</url>
    <content type="text"><![CDATA[大范围借鉴及自己思考总结的内容，感谢各位博主的分享。 基础概念何为性能问题(1). 响应时间指从用户操作开始到系统给用户以正确反馈的时间。一般包括逻辑处理时间 + 网络传输时间 + 展现时间。对于非网络类应用不包括网络传输时间。 展现时间即：网页或 App 界面渲染时间。响应时间是：用户对性能最直接的感受。 (2). TPS(Transaction Per Second)TPS为每秒处理的事务数，是系统吞吐量的指标，在搜索系统中也用QPS(Query Per Second)衡量。TPS一般与响应时间反相关。 通常所说的性能问题就是指响应时间过长、系统吞吐量过低。 对后台开发来说，也常将高并发下内存泄漏归为性能问题。对移动开发来说，性能问题还包括电量、内存使用这两类较特殊情况。 性能调优方式明白了何为性能问题之后，就能明白性能优化实际就是优化系统的响应时间，提高TPS。优化响应时间，提高TPS。方式不外乎这三大类： (1) 降低执行时间，又包括几小类 a. 利用多线程并发或分布式提高 TPS b. 缓存(包括对象缓存、IO 缓存、网络缓存等) c. 数据结构和算法优化 d. 性能更优的底层接口调用，如 JNI 实现 e. 逻辑优化 f. 需求优化 (2) 同步改异步，利用多线程提高TPS (3) 提前或延迟操作，错峰提高TPS 项目优化细节内存泄漏问题静态单例类引用Activity的context单例模式不正确的获取context: 1234567891011121314public class LoginManager &#123; private Context context; private static LoginManager manager; public static LoginManager getInstance(Context context) &#123; if (manager == null) manager = new LoginManager(context); return manager; &#125; private LoginManager(Context context) &#123; this.context = context; &#125; 在LoginActivity中: 123456789public class LoginActivity extends Activity &#123; private LoginManager loginManager; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_login); loginManager = LoginManager.getInstance(this); &#125; 在LoginManager的单例中context持有了LoginActivity的this对象，即使登录成功后我们跳转到了其他Activity页面，LoginActivity的对象仍然得不到回收因为他被单例所持有，而单例的生命周期是同Application保持一致的。 正确的获取context的方式： 1234567891011121314public class LoginManager &#123; private Context context; private static LoginManager manager; public static LoginManager getInstance(Context context) &#123; if (manager == null) manager = new LoginManager(context); return manager; &#125; private LoginManager(Context context) &#123; this.context = context.getApplicationContext(); &#125; 我们单例中context不再持有Activity的context而是持有Application的context即可，因为Application本来就是单例，所以这样就不会存在内存泄漏的的现象了。 单例模式中通过内部类持有activity对象下面是一个单例的类： 12345678910111213141516171819202122232425public class TestManager &#123; public static final TestManager INSTANCE = new TestManager(); private List&lt;MyListener&gt; mListenerList; private TestManager() &#123; mListenerList = new ArrayList&lt;MyListener&gt;(); &#125; public static TestManager getInstance() &#123; return INSTANCE; &#125; public void registerListener(MyListener listener) &#123; if (!mListenerList.contains(listener)) &#123; mListenerList.add(listener); &#125; &#125; public void unregisterListener(MyListener listener) &#123; mListenerList.remove(listener); &#125;&#125;interface MyListener &#123; public void onSomeThingHappen();&#125; 然后是activity: 123456789101112131415public class TestActivity extends AppCompatActivity &#123; private MyListener mMyListener=new MyListener() &#123; @Override public void onSomeThingHappen() &#123; &#125; &#125;; private TestManager testManager=TestManager.getInstance(); @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_test); testManager.registerListener(mMyListener); &#125;&#125; 我们知道在java中，非静态的内部类的对象都是会持有指向外部类对象的引用的，因此我们将内部类对象mMyListener让单例所持有时，由于mMyListener引用了我们的activity对象，因此造成activity对象也不能被回收了，从而出现内存泄漏现象。 修改以上代码，避免内存泄漏，在activity中添加以下代码: 12345@Overrideprotected void onDestroy() &#123; testManager.unregisterListener(mMyListener); super.onDestroy();&#125; 退出界面时，取消相关注册监听！ AsyncTask不正确使用造成的内存泄漏我们在来看一种更加容易被忽略的内存泄漏现象，对于AsyncTask不正确使用造成内存泄漏的问题： 12345678mTask=new AsyncTask&lt;String,Void,Void&gt;() &#123; @Override protected Void doInBackground(String... params) &#123; //doSamething.. return null; &#125; &#125;.execute("a task"); 我们在使用AsyncTask的时候不宜在其中执行太耗时的操作，假设activity已经退出了，然而AsyncTask里任务还没有执行完成或者是还在排队等待执行，就会造成我们的activity对象被回收的时间延后，一段时间内内存占有率变大。 解决方法在activity退出的时候应该调用cancel()函数: 123456@Override protected void onDestroy() &#123; //mTask.cancel(false); mTask.cancel(true); super.onDestroy(); &#125; 退出界面时，结束当前页面的线程。 内部Handler类引起内存泄露原因：Handler在Android中用于消息的发送与异步处理，常常在Activity中作为一个匿名内部类来定义，此时Handler会隐式地持有一个外部类对象（通常是一个Activity）的引用。当Activity已经被用户关闭时，由于Handler持有Activity的引用造成Activity无法被GC回收，这样容易造成内存泄露。 正确的做法是将其定义成一个静态内部类（此时不会持有外部类对象的引用），在构造方法中传入Activity并对Activity对象增加一个弱引用，这样Activity被用户关闭之后，即便异步消息还未处理完毕，Activity也能够被GC回收，从而避免了内存泄露。 123456789101112131415161718192021public static class MyHandler extends Handler &#123; private WeakReference&lt;Activity&gt; reference; public MyHandler(Activity activity) &#123; reference = new WeakReference&lt;Activity&gt;(activity); &#125; @Override public void handleMessage(Message msg) &#123; if (reference.get() != null) &#123; switch (msg.what) &#123; case 0: // do something... break; default: // do something... break; &#125; &#125; &#125; &#125; webview导致的内存泄漏用代码New一个WebView而不是在XML中静态写入(不过貌似不能设置进度条了，不需要进度条的可以忽略): 在XML文件中用layout占位: 1234&lt;RelativeLayout android:id="@+id/base_web_view_container" android:layout_width="match_parent" android:layout_height="match_parent" /&gt; 接下来只需要在Activity中New一个WebView并且添加到我们的容器中就ok了: 123456RelativeLayout webview_container = (RelativeLayout) findViewById(R.id.base_web_view_container);web_view_ = new WebView(yourApplicationContext);web_view_.setLayoutParams(new ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT));web_view_.setOnWebCallback(yourWebCallback);webview_container.addView(web_view_); 关于WebView的context应该用Activity还是Application的context，这里网上较为一致的观点都是采用Application的，理由是这样不会造成Activity的context的内存泄漏。 销毁时的动作： 1234567891011121314public void clearWebViewResource() &#123; if (web_view_ != null) &#123; LogUtils.d(TAG,"Clear webview's resources"); web_view_.removeAllViews(); // in android 5.1(sdk:21) we should invoke this to avoid memory leak // see (https://coolpers.github.io/webview/memory/leak/2015/07/16/ // android-5.1-webview-memory-leak.html) ((ViewGroup) web_view_.getParent()).removeView(web_view_); web_view_.setTag(null); web_view_.clearHistory(); web_view_.destroy(); web_view_ = null; &#125;&#125; 尽量不要将WebView作为listview的头部使用，这样的话WebView会被一次性加载到内存中。 Window Leaked按字面了解，Window Leaked大概就是说一个窗体泄漏了，也就是我们常说的内存泄漏，为什么窗体会泄漏呢？ 产生原因： 我们知道Android的每一个Activity都有个WindowManager窗体管理器，同样，构建在某个Activity之上的对话框、PopupWindow也有相应的WindowManager窗体管理器。因为对话框、PopupWindown不能脱离Activity而单独存在着，所以当某个Dialog或者某个PopupWindow正在显示的时候我们去finish()了承载该Dialog(或PopupWindow)的Activity时，就会抛Window Leaked异常了，因为这个Dialog(或PopupWindow)的WindowManager已经没有谁可以附属了，所以它的窗体管理器已经泄漏了。 解决方法：关闭(finish)某个Activity前，要确保附属在上面的Dialog或PopupWindow已经关闭(dismiss)了。 避免内存流失内存流失可能会导致出现大量的 GC 事件，如自定义组件的 onDraw() ，避免大量创建临时对象，比如 String ，以免频繁触发 GC。GC 事件通常不影响您的 APP 的性能，然而在很短的时间段，发生许多垃圾收集事件可以快速地吃了您的帧时间，系统上时间的都花费在 GC ，就有很少时间做其他的东西像渲染或音频流。 监听器的注销 对于观察者, 广播, Listener等, 注册和注销没有成对出现而导致的内存泄露. 使用CountDownTimer倒计时时，退出activity要取消：timer.cancel() 使用LocationManager获取地理位置，及时取消注册：locationManager.removeUpdates(mListener); 使用dialog或BottomSheetDialog，消失时移除监听，对象置空 使用RxBus，退出activity取消注册 使用一些三方的库，仔细查看是否需要取消注册的情况 Bitmap处理以fresco为例： (最好是加载图片宽高大小的图片，多余的尺寸会导致内存浪费，不过webp后缀的图片无法设置宽高，这是个问题？)加载特别特别大的图片时最容易导致这种情况。如果你加载的图片比承载的View明显大出太多，那你应该考虑将它Resize一下。 Android 无法绘制长或宽大于2048像素的图片。这是由OpenGL渲染系统限制的，如果它超过了这个界限，Fresco会对它进行Resize。 decode format：解码格式，选择ARGB_8888/RBG_565/ARGB_4444/ALPHA_8，存在很大差异。在不需要特别清晰的图片情况下，使用RBG_565为好。 SharedPreference 存储valuesp在创建的时候会把整个文件全部加载进内存，如果你的sp文件比较大，那么会带来两个严重问题： 第一次从sp中获取值的时候，有可能阻塞主线程，使界面卡顿、掉帧。 解析sp的时候会产生大量的临时对象，导致频繁GC，引起界面卡顿。 这些key和value会永远存在于内存之中，占用大量内存。 储存数据量过大后，取值小屏手机vivoY23L,v4.4.4会取值失败。 Cursor关闭如查询数据库的操作，使用到Cursor，也要对Cursor对象及时关闭。 12345678910111213try &#123; if (cursor != null) &#123; cursor.moveToFirst(); // do something. &#125;&#125;catch (Exception e) &#123; e.printStackTrace();&#125;finally &#123; if (cursor != null) &#123; cursor.close(); cursor = null; &#125;&#125; 有效使用内存的建议去掉bean里无用的字段有时候我们通过GsonFormat直接生成返回的json的Bean，而有一些我们并未使用的字段也一并生成了，建议删除这些无用字段，不然将无可避免的占用一定的内存空间。 关闭页面，全局的list清空后置空用完就清空，并设置为null，不要到处引用不然会导致不能及时释放。 谨慎使用服务Service离开了 APP 还在运行服务是最糟糕的内存管理错误之一，当 APP 处在后台，我们应该停止服务，除非它需要运行的任务。我们可以使用JobScheduler替代实现，JobScheduler把一些不是特别紧急的任务放到更合适的时机批量处理。如果必须使用一个服务，最佳方法是使用IntentService，限制服务寿命，所有请求处理完成后，IntentService 会自动停止。 使用优化后的数据容器考虑使用优化过数据的容器 SparseArray / SparseBooleanArray / LongSparseArray 代替 HashMap 等传统数据结构，通用 HashMap 的实现可以说是相当低效的内存，因为它需要为每个映射一个单独的条目对象 关于HashMap，ArrayMap，SparseArray, 这篇文章有个比较直观的比较, 可以看下 少用枚举enum结构枚举一般是用来列举一系列相同类型的常量，它是一种特殊的数据类型，使用枚举能够确保参数的安全性。但是Android开发文档上指出，使用枚举会比使用静态变量多消耗两倍的内存，应该尽量避免在Android中使用枚举。 那么枚举为什么会更消耗内存呢？ - 分析链接 避免创建不必要的对象诸如一些临时对象, 特别是循环中的. 使用异步处理数据较多的情况如果一些数据需要处理再显示在UI上，对于数据量比较大的情况强烈建议异步处理后再在主线程处理。 使用 nano protobufs 序列化数据Protocol buffers 是一个语言中立，平台中立的，可扩展的机制，由谷歌进行序列化结构化数据，类似于 XML 设计的，但是更小，更快，更简单。如果需要为您的数据序列化与协议化，建议使用 nano protobufs。 使用ProGuard来剔除不需要的代码使用 ProGuard 来剔除不需要的代码，移除任何冗余的，不必要的，或臃肿的组件，资源或库完善 APP 的内存消耗。 降低整体尺寸APK您可以通过减少 APP 的整体规模显著减少 APP 的内存使用情况。文章：Android APK瘦身实践 优化布局层次通过优化视图层次结构，以减少重叠的 UI 对象的数量来提高性能。文章：Android 渲染优化 检测工具 leakcanary 参考文章 性能优化系列总篇 Android内存优化之——static使用篇 Android 中handler的HandlerLeak问题 源码探索系列1—Handler与HandlerLeak的那些事 WebView内存泄漏优化之路 关于android.view.WindowLeaked的解决方案 Android 内存优化 请不要滥用SharedPreference]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[武汉购房经历 | 已结束]]></title>
    <url>%2F2018%2F06%2F13%2Fbuying-a-house-in-wuhan%2F</url>
    <content type="text"><![CDATA[前言2018.6.12，今天刚领到了购房合同，从买房到现在已经一年多了，总算完成了一项一百多万的大买卖。总结一下这一年多买房的经历。 很长的文字，建议用时一个小时不要看。 开始想买房刚毕业半年，还在北京工作的的时候，一高中同学就打算在武汉买套房，那时候是2015年底，因为她毕业的早一年，而且提前出去工作的，在武汉已经工作了一年了，对那里的形势也比较了解。 跟我说了一下买房的事情，由于我对武汉的情况并不了解，而且那时候刚毕业不久，没有很稳定的工作，不确定是不是一定到武汉定居，所以并没有多在意，当年过年回家和父母商量可不可以买。 当时没有买，我知道的几个原因有，第一：家里那时候生意不太好做，准备搬到市区去做另一行的生意，进货、租店而且还要一定的资金周转，拿出20万作为首付后资金有点紧张。第二：父母问了其他人武汉的房子好不好买，大家都说好买，不急，到处都拉着你买房子。第三：我还不确定回武汉，以后还不一定在武汉定居，现在买了不一定增值，花20万放在房子上增值现在看不到好的前景。第四：我的收入不稳定，买了不一定还得起，到时候还得让父母还，我心里也不好受。第五：我大学在宜昌上的，之后又去了北京，对武汉的情况不了解，不知道哪个地方好，哪个地方差还需要去好好看，而且买了后还要领合同签贷款交首付之类的要一段时间，我马上就要去北京了，父母忙生意也没时间。由于种种原因，当时是没有买的，不然现在也不会花这么大价钱买。 那个高中同学买了，之后说的是逼她的父母买的《宝业光谷丽都》，当时的价好像是7500左右，2015年下半年或2016年上半年，买的一个85平左右的两室一厅，对于我们来说已经非常好了。 后来房价一路飙升，原定她的小区第三期2017年开盘的一直捂盘到现在，2018年5月，靠近三环的比较吵的以均价15000元一平，靠后一点的以均价17000元一平的出售了。整整翻了两倍不止。 网上看房子过完年去北京后，网上一直有武汉房价的消息，可能那时候资本寒冬，投资家的钱没地方去就很多到了房市上面。那时候还在网上慢慢悠悠看房子，看哪里的地段好，哪里符合我工作的地方。 突然，具体时间忘记了，也不是很敏感，因为当时父母没这么想买，我没这么多钱，觉得父母已经很辛苦了，所以没有太在意。大约是2016年下半年的时候，武汉限购了，不是武汉户口的买不了，刚开始是几个区限购，后来越来越多，以至于好点的地方都需要户口或两年社保。[2016、武汉9月限贷，10月限购，11月又限购] 2017年过年的时候回家，差不多2017年2月，在武汉呆了几天，去她的房子那看了一下，好像就是那个三期的，说是快开盘了，我问可以不可以买，说是限购了一定要是武汉户口，或是两年社保，当时想了想两年是不可能的，还要工作两年，本地户口又不是，所以很无奈。 第一次实地看房2017年回家后，决定了之后去深圳发展，回北京后辞去当时的工作，然后去了深圳，打算的是在深圳打工然后还武汉的房贷。既然买不了主城区的房子，就买远城区的，心里想的很简单，只要是武汉的房子就好，就算离工作的地方搭车2小时也无所谓。 然后在深圳找工作期间，发现不是很顺利，深圳的工资没有我想象的那么高，而且远城区的房子比我想象的要远😂。 当时在深圳找工作，因为深圳距离武汉比较远，父母和另一个人就开车一起去武汉看了一次，开去武汉差不多就2个小时左右。看了几个楼盘感觉比较好，想我回来看下然后最好能定下来。2017年5月1日前几天我回武汉去和父母看了一下。 当时看了四套房，都在汉口北地铁站附近： 第一套，位置很偏，旁边还是石子路，配套什么的想都没想。进去小区之后，两个字：“荒芜”，基本没有什么人在那里住，只有一个阿姨推着小孩在那里玩。墙上已经掉漆了，是的，建筑的外墙已经掉漆了，进去楼道口，门和电梯都是旧的，应该是没有物业吧，没人住也不用请物业，不能进去房间里看，就到顶楼看了下，心里很难受，坚决不能买。 第二套，是隔得不远的一间，小区位置还比较好，和之前的比好多了，里面的入住率很高，而且绿化做的很好，就是有个缺点，在一楼或是二楼，阳光不是很好，好像还看了同一个小区的，因为里面的户型不好没有考虑，都是二手房。暂时把这个留作考虑。 第三套，这个很差非常差。。是一个和我一般大的小姑凉带我们看的房，去的路上还有别人在旁边种田，进去后是一个老小区，里面别人住了大几年的那种，很破。房价是一万一平！小姑凉实话说了，之前那里没人来看，因为限购了，所以很多人跑这里买了，这里的价格就起来了。 第四套，是性价比最高的。在第二套的不远处，但是这个是中层，而且是毛坯，户型也还可以采光比较好，大小85平左右，小区物业一般。在楼上看了一下远处新建的一栋楼，问了下中介那么什么价，中介说均价差不多9000-10000，要收10万的茶水费才能买到，就是10万买一个购房名额，当时我们真是目瞪口呆，10万在老家可以付个首付了这里就是一个名额钱。 思来想去，如果买的话最好的选择是第四套，但感觉缺点什么，没有生气还是比较远？父母比较忙也没有时间过来武汉，一直看房子为这事操心，都准备去中介所那里交定金了，一万的定金给预留房源，交了买可以低首付，不买是不能退的。思考了很久，我拉住父母说，我另一个同学也说要在武汉买房子，我参考一下他的意见。 另一个同学也在武汉工作，一个男生，之前和我们说想要在武汉买房，他对武汉应该很熟悉，就问了他很多情况，让他说汉口北是什么情况，建不建议买。他说汉口北有地铁，周边有很多批发市场，看起来还可以，但是离主城区远，周边也没有什么工作的地方，一切都比较虚。这么一说我心里就有点明白了，在回去的时候思考了很久该怎么办。最后灵光一现，干脆回武汉，这样对武汉也熟一些，知道买哪里好，在武汉先工作着，不行就两年后再买，买的很远也不能住没有意义。 然后，我就回武汉了。 可以转户口了2017年8月份，听到一个房产中介朋友说可以转户口了！只要是大学生就可以！ 当时不敢相信，还特地去东湖高新政务中心问了，武汉启动大学生留汉政策，可以办理！然后下个星期我就拿资料去办理了。 办理所需的资料：[2017年9月1日 星期五 10:24 拍的照片] 然后很快拿到准迁证，之后回老家的户籍办理中心，将准迁证给工作人员，然后电脑操作一下在准迁证另一半上盖一个章，再回武汉到洪山区关东派出所将另一半准迁证给工作人员。等一两个月新的身份证下来就好了！ 这时候我终于可以买主城区的房子了！比我预想的快了将近两年。 江夏庙山保利海上五月花 限购区看中的第一套房，严格来讲江夏不算主城区。 租房的时候遇到一个在我爱我家做房产中介的朋友。他在卖二手房，负责保利海上五月花，周末约他去看了一下那的房子。相对之前我看的房子好太多太多了，价格是11600元左右一平，因为是二手房有很多税加一起来差不多这个价，而且是临湖，可以睡到卧室能直接看到湖的哪一种，距离光谷转盘坐公交40-50分钟。没有看到比这还好的了，因为之前看的都比较差。 想买，后来发现我另一同学在武汉做中介，也是在我爱我家，负责另一片区。说可以讲中介费做到0.5%，正常的是2.5%，而且后期还有很多税是和中间评估商有关联的，评估的越高税越贵，他们可以做的低一点，这样算下来可以少几万！当然是找我那同学了，只能对不起那朋友了。 后来，过来这边看了好几次，总觉得还是不太好。第一，单价还是有点贵，第二，房间比较小，77平，两个小房间，两个人住还好，之后人多了不方便，不过当时的首付只有35w，所以大点的话了买不起。总的来说，基本满足我的需要。 江夏庙山广信万汇城 江夏庙山地理位置最好的盘 父母过来准备交首付了，想带父母去房子里看一下，路过了《广信万汇城》。显然那个盘比保利海上五月花好，新房而且地理位置好，旁边就是武昌理工学院。当时单价是9500元一平，算了下，就算交8万的茶水费买97平的和买保利海上五月花一样的价。何乐而不为，当时就定了广信万汇城！ 10月份交了认筹资料就没有管了，因为交了茶水费可以说是稳了，大伙基本也知道怎么回事，说的是不交买不到的，没想到的是交了也买不到。 过了两个月，通知开盘，交了20w的认筹金，然后开盘后被告知没有搞到房子，开发商那边炸了，收了很多的茶水费，房子不够用了，大家都没有得到。被号称是全球最快秒光盘，全部内定，一进去选房系统全部秒红，事后很多人去销售中心拉横幅，我还被加入了好多的“广信万汇城退筹群”。这这一次开的是第二期，第三期定在2018年下旬了，没有请营销团队，全部内部售卖，可以说是非常厉害了！ 秒光视频 - 说不定什么时候就没有了—“垃圾，都被内定了，还收20万认凑金，收了一千多份，这样的开发商政府为什么不查？老百姓就这样被折腾没人管吗？大家现在需要的是真相，全部房拿出去收茶水费，还要骗这么多认凑，太过分了！” 之后同学推荐了中海光谷锦城，说的是双轨交汇，就是贵了点差不多四十几万的首付，给父母说了太贵就没作考虑。然后马上过年回家了，这年就没有买到。 保利海上五月花最后一期 在毛坯房绝迹时，保利海上五月花最后一期毛坯房推出了 这次的政策很好，房产商的120平以下的房源，40%拿出来作为刚需选房(2018年6月1日后是60%)。就是如果有100套120平以下的房，那么，就拿40套出来让刚需的先选择一次，没有选中再选择另外的房源。评为刚需的条件是：在武汉没有房而且多少年内没有贷款记录。由房管局将所有刚需的人摇号排序依次选房，保利海上五月花最后一期刚需房源有180套，我被摇到了90名，就是说我是第90人进去选房子的人，选一个少一套。 经过一定的思想斗争，我放弃了。之前一直想买的房子现在免费给我机会不要茶水费，毛坯，而且单价是9700元，这里的二手房价已经是12000元了，网上内定名额已经炒到10w一个人了。这里的交通(2049年都没有规划地铁)，教育配套，生活配套都不行，仅有的好处是便宜。考虑到后期这里显然不是最佳的选择。 安居客看房团 白沙洲线路：新力城、美好长江首玺、东原乐见城、中悦滨湖尚城、加州橘郡 为了了解更多的房源，在安居客上报了一个白沙洲线路的看房团，这条线路的盘均价在12000左右。 新力城、美好长江首玺性价比比较高，属于白沙洲，现在的周边环境不太适合居住，交通也基本没有，新力城都没有公交车到那里。不过周围已经规划地铁，相信以后会很好。 东原乐见城位置最好，在南湖，但价格也最高，首付60-70w，验资50w,装修不能贷款。周边有地铁并且已经开通，生活氛围也浓厚。 中悦滨湖尚城属于江夏，四环外了，距离地铁线也比较远，好处是周围有几个学校和一个腾讯大厦，居然叫出12500的高价，应该是距离江夏市政府比较近或其他缘故。 加州橘郡在江夏庙山，距离保利海上五月花比较近，自从经历了广信万汇城，觉得庙山其他的盘都看不上眼了。自带幼儿园小学，周边都是私立学校，置业说一年5w学费，一般人真的上不起，很多家长陪读的，出租到是很好。后期开盘人也是爆满。 和公司的一个同事一起去看的，然后在路上遇到了一个一起看房的哥们，从他口中得知了《康桥知园》这个楼盘，说是价格适中，而且地理位置也可以，之前加过他们的置业，马上截止交资料了就把资料拍照发给了置业。 康桥知园 旁边楼盘有：招商东城华府和中海光谷锦城。 位置：位于东湖高新区佛祖岭地块，距离佛祖岭地铁站(2号线南延线最后一站)1.7km左右。旁边的中海和招商华府都属于江夏。 价格：郑州康桥集团拿的地，7200多一点，均价15500元，价格还能接受，周边的中海和招商华府都差不多是这个价，中海的地拿的是8300元左右，是江夏地王。首付将近50w。 配套：说的三轨交汇，2号线，9号线和有轨。2号线2019年1月份开通，有轨已经开通，9号线的站点会距离项目更近一些，不过是很久之后的事情了，也属于2期建设，不知道是何年何月。周边有很多学校，幼儿园小学初中高中都有，而且都可以上，隔壁的楼盘则不能。 小区规模：这个相对劣势，只有三栋楼288户卖完就没有了，不过小区的绿化楼间距可以，品质也比较好。 武汉阿松的评价： 武汉有这样一个盘 开发商竟然不以赚钱为目的？ 阿松楼书：康桥知园-光谷稀有品质房 所有房源一次性全部推出！ 康桥知园VS中海光谷锦城！ 地理位置 东湖高新 - 武汉东湖新技术开发区 有人评价东湖高新和汉阳：一个是高科技里搞住宅，一个是住宅里搞高科技。 如果说以前武汉的中心是汉口，那现在武汉的中心就是东湖高新。 光谷是宇宙中心，光谷东是上海，光谷南是广州，光谷西是成都，光谷北是北京。 一个与市政府平级的行政区 不做多的解释了，看百度百科： 武汉东湖新技术产业开发区 从0到518平方公里！武汉最牛X的区是如何炼成的？ 贷款事项 房贷 装修贷 利率：25% 经过一系列操作，最终成功买到了康桥知园，总价160w左右，首付50w左右，房贷和装修贷是分开的。 房贷：首套房30%(第二套50%)，招商，利率上浮25%，总贷款94w，还款30年。 装修贷：中行信用卡，贷款18w，还款8年。 算在一起每月还款8k左右了，在武汉，房价现在这个价很正常，每月月供这个多，在武汉拿的工资很难还得起。除非装修款提前还完之后的生活就宽裕一点。 拿到房子后等通知去售楼部交贷款资料给相关银行审核，前提是我和我父母的收入(可以添加父母为共同还款人)加起来是贷款的2倍，就是一月1.6k。审核的细节很多，还要看父母的征信等，父母过来排了半天的队，半辈子的积蓄就给了首付钱，心里很难受。 给银行审核的时间差不多一个月左右，然后成功后去售楼部交首付，交完首付签购房合同，合同拿去给房管局盖章时间差不多也是一个月左右。然后房贷放款，售楼部拿到购房合同去中行放装修款，这个时间也将近大半个月吧。 最后等房贷和装修贷全部放款之后，就去售楼部拿的购房合同。 落户及房产证 置业说的是90天之后可以拿购房合同去东湖高新政务服务中心办理房产证。 听阿松讲。东湖高新这样的主城区需要100平米以上才能落户，其他的区有点不一样，面积可以小一点。还没有办理房屋落户和房产证暂不多说。 结语由最初的能买到，能住就好，到最后考虑到行政区、交通、教育、离上班的位置距离、周边商业、户型。这一年多的买房经历真是学到了不少，以前东南西北都分不清，现在因为要看房子的朝向都老熟了，房子朝南偏13度才是最佳朝向，而不是正朝南。 最辛苦的还是父母，首付钱基本是父母支持的，家里本不富裕，一个农村人在武汉买一套房是多不容易的事情，周围的小伙伴在武汉买房的毕竟还是少数，后期会更加努力争取过上更好的生活。 基本完。 2018.6.13 00:41 夜深，下次更。2018.6.13 22:51 基本结束]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo permalink设置技巧]]></title>
    <url>%2F2018%2F06%2F06%2Fset-hexo-permalink%2F</url>
    <content type="text"><![CDATA[背景之前的文章有幸被鸿洋的公众号收录，文章内引用了博客中的一篇文章链接：https://jingbin.me/2017/11/23/%E5%BC%80%E5%8F%91%E4%B8%AD%E6%89%80%E9%81%87%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3/；着实尴尬，因为默认生成的文章链接是:year/:month/:day/:title/，里面的汉字经过转义，导致了这样的结局。 永久链接看一下永久链接（Permalinks）的解释，在站点的_config.yml中，生成的文章链接默认为： 12permalink: :year/:month/:day/:title/permalink_defaults: 因为title可能为中文，那生成的链接就可能为上面的情况，这时候我们希望自己在每篇文章的Front-matter中指定一个字段，然后替换title，这样就可以显示我们自己定义的url了，例如： permalink: :year/:month/:day/:urlname/ permalink: post/:urlname/ 1234permalink: :year/:month/:day/:urlname/# 当没有urlname时显示什么,写上 :title 也没有用，会作为字符串处理permalink_defaults: urlname: index 因为之前文章的形式是:year/:month/:day/:title/，为了保留以前的文章阅读数，这里我使用第一种形式，然后在以前每篇文章的Front-matter中加上urlname，保持和以前的文章链接一致就可以了，例子： 12345678910---title: 《Android群英传 神兵利器》读书笔记urlname: 《Android群英传-神兵利器》读书笔记date: 2018-02-04 23:16:31tags:- Android- Books- 工具categories: Android--- 注意：标题上的空格，有时候转义为“%20”，有时候则为“-”。其他的特殊字符也要注意，不然和以前的文章就不是一个链接了！ 为了每次hexo new “my new blog title”时就有urlname字段，我们可以在scaffolds/post.md里配上这个字段，例如： 1234567---title: &#123;&#123; title &#125;&#125;urlname: date: &#123;&#123; date &#125;&#125;tags:categories:--- 这样生成的链接形式就是这样了：https://jingbin.me/2018/06/06/set-hexo-permalink/ 总结一下 修改站点文件_config.yml中的permalink： 123permalink: :year/:month/:day/:urlname/permalink_defaults: urlname: index 在scaffolds/post.md里配上urlname字段：1234567---title: &#123;&#123; title &#125;&#125;urlname: date: &#123;&#123; date &#125;&#125;tags:categories:--- hexo遇到的问题hexo d卡很久之前遇到的一个问题，折磨了几天，和这篇文章无关，现记录在这里：用hexo d命令部署的时候总是会卡住很久，只用hexo d -debug查看日志发现信息一直在循环： 123456789101112▶ hexo d -debugINFO Start processingINFO Files loaded in 620 msINFO Start processingINFO Files loaded in 342 ms...INFO Start processingINFO Files loaded in 274 msINFO 0 files generated in 381 msINFO Start processing^C Bye! 这里和另一个使用hexo的人情况一致，hexo deploy 命令卡住的奇怪问题，参考他的解决方法还是没有解决，估计每个人产生的原因可能不一致，最后删除db.json 文件才好了。 debug预览错误提示 TypeError: The header content contains invalid characters 网上有说是链接上有中文的原因，不过是2016年的了。 我的是使用了![图片](图片)这样的文本，本想做一个占位然后后期补上的，不过加上这个会导致错误！ 主页底部的访问数量显示失效之前一直以为底部的访问数量是leancloud来计数的，后来发现错了。 leancloud是用来统计文章的访问量的，不蒜子才是用来统计站点的总访问量的。 因七牛强制过期『dn-lbstatics.qbox.me』域名，与客服沟通无果，只能更换域名到『busuanzi.ibruce.info』！导致站点的总浏览量显示不出，更改就好了：找到对应的next主题文件：_scripts/third-party/analytics/busuanzi-counter.swig 更改对应的域名为：busuanzi.ibruce.info 使用不蒜子添加总访问量 不蒜子 - 极简网页计数器 相关文章 Mac搭建Hexo博客流程记录，排雷完成 HEXO的站内链接和永久链接 在hexo博客中打造相对完美的URL hexo问题篇(偶尔抽抽疯)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次面试题的简单整理]]></title>
    <url>%2F2018%2F05%2F27%2F%E4%B8%80%E6%AC%A1%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84%E7%AE%80%E5%8D%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[牛客网：https://www.nowcoder.com/9070733 选择题1、广播的注册方式 123456&lt;!--广播注册--&gt; &lt;receiver android:name=".SmsBroadCastReceiver"&gt; &lt;intent-filter android:priority="20"&gt; &lt;action android:name="android.provider.Telephony.SMS_RECEIVED"/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 2、android 关于service生命周期的onCreate()和onStart()说法正确的是?(AD) A.当第一次启动的时候先后调用onCreate()和onStart()方法 B.当第一次启动的时候只会调用onCreate()方法 C.如果service已经启动，将先后调用onCreate()和onStart()方法 D.如果service已经启动，只会执行onStart()方法，不在执行onCreate()方法 3.在android中使用Menu时可能需要重写的方法有?（AC） A.onCreateOptionsMenu() B.onCreateMenu() C.onOptionsItemSelected() D.onItemSelected() 12345678910111213141516171819202122232425262728293031323334353637public class MainActivity extends Activity &#123; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); &#125; @Override public boolean onCreateOptionsMenu(Menu menu) &#123; // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater().inflate(R.menu.activity_main, menu); return true; &#125; @Override public boolean onOptionsItemSelected(MenuItem item) &#123; // TODO Auto-generated method stub switch(item.getItemId())&#123; case R.id.menu_about: Toast.makeText(MainActivity.this, ""+"关于", Toast.LENGTH_SHORT).show(); break; case R.id.menu_settings: Toast.makeText(MainActivity.this, ""+"设置", Toast.LENGTH_SHORT).show(); break; case R.id.menu_quit: Toast.makeText(MainActivity.this, ""+"退出", Toast.LENGTH_SHORT).show(); break; default: break; &#125; // Toast.makeText(MainActivity.this, ""+item.getItemId(), Toast.LENGTH_SHORT).show(); return super.onOptionsItemSelected(item); &#125; 4.android中下列属于intent的作用是(C) A.实现应用程序间的数据共享 B.是一段长的生命周期，没有用户界面的程序，可以保持应用在后台运行，而不会因为切换页面而消失 C.可以实现界面间的切换，可以包含动作和动作数据，连接四大组件的纽带 D.处理一个应用程序整体性的工作 不同activity间的数据共享 5.如果在Activity中对一些资源以及状态进行保存操作，最好是在生命周期的哪个函数中进行呢？（A） A.onPause() B.onCreat() C.onResume() D.onStart() 暂停的时候保存。在onPause()时候保存状态，才能保存用户最终的使用状态。 6.android 工程最后生成的工程文件是？ 1234app\build\intermediates文件夹里是也intermediates：是一个中间人，调节人的意思，java源文件转为class文件后再转为dex文件，最后生成apk这里面class文件夹就被存放在intermediates文件夹里面 填空题1.android常用的五种布局FrameLayout(框架布局)，LinearLayout(线性布局)，RelativeLayout(相对布局)，AbsoluteLayout(绝对布局)，TableLayout(表格布局) 2.Android四大基本组件分别是Activity，Service服务,Content Provider内容提供者，BroadcastReceiver广播接收器。 3.android 中 service 的实现方法是： __ 和 _ 。start 和 bind 4.Android的系统体系结构分为四层，自顶向下分别是 应用程序(Applications) 应用程序框架(Application Frameworks) 系统运行库与Android运行环境(Libraris &amp; Android Runtime) Linux内核(Linux Kernel) 5.AsyncTask是什么？AsyncTask的使用方法？android的类AsyncTask对线程间通讯进行了包装，提供了简易的编程方式来使后台线程和UI线程进行通讯：后台线程执行异步任务，并把操作结果通知UI线程。 123456789101112131415161718192021222324252627282930313233343536373839404142class DownloadTask extends AsyncTask&lt;Integer, Integer, String&gt;&#123; //后面尖括号内分别是参数（例子里是线程休息时间），进度(publishProgress用到)，返回值 类型 @Override protected void onPreExecute() &#123; //第一个执行方法 super.onPreExecute(); &#125; @Override protected String doInBackground(Integer... params) &#123; //第二个执行方法,onPreExecute()执行完后执行 for(int i=0;i&lt;=100;i++)&#123; pb.setProgress(i); publishProgress(i); try &#123; Thread.sleep(params[0]); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return "执行完毕"; &#125; @Override protected void onProgressUpdate(Integer... progress) &#123; //这个函数在doInBackground调用publishProgress时触发，虽然调用时只有一个参数 //但是这里取到的是一个数组,所以要用progesss[0]来取值 //第n个参数就用progress[n]来取值 tv.setText(progress[0]+"%"); super.onProgressUpdate(progress); &#125; @Override protected void onPostExecute(String result) &#123; //doInBackground返回时触发，换句话说，就是doInBackground执行完后触发 //这里的result就是上面doInBackground执行后的返回值，所以这里是"执行完毕" setTitle(result); super.onPostExecute(result); &#125; &#125; AsyncTask 的使用方法和工作原理 6.什么是AIDL？AIDL是如何工作的？ AIDL: Android Interface Definition Language AIDL是一种IDL语言，用于生成可以在Android设备上两个进程之间进行进程间通信(interprocess communication, IPC)的代码。如果在一个进程中（例如Activity）要调用另一个进程中（例如Service）对象的操作，就可以使用AIDL生成可序列化的参数。 AIDL是一种接口定义语言，用于生成可在Android设备上两个进程之间进行进程间通信(IPC)的代码。高度概括AIDL的用法，就是服务端里有一个Service，给与之绑定(bindService)的特定客户端进程提供Binder对象。客户端通过AIDL接口的静态方法asInterface 将Binder对象转化成AIDL接口的代理对象，通过这个代理对象就可以发起远程调用请求了。 引：https://blog.csdn.net/tellh/article/details/55100167 7.Android中如何避免OOM异常？ Java.lang.OutOfMemoryError : bitmap size exceeds VM budget。 OOM 内存溢出，想要避免OOM 异常首先我们要知道什么情况下会导致OOM 异常。1、图片过大导致OOM2、界面切换导致OOM3、在页面切换时尽可能少地重复使用一些代码3、查询数据库没有关闭游标4、构造Adapter 时，没有使用缓存的convertView5、Bitmap 对象不再使用时调用recycle()释放内存6、其他Android 应用程序中最典型的需要注意释放资源的情况是在Activity 的生命周期中，在onPause()、onStop()、onDestroy()方法中需要适当的释放资源的情况。使用广播没有注销也会产生OOM。 https://blog.csdn.net/jiayi_yao/article/details/51107960 8.什么是ANR 如何避免它？ ANR：Application Not Responding 不同的组件发生ANR的时间不一样，Activity是5秒，BroadCastReceiver是10秒，Service是20秒。解决方案：1、将所有耗时操作，比如访问网络，Socket 通信，查询大量SQL 语句，复杂逻辑计算等都放在子线程中去，然后通过handler.sendMessage、runonUITread、AsyncTask 等方式更新UI，以确保用户界面操作的流畅度。2、如果耗时操作需要让用户等待，那么可以在界面上显示进度条。 https://blog.csdn.net/m_xiaoer/article/details/62438802 9.NDK 与 JNI 是什么？ JNI: Java Native Interface，即 Java本地接口NDK: Native Development Kit，是 Android的一个工具开发包 JNI介绍定义：Java Native Interface，即 Java本地接口作用： 使得Java 与 本地其他类型语言（如C、C++）交互即在 Java代码 里调用 C、C++等语言的代码 或 C、C++代码调用 Java 代码 特别注意：JNI是 Java 调用 Native 语言的一种特性JNI 是属于 Java 的，与 Android 无直接关系 实现步骤:1.在Java中声明Native方法（即需要调用的本地方法）2.编译上述 Java源文件javac（得到 .class文件）3.通过 javah 命令导出JNI的头文件（.h文件）使用 Java需要交互的本地代码 实现在 Java中声明的Native方法如 Java 需要与 C++ 交互，那么就用C++实现 Java的Native方法4.编译.so库文件5.通过Java命令执行 Java程序，最终实现Java调用本地代码 NDK介绍定义：Native Development Kit，是 Android的一个工具开发包NDK是属于 Android 的，与Java并无直接关系 作用：快速开发C、 C++的动态库，并自动将so和应用一起打包成 APK即可通过 NDK在 Android中 使用 JNI与本地代码（如C、C++）交互 https://blog.csdn.net/carson_ho/article/details/73250163 10.Android Fragment 生命周期图 fragments的大部分状态都和activitie很相似，但fragment有一些新的状态。 onAttached() —— 当fragment被加入到activity时调用（在这个方法中可以获得所在的activity）。onCreateView() —— 当activity要得到fragment的layout时，调用此方法，fragment在其中创建自己的layout(界面)。onActivityCreated() —— 当activity的onCreated()方法返回后调用此方法onDestroyView() —— 当fragment中的视图被移除的时候，调用这个方法。onDetach() —— 当fragment和activity分离的时候，调用这个方法。 一旦activity进入resumed状态（也就是running状态），你就可以自由地添加和删除fragment了。因此，只有当activity在resumed状态时，fragment的生命周期才能独立的运转，其它时候是依赖于activity的生命周期变化的。 http://www.cnblogs.com/purediy/p/3276545.html 11.Android5.0和6.0之后有哪些新控件？Android5.0和6.0之后新增的控件，在项目中使用的时候，可分为三大类： 1、第一类是内核提供的控件，位于SDK的android.jar中。这个与系统版本有关，每个版本的android.jar是固定的，有在该内核中定义的控件才能正常调用，没在内核中定义的控件在运行时会扔出类找不到的异常。比如水波图形RippleDrawable和矢量图形VectorDrawable，这两个控件在Android5.0之后的系统内核中提供，所以只有系统版本不低于5.0的手机才能使用它们，运行4.*系统的手机是无法正常调用这两个控件的。 2、第二类是v4兼容库提供的控件，位于SDK的android-support-v4.jar中。v4库默认会被编译进App的安装包，所以它不需要系统内核支持，可直接运行在4.0之后的所有系统上，并且App工程无需手工导入v4库。使用v4控件唯一需要注意的地方，是布局文件中要引用完整路径的控件名称，如抽屉布局android.support.v4.widget.DrawerLayout、下拉刷新布局android.support.v4.widget.SwipeRefreshLayout等等。 3、第三类是v7兼容库和design库，它们有各自的库工程，开发者要在App工程中手工导入用到的兼容库。v7与design库导入App工程后，编译出来的App即可兼容4.*的系统。使用v7与design库的控件，类似于使用自定义控件，不但要在布局文件中引用完整路径的控件名称，还要在根布局声明命名空间（即添加属性xmlns:app=http://schemas.android.com/apk/res-auto），然后方可使用这些控件的自定义属性。这部分控件数量最多，实现的界面特效最丰富，而且互相之间存在依赖关系，如design库依赖于appcompat-v7库，部分design控件如NavigationView还依赖于recyclerview-v7库，所以若要正确使用design库的控件，往往得同时导入好几个相关的兼容库。 https://blog.csdn.net/aqi00/article/details/59108336 编程题1.写一个自己的Handler，对消息进行处理 2.写一个冒泡排序1234567891011121314151617public class bubbleSort &#123;public bubbleSort()&#123; int a[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;; int temp=0; for(int i=0;i&lt;a.length-1;i++)&#123; for(int j=0;j&lt;a.length-1-i;j++)&#123; if(a[j]&gt;a[j+1])&#123; temp=a[j]; a[j]=a[j+1]; a[j+1]=temp; &#125; &#125; &#125; for(int i=0;i&lt;a.length;i++) System.out.println(a[i]); &#125;&#125; 3.快速排序基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。 1234567891011121314151617181920212223242526272829303132333435363738394041public class quickSort &#123;inta[]=&#123;49,38,65,97,76,13,27,49,78,34,12,64,5,4,62,99,98,54,56,17,18,23,34,15,35,25,53,51&#125;;public quickSort()&#123; quick(a); for(int i=0;i&lt;a.length;i++) System.out.println(a[i]);&#125;public int getMiddle(int[] list, int low, int high) &#123; int tmp = list[low]; //数组的第一个作为中轴 while (low &lt; high) &#123; while (low &lt; high &amp;&amp; list[high] &gt;= tmp) &#123; high--; &#125; list[low] = list[high]; //比中轴小的记录移到低端 while (low &lt; high &amp;&amp; list[low] &lt;= tmp) &#123; low++; &#125; list[high] = list[low]; //比中轴大的记录移到高端 &#125; list[low] = tmp; //中轴记录到尾 return low; //返回中轴的位置 &#125; public void _quickSort(int[] list, int low, int high) &#123; if (low &lt; high) &#123; int middle = getMiddle(list, low, high); //将list数组进行一分为二 _quickSort(list, low, middle - 1); //对低字表进行递归排序 _quickSort(list, middle + 1, high); //对高字表进行递归排序 &#125; &#125; public void quick(int[] a2) &#123; if (a2.length &gt; 0) &#123; //查看数组是否为空 _quickSort(a2, 0, a2.length - 1); &#125; &#125;&#125; https://blog.csdn.net/pzhtpf/article/details/7560294 kotlin了解一下kotlin中国]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 水波纹效果的探究]]></title>
    <url>%2F2018%2F05%2F20%2FAndroid%20%E6%B0%B4%E6%B3%A2%E7%BA%B9%E6%95%88%E6%9E%9C%E7%9A%84%E6%8E%A2%E7%A9%B6%2F</url>
    <content type="text"><![CDATA[前言水波纹效果从Android5.0就已经出来了，基本的使用相信大家都知道了，这里多谈一些相对深层次的使用： 1、基本使用 2、水波纹效果与布局绘制之间的问题 3、长按水波纹扩散效果 4、Button点击的水波纹效果 基本使用系统自带水波纹实现方式有界水波纹1android:background="?android:attr/selectableItemBackground" 无界水波纹 以控件宽高中最大的数值作为水波纹效果所在正方形的边界进行绘制 1android:background="?android:attr/selectableItemBackgroundBorderless" 自定义水波纹实现方式无界水波纹1234&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;ripple xmlns:android="http://schemas.android.com/apk/res/android"android:color="@color/colorAccent"&gt; &lt;/ripple&gt; 有界水波纹1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ripple xmlns:android="http://schemas.android.com/apk/res/android" android:color="@color/itemBackground"&gt; &lt;item &gt; &lt;color android:color="@android:color/white" /&gt; &lt;/item&gt;&lt;/ripple&gt; 水波纹效果与布局绘制之间的问题在使用了以上的自定义有界水波纹点击效果后，使用[开发者选项 - 调试GPU过渡绘制]得到下面的视图 对比后，发现绿色的文字部分经过了二重绘制，因为布局的白色背景和文字自身颜色的原因。如果布局背景能去掉还能实现水波纹的效果就好了，这样就只有文字一层的颜色。 有两种方案可以达到想要的这种效果：1、使用系统自带有界水波纹实现方式，因为系统本身的默认背景是透明色的。1android:background="?android:attr/selectableItemBackground" 系统的默认水波纹颜色是灰色，如果需要使用对应的高亮色来作为ripple的背景色，我们可以在styles-v21系统主题里加入这个：&lt;item name = &quot;android:colorControlHighlight&quot;&gt;@color/colorAccent&lt;/item&gt; 2、使用自定义有界水波纹效果，使其默认背景色为透明色。写法： 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ripple xmlns:android="http://schemas.android.com/apk/res/android" android:color="@color/itemBackground"&gt; &lt;item android:id="@android:id/mask"&gt; &lt;color android:color="@android:color/white" /&gt; &lt;/item&gt;&lt;/ripple&gt; 添item时，如果指定id为@android:id/mask，那么不点击时不会显示出该item指定的color。可以设置指定子层item的android:id=”@android:id/mask”来设定当前Ripple的Mask。Mask的内容并不会被绘制到屏幕上，它的作用是限定Ripple效果的绘制区域。 最后可以得到我们想要的效果： 长按水波纹扩散效果 在使用小红书时，我们可以看到关于“笔记”的item长按会展示扩散的效果。1android:foreground="?attr/selectableItemBackgroundBorderless" 又或者，无边界的水波纹也可以达到长按扩散的效果，只是它会超出边界，那我们就在对应的父布局加一层有边界的水波纹背景即可。就像这样： 12345678910111213&lt;RelativeLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:background="?attr/selectableItemBackground"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="wrap_content" android:background="?attr/selectableItemBackgroundBorderless" android:onClick="@&#123;()-&gt;adapter.openDetail(bean)&#125;" android:padding="8dp"&gt; &lt;/RelativeLayout&gt;&lt;/RelativeLayout&gt; 两者的区别是：长按扩散时，前者的水波纹会在图片之上，而后者在图片之下。 Button点击的水波纹效果 12345678910&lt;Button style="@style/Widget.AppCompat.Button.Colored" android:layout_width="0dp" android:layout_height="wrap_content" android:layout_marginLeft="20dp" android:layout_weight="1" android:onClick="login" android:text="登陆" android:textColor="@android:color/white" android:textStyle="bold" /&gt; The Widget.AppCompat.Button.Colored 继承了 Widget.AppCompat.Button style并且根据你选择的主题应用最接近的颜色。 参考资料 Ripple 水波纹效果 聊聊Android5.0中的水波纹效果 解决点击ripple水波纹无效的问题 UI之修改Button颜色保持默认点击效果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能优化之布局优化记录]]></title>
    <url>%2F2018%2F05%2F17%2F%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B9%8B%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[做开发时间长了之后，收集后台的bug，发现很多都是OOM(Out Of Memory Killer)。性能优化这时候成为了重点，下面是自己项目中布局优化的记录，希望对大家有所帮助。 父布局 对于ViewGroup的选择问题：推荐FrameLayout &gt; LinearLayout &gt; RelativeLayout(为了优化布局，RelativeLayout会调用childrenView 的onMeasure()两次)，推荐阅读：LinearLayout与RelativeLayout的性能比较 尽量不要嵌套使用RelativeLayout. 尽量不要在嵌套的LinearLayout中都使用weight属性. 避免使用多重布局嵌套，层级能少就少 善用TextView的Drawable减少布局层级 背景色 去掉多余的布局背景色，比如ScrollView包裹的内容分为两段，第一段使用的是match_parent的宽，第二段是文字，只需要给文字部分加背景，则背景色属性就放在文字部分的节点属性里。 RecyclerView及ViewPager等外部容器最好不要使用背景色，如果内容有背景色会导致重叠 selector可使用系统自带的点击效果android:background=&quot;?attr/selectableItemBackground&quot;，因为初始值为透明色，不会重绘。如果需要使用对应的高亮色来作为ripple的背景色，那么就需要在styles-v21里面加这个加入：&lt;item name = &quot;android:colorControlHighlight&quot;&gt;@color/colorAccent&lt;/item&gt; 注：Navigation的background会影响4.4系统的状态栏 CardView会自动加一层背景色 ripple里的默认颜色为标签下设置，如果设置多个重复的会导致多重绘制。 ripple里如要设置默认色为透明色，因为设置透明色不会导致重新绘制。直接设置color=&quot;@android:color/transparent&quot;点击会没有效果，加上一个掩码就好了 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;ripple xmlns:android="http://schemas.android.com/apk/res/android" android:color="@color/itemBackground"&gt; &lt;item android:id="@android:id/mask"&gt; &lt;color android:color="@android:color/white" /&gt; &lt;/item&gt;&lt;/ripple&gt; Mask层(Mask Layer):可以设置指定子层item的android:id=”@android:id/mask”来设定当前Ripple的Mask。Mask的内容并不会被绘制到屏幕上，它的作用是限定Ripple效果的绘制区域。mask所在的的子层限制了Ripple效果的最大范围只能是View的边界，不会扩散到父组件。 布局优化标签1、&lt;include&gt;：常用于将布局中的公共部分提取出来供其他layout共用，以实现布局模块化，这在布局编写方便提供了大大的便利。 2、&lt;viewstub&gt;：viewstub标签同include标签一样可以用来引入一个外部布局，不同的是，viewstub引入的布局默认不会扩张，即既不会占用显示也不会占用位置，从而在解析layout时节省cpu和内存。viewstub常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等。比较直观的感觉是：在设置里打开显示布局边界后，如果不是使用&lt;viewstub&gt;标签，GONE掉后，加载中的布局还是会有颜色显示，而使用了此标签后颜色会消失。 使用前 使用后 3、&lt;merge&gt;：在使用了include后可能导致布局嵌套过多，多余不必要的layout节点，从而导致解析变慢，不必要的节点和嵌套可通过hierarchy viewer(下面布局调优工具中有具体介绍)或设置-&gt;开发者选项-&gt;显示布局边界查看。 优化工具1、GPU过渡绘制：Graphic Processing Unit 位置：设置/选择开发选项（Developer Options）/调试GPU 过度绘制（Debug GPU Overdraw），然后选择“显示过度绘制区域（Show overdraw area）”。 定义：指在屏幕上的一个像素在单个帧中被重绘了多次。可以通过手机设置/开发者选项/调试GPU过渡绘制/，不同的颜色显示了渲染过渡程度 2、Hierarchy Viewer3、Lint tool 优化结果 优化前 优化后 对应项目：CloudReader 参考资料 性能优化之布局优化 [Android] 布局优化 Android性能优化–布局优化]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[健身记录]]></title>
    <url>%2F2018%2F04%2F28%2F%E5%81%A5%E8%BA%AB%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[从2017五月中旬开始锻炼了半年有余，体重从57kg到68kg，算是达成目标。后期的持续锻炼也很重要，前天去健身房练背，有些动作忘记了，记录下来今后查阅。 心肺训练(有氧) 深蹲跳 箭步蹲 原地碎步跑20s＋俯卧撑8 单脚过障碍 蛙跳 跳绳 无氧训练胸 俯卧撑 史密斯平板卧推 坐姿黄蜂推胸 小杠铃平板卧推 高位俯卧撑 上斜卧推 站姿钢线夹胸 坐姿夹胸 仰卧推胸飞鸟 腹 平板支撑 高位抬腿 卷腹 高位俯卧撑 – 抬腿 坐姿腿屈伸 两头起+卷腹 自行车碰膝、大风车 仰卧起坐 山羊挺身 腰 哑铃侧身弯体 侧身弯体 侧身抬腿 杠铃前躬体 单腿罗马尼亚硬拉 罗马椅背屈伸 背部 坐姿划船 高位下拉 俯身哑铃臂屈伸 杠铃拉背 杠铃硬拉 大黄蜂拉背 自重引体 俯身飞鸟 器械夹背 腿 倒蹬机 器械开腿 器械合退 器械反勾腿 哑铃箭步走 杠铃深蹲 器械腿屈伸 史密斯深蹲 二头肌 二头弯举 哑铃自由二头弯举 二头举重龙门架 杠铃站姿弯举 肩 器械推肩 坐姿哑铃推肩 哑铃侧平举 仰卧哑铃屈伸 大黄蜂推肩 哑铃臂屈伸 放松伸展 斜方肌上束 肩胛提肌 胸锁乳突肌 斜角肌 腰方肌左侧 筋膜放松 仰卧肚脐回贴 弹力带仰卧下拉 弹力带推肩 弹力带提拉 弹力带外展 弹力带下拉 蛙泳划臂 支撑抬臀]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《第一行代码：Android（第2版）》读书笔记]]></title>
    <url>%2F2018%2F04%2F28%2F%E3%80%8A%E7%AC%AC%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%9AAndroid%EF%BC%88%E7%AC%AC2%E7%89%88%EF%BC%89%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《第一行代码：Android（第2版）》 - 被广大Android 开发者誉为“Android 学习第一书”。全书系统全面、循序渐进地介绍了Android软件开发的必备知识、经验和技巧。 内容比较基础，查漏补缺，记一些重点。 第2版基于Android 7.0 对第1 版进行了全面更新，将所有知识点都在最新的Android 系统上进行重新适配，使用 全新的Android Studio 开发工具代替之前的Eclipse，并添加了对Material Design、运行时权限、Gradle、RecyclerView、百分比布局、OkHttp、Lambda 表达式等全新知识点的详细讲解。 Android系统架构总的来说，Android的系统体系结构分为四层，自顶向下分别是 应用程序(Applications) 应用程序框架(Application Frameworks) 系统运行库与Android运行环境(Libraris &amp; Android Runtime) Linux内核(Linux Kernel) 应用程序(Applications)Android会同一系列核心应用程序包一起发布，该应用程序包包括email客户端，SMS短消息程序，日历，地图，浏览器，联系人管理程序等。所有的应用程序都是使用JAVA语言编写的。通常开发人员就处在这一层。 应用程序框架(Application Frameworks)提供应用程序开发的各种API进行快速开发，也即隐藏在每个应用后面的是一系列的服务和系统，大部分使用Java编写，所谓官方源码很多也就是看这里，其中包括： 丰富而又可扩展的视图（Views），可以用来构建应用程序， 它包括列表（lists），网格（grids），文本框（text boxes），按钮（buttons）， 甚至可嵌入的web浏览器。 内容提供器（Content Providers）使得应用程序可以访问另一个应用程序的数据（如联系人数据库）， 或者共享它们自己的数据 资源管理器（Resource Manager）提供 非代码资源的访问，如本地字符串，图形，和布局文件（ layout files ）。 通知管理器 （Notification Manager） 使得应用程序可以在状态栏中显示自定义的提示信息。 活动管理器（ Activity Manager） 用来管理应用程序生命周期并提供常用的导航回退功能。 系统运行库与Android运行环境(Libraris &amp; Android Runtime)系统运行库Android 包含一些C/C++库，这些库能被Android系统中不同的组件使用。它们通过 Android 应用程序框架为开发者提供服务。以下是一些核心库： Bionic系统 C 库 - 一个从 BSD 继承来的标准 C 系统函数库（ libc ）， 它是专门为基于 embedded linux 的设备定制的。 媒体库 - 基于 PacketVideo OpenCORE；该库支持多种常用的音频、视频格式回放和录制，同时支持静态图像文件。编码格式包括MPEG4, H.264, MP3, AAC, AMR, JPG, PNG 。 Surface Manager - 对显示子系统的管理，并且为多个应用程序提 供了2D和3D图层的无缝融合。这部分代码 Webkit,LibWebCore - 一个最新的web浏览器引擎用，支持Android浏览器和一个可嵌入的web视图。鼎鼎大名的 Apple Safari背后的引擎就是Webkit SGL - 底层的2D图形引擎 3D libraries - 基于OpenGL ES 1.0 APIs实现；该库可以使用硬件 3D加速（如果可用）或者使用高度优化的3D软加速。 FreeType -位图（bitmap）和矢量（vector）字体显示。 SQLite - 一个对于所有应用程序可用，功能强劲的轻型关系型数据库引擎。 还有部分上面没有显示出来的就是硬件抽象层。其实Android并非讲所有的设备驱动都放在linux内核里面，而是实现在userspace空间，这么做的主要原因是GPL协议，Linux是遵循该 协议来发布的，也就意味着对 linux内核的任何修改，都必须发布其源代码。而现在这么做就可以避开而无需发布其源代码，毕竟它是用来赚钱的。 而 在linux内核中为这些userspace驱动代码开一个后门，就可以让本来userspace驱动不可以直接控制的硬件可以被访问。而只需要公布这个 后门代码即可。一般情况下如果要将Android移植到其他硬件去运行，只需要实现这部分代码即可。包括：显示器驱动，声音，相机，GPS,GSM等等 Android运行环境该核心库提供了JAVA编程语言核心库的大多数功能。 每一个Android应用程序都在它自己的进程中运 行，都拥有一个独立的Dalvik虚拟 机实例。Dalvik被设计成一个设备可以同时高效地运行多个虚拟系统。 Dalvik虚拟机执行（.dex）的Dalvik可执行文件，该格式文件针对小内存使用做了 优化。同时虚拟机是基于寄存器的，所有的类都经由JAVA编译器编译，然后通过SDK中 的 “dx” 工具转化成.dex格式由虚拟机执行。 Linux内核(Linux Kernel)Android的核心系统服务依赖于Linux 2.6 内核，如安全性，内存管理，进程管理， 网络协议栈和驱动模型。 Linux 内核也同时作为硬件和软件栈之间的抽象层。其外还对其做了部分修改，主要涉及两部分修改： Binder (IPC)：提供有效的进程间通信，虽然linux内核本身已经提供了这些功能，但Android系统很多服务都需要用到该功能，为了某种原因其实现了自己的一套。 电源管理：主要是为了省电，毕竟是手持设备嘛，低耗电才是我们的追求。 配置 gradew和gradlew.bat：这两个文件是用来命令行界面中执行gradle命令的，其中gradlew是在Linux或Mac系统中使用的；gradlew.bat是在Windows系统中使用的。 HelloWorld.iml：iml文件是所有InteliJ IDEA项目都会自动生成的一个文件(Android Studio是基于InteliJ IDEA开发的)，用于标识这是一个InteliJ IDEA项目，我们不需要修改这个文件中的任何内容。 proguard-rules.pro：指定代码混淆规则。 Gradle是一个非常先进的项目构建工具，它使用了一种基于Groovy的领域特定语言（DSL）来声明项目设置，摒弃了传统基于XML（如Ant何Maven）的各种繁琐配置。 compileSdkVersion：用于指定项目的编译版本，指定的24表示使用Android7.0系统的SDK编译。 buildToolsVersion：用于指定项目构建工具的版本。 targetSdkVersion：指定的值表示你在该目标版本上已经做过了充分的测试，系统将会为你的应用程序启动一些最新的功能和特性。 更多隐式Intent的用法 随时随地退出程序]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Android开发艺术探索》读书笔记]]></title>
    <url>%2F2018%2F04%2F13%2F%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《Android开发艺术探索》 - 一本Android进阶类书籍，采用理论、源码和实践相结合的方式来阐述高水准的Android应用开发要点。 《Android开发艺术探索》从三个方面来组织内容。第一，介绍Android开发者不容易掌握的一些知识点；第二，结合Android源代码和应用层开发过程，融会贯通，介绍一些比较深入的知识点；第三，介绍一些核心技术和Android的性能优化思想。 《Android开发艺术探索》侧重于Android知识的体系化和系统工作机制的分析，通过《Android开发艺术探索》的学习可以极大地提高开发者的Android技术水平，从而更加高效地成为高级开发者。而对于高级开发者来说，仍然可以从《Android开发艺术探索》的知识体系中获益。 完善中，借鉴了他人的读书笔记。 Activity的生命周期和启动模式用户正常使用情况下的生命周期 &amp; 由于Activity被系统回收或者设备配置改变导致Activity被销毁重建情况下的生命周期。 Activity的生命周期全面分析典型情况下的生命周期分析 1.Activity第一次启动：onCreate-&gt;onStart-&gt;onResume。 2.Activity切换到后台（ 用户打开新的Activity或者切换到桌面）,onPause-&gt;onStop。 3.Activity从后台到前台，重新可见，onRestart-&gt;onStart-&gt;onResume。 4.用户退出Activity，onPause-&gt;onStop-&gt;onDestroy。 5.onStart开始到onStop之前，Activity可见。onResume到onPause之前，Activity可以接受用户交互。 6.在新Activity启动之前，栈顶的Activity需要先onPause后，新Activity才能启动。所以不能在onPause执行耗时操作。 异常情况下的生命周期分析系统配置变化导致Activity销毁重建例如Activity处于竖屏状态，如果突然旋转屏幕，由于系统配置发生了改变，Activity就会被销毁并重新创建。 在异常情况下系统会在onStop之前调用onSaveInstanceState来保存状态。Activity重新创建后，会在onStart之后调用onRestoreInstanceState来恢复之前保存的数据。 保存数据的流程： Activity被意外终止，调用onSaveIntanceState保存数据-&gt; Activity委托Window，Window委托它上面的顶级容器一个ViewGroup（ 书上说很可能就是DecorView） 。然后顶层容器在通知所有子元素来保存数据。 每个View都有 onSaveInstanceState 和 onRestoreInstanceState 方法。查看TextView 源码可以发现保存了文本选中状态和文本内容。 系统只在Activity异常终止的时候才会调用 onSaveInstanceState 和onRestoreInstanceState 方法。其他情况不会触发。 资源内存不足导致低优先级的Activity被回收 1.前台- 可见非前台（ 被对话框遮挡的Activity） -后台，这三种Activity优先级从高到低。 2.android:configChanges=”orientation” 在manifest中指定 configChanges 在系统配置变化后不重新创建Activity，也不会执行onSaveInstanceState 和 onRestoreInstanceState 方法，而是调用 onConfigurationChnaged 方法。 3.configChanges 一般常用三个选项： locale 系统语言变化 keyborardHidden 键盘的可访问性发生了变化，比如用户调出了键盘 orientation 屏幕方向变化 Activity的启动模式Activity的LaunchModeAndroid使用栈来管理Activity。 standard 每次启动都会重新创建一个实例，不管这个Activity在栈中是否已经存在。 谁启动了这个Activity，那么Activity就运行在启动它的那个Activity所在的栈中。 用Application去启动Activity时会报错，提示非Activity的Context没有所谓的任务栈。解决办法是为待启动Activity制定FLAG_ACTIVITY_NEW_TASH标志位，这样就会为它创建一个新的任务栈。 singleTop 如果新Activity位于任务栈的栈顶，那么此Activity不会被重新创建，同时回调 onNewIntent 方法。 如果新Activity已经存在但不是位于栈顶，那么新Activity仍然会被创建。 singleTask 这是一种单实例模式 只要Activity在栈中存在，那么多次启动这个Activity都不会重新创建实例，同时也会回调 onNewIntent 方法。 同时会导致在Activity之上的栈内Activity出栈。 singleIntance 具有singleTask模式的所有特性，同时具有此模式的Activity只能单独的位于一个任务栈中 TaskAffinity属性TaskAffinity参数标识了一个Activity所需要的任务栈的名字。为字符串，且中间必须包含包名分隔符“.”。默认情况下，所有Activity所需的任务栈名字为应用包名。TashAffinity属性主要和singleTask启动模式或者 allowTaskReparenting 属性配对使用，其他情况下没有意义。 应用A启动了应用B的某个Activity后，如果Activity的allowTaskReparenting属性为true的话，那么当应用B被启动后，此Activity会直接从应用A的任务栈转移到应用B的任务栈中。 打个比方就是，应用A启动了应用B的ActivityX，然后按Home回到桌面，单击应用B的图标，这时并不会启动B的主Activity，而是重新显示已经被应用A启动的ActivityX。这是因为ActivityX的TaskAffinity值肯定不和应用A的任务栈相同（ 因为包名不同） 。所以当应用B被启动以后，发现ActivityX原本所需的任务栈已经被创建了，所以把ActivityX从A的任务栈中转移过来了。 设置启动模式: 1.manifest中 设置下的 android:launchMode 属性。 2.启动Activity的 intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); 。 3.两种同时存在时，以第二种为准。第一种方式无法直接为Activity添加FLAG_ACTIVITY_CLEAR_TOP标识，第二种方式无法指定singleInstance模式。 4.可以通过命令行 adb shell dumpsys activity 命令查看栈中的Activity信息。 Activity的Flags这些FLAG可以设定启动模式、可以影响Activity的运行状态。 FLAG_ACTIVITY_CLEAR_TOP 具有此标记位的Activity启动时，同一个任务栈中位于它上面的Activity都要出栈，一般和FLAG_ACTIVITY_NEW_TASK配合使用。效果和singleTask一样。 FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS 如果设置，新的Activity不会在最近启动的Activity的列表(就是安卓手机里显示最近打开的Activity那个系统级的UI)中保存。 IntentFilter的匹配规则启动Activity分为两种： 1.显示调用 明确指定被启动对象的组件信息，包括包名和类名 2.隐式调用 不需要明确指定组件信息，需要Intent能够匹配目标组件中的IntentFilter中所设置的过滤信息。 3.IntentFilter中的过滤信息有action、category、data。 4.只有一个Intent同时匹配action类别、category类别、data类别才能成功启动目标Activity。 5.一个Activity可以有多个intent-filter，一个Intent只要能匹配任何一组intent-filter即可成功启动对应的Activity。 action 1.action是一个字符串。 2.一个intent-filter可以有多个aciton，只要Intent中的action能够和任何一个action相同即可成功匹配。匹配是指与action的字符串完全一样。 3.Intent中如果没有指定action，那么匹配失败。 category category是一个字符串。 2.Intent可以没有category，但是如果你一旦有category，不管有几个，每个都能够与intent-filter中的其中一个category相同。 3.系统在startActivity和startActivityForResult的时候，会默认为Intent加上 android.intent.category.DEFAULT 这个category，所以为了我们的activity能够接收隐式调用，就必须在intent-filter中加上 android.intent.category.DEFAULT 这个category。 data 1.data的匹配规则与action一样，如果intent-filter中定义了data，那么Intent中必须要定义可匹配的data。 2.intent-filter中data的语法： &lt;data android:scheme=&quot;string&quot; android:host=&quot;string&quot; android:port=&quot;string&quot; android:path=&quot;string&quot; android:pathPattern=&quot;string&quot; android:pathPrefix=&quot;string&quot; android:mimeType=&quot;string&quot;/&gt; 3.Intent中的data有两部分组成：mimeType和URI。mimeType是指媒体类型，比如image/jpeg、audio/mpeg4-generic和video/等，可以表示图片、文本、视频等不同的媒体格式。 URI的结构：&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern&gt;]//实际例子content://com.example.project:200/folder/subfolder/etchttp://www.baidu.com:80/search/info scheme：URI的模式，比如http、file、content等，默认值是 file 。 host：URI的主机名 port：URI的端口号 path、pathPattern和pathPrefix：这三个参数描述路径信息。 path、pathPattern可以表示完整的路径信息，其中pathPattern可以包含通配符 * ，表示0个或者多个任意字符。 pathPrefix只表示路径的前缀信息。 Intent指定data时，必须调用 setDataAndType 方法， setData 和 setType 会清除另一方的值。 隐式调用需注意: 1.当通过隐式调用启动Activity时，没找到对应的Activity系统就会抛出 android.content.ActivityNotFoundException 异常，所以需要判断是否有Activity能够匹配我们的隐式Intent。 i. 采用 PackageManager 的 resloveActivity 方法public abstract List queryIntentActivityies(Intent intent,int flags);public abstract ResolveInfo resloveActivity(Intent intent,int flags);以上的第二个参数使用 MATCH_DEFAULT_ONLY ，这个标志位的含义是仅仅匹配那些在intent-filter中声明了 android.intent.category.DEFAULT 这个category的Activity。因为如果把不含这个category的Activity匹配出来了，由于不含DEFAULT这个category的Activity是无法接受隐式Intent的从而导致startActivity失败。 ii. 采用 Intent 的 resloveActivity 方法 2.下面的action和category用来表明这是一个入口Activity并且会出现在系统的应用列表中，二者缺一不可。 View的事件体系view的基础知识什么是viewView是Android中所有控件的基类，View的本身可以是单个空间，也可以是多个控件组成的一组控件，即ViewGroup，ViewGroup继承自View，其内部可以有子View，这样就形成了View树的结构。 View的位置参数View的位置主要由它的四个顶点来决定，即它的四个属性：top、left、right、bottom，分别表示View左上角的坐标点（top，left）以及右下角的坐标点（right，bottom）。同时，我们可以得到View的大小：12width = right - leftheight = bottom - top 而这四个参数可以由以下方式获取： Left = getLeft(); Right = getRight(); Top = getTop(); Bottom = getBottom();Android3.0后，View增加了x、y、translationX和translationY这几个参数。其中x和y是View左上角的坐标，而translationX和translationY是View左上角相对于容器的偏移量。 他们之间的换算关系如下：x = left + translationX;y = top + translationY;注意：View在平移的过程中，top和left不会改变，改变的是x、y、translationX和translaY。 MotionEvent和TouchSlopMotionEvent在手指接触到屏幕后会产生乙烯类的点击事件，如 点击屏幕后离开松开，事件序列为DOWN-&gt;UP 点击屏幕滑动一会再松开，事件序列为DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP 通过MotionEven对象我们可以得到事件发生的x和y坐标，我们可以通过getX/getY和getRawX/getRawY得到，它们的区别是：getX/getY返回的是相对于当前View左上角的x和y坐标，getRawX/getRawY返回的是相对于手机屏幕左上角的x和y坐标。 TouchSloupTouchSloup是系统所能识别出的被认为是滑动的最小距离，这是一个常量，与设备有关，可通过以下方法获得：1ViewConfiguration.get(getContext()).getScaledTouchSloup(). VelocityTracker、GestureDetector和ScrollerVelocityTracker速度追踪，用于追踪手指在滑动过程中的速度，包括水平放向速度和竖直方向速度。 使用方法：1.在View的onTouchEvent方法中追踪当前单击事件的速度12VelocityRracker velocityTracker = VelocityTracker.obtain();velocityTracker.addMovement(event); 2.计算速度，获得水平速度和竖直速度123velocityTracker.computeCurrentVelocity(1000);int xVelocity = (int)velocityTracker.getXVelocity();int yVelocity = (int)velocityTracker.getYVelocity(); 注意，获取速度之前必须先计算速度，即调用computeCurrentVelocity方法，这里指的速度是指一段时间内手指滑过的像素数，1000指的是1000毫秒，得到的是1000毫秒内滑过的像素数。速度可正可负：1速度 = （终点位置 - 起点位置） / 时间段 3.最后，当不需要使用的时候，需要调用clear()方法重置并回收内存：12velocityTracker.clear();velocityTracker.recycle(); GestureDetector手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。 使用方法：1.创建一个GestureDetector对象并实现OnGestureListener接口，根据需要，也可实现OnDoubleTapListener接口从而监听双击行为：123GestureDetector mGestureDetector = new GestureDetector(this);//解决长按屏幕后无法拖动的现象mGestureDetector.setIsLongpressEnabled(false); 2.在目标View的OnTouchEvent方法中添加以下实现：12boolean consume = mGestureDetector.onTouchEvent(event);return consume; 3.实现OnGestureListener和OnDoubleTapListener接口中的方法，其中常用的方法有：onSingleTapUp(单击)、onFling(快速滑动)、onScroll(拖动)、onLongPress(长按)和onDoubleTap（双击）。 建议：如果只是监听滑动相关的，可以自己在onTouchEvent中实现，如果要监听双击这种行为，那么就使用GestureDetector。 Scroller弹性滑动对象，用于实现View的弹性滑动。其本身无法让View他行滑动，需要和View的computeScroll方法配合使用才能完成这个功能。 使用方法：12345678910111213141516Scroller scroller = new Scroller(mContext);//缓慢移动到指定位置private void smoothScrollTo(int destX,int destY)&#123; int scrollX = getScrollX(); int delta = destX - scrollX; //1000ms内滑向destX,效果就是慢慢滑动 mScroller.startScroll(scrollX,0,delta,0,1000); invalidata();&#125;@Overridepublic void computeScroll()&#123; if(mScroller.computeScrollOffset())&#123; scrollTo(mScroller.getCurrX,mScroller.getCurrY()); postInvalidate(); &#125;&#125; 原理下节讲。 View的滑动使用scrollTo/scrollBy1.scrollBy实际调用了scrollTo，它实现了基于当前位置的相对滑动，而scrollTo则实现了绝对滑动。2.scrollTo和scrollBy只能改变View的内容位置而不能改变View在布局中的位置。3.滑动偏移量mScrollX和mScrollY的正负与实际滑动方向相反，即从左向右滑动，mScrollX为负值，从上往下滑动mScrollY为负值。 使用动画使用动画移动View，主要是操作View的translationX和translationY属性，既可以采用传统的View动画，也可以采用属性动画，如果使用属性动画，为了能够兼容3.0以下的版本，需要采用开源动画库nineolddandroids。 如使用属性动画：(View在100ms内向右移动100像素)1ObjectAnimator.ofFloat(targetView,"translationX"0,100).setDuration(100).start(); 改变布局属性通过改变布局属性来移动View，即改变LayoutParams。 各种滑动方式的对比1.scrollTo/scrollBy：操作简单，适合对View内容的滑动；2.动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果；3.改变布局参数：操作稍微复杂，适用于有交互的View。 弹性滑动使用Scroller使用Scroller实现弹性滑动的典型使用方法如下：12345678910111213141516Scroller scroller = new Scroller(mContext);//缓慢移动到指定位置private void smoothScrollTo(int destX,int dextY)&#123; int scrollX = getScrollX(); int deltaX = destX - scrollX; //1000ms内滑向destX，效果就是缓慢滑动 mScroller.startSscroll(scrollX,0,deltaX,0,1000); invalidate();&#125;@overridepublic void computeScroll()&#123; if(mScroller.computeScrollOffset())&#123; scrollTo(mScroller.getCurrX(),mScroller.getCurrY()); postInvalidate(); &#125;&#125; 从上面代码可以知道，我们首先会构造一个Scroller对象，并调用他的startScroll方法，该方法并没有让view实现滑动，只是把参数保存下来，我们来看看startScroll方法的实现就知道了：12345678910111213public void startScroll(int startX,int startY,int dx,int dy,int duration)&#123; mMode = SCROLL_MODE; mFinished = false; mDuration = duration; mStartTime = AnimationUtils.currentAminationTimeMills(); mStartX = startX; mStartY = startY; mFinalX = startX + dx; mFinalY = startY + dy; mDeltaX = dx; mDeltaY = dy; mDurationReciprocal = 1.0f / (float)mDuration;&#125; 可以知道，startScroll方法的几个参数的含义，startX和startY表示滑动的起点，dx和dy表示的是滑动的距离，而duration表示的是滑动时间，注意，这里的滑动指的是View内容的滑动，在startScroll方法被调用后，马上调用invalidate方法，这是滑动的开始，invalidate方法会导致View的重绘，在View的draw方法中调用computeScroll方法，computeScroll又会去向Scroller获取当前的scrollX和scrollY；然后通过scrollTo方法实现滑动，接着又调用postInvalidate方法进行第二次重绘，一直循环，知道computeScrollOffset()方法返回值为false才结束整个滑动过程。 我们可以看看computeScrollOffset方法是如何获得当前的scrollX和scrollY的： 123456789101112131415public boolean computeScrollOffset()&#123; ... int timePassed = (int)(AnimationUtils.currentAnimationTimeMills() - mStartTime); if(timePassed &lt; mDuration)&#123; switch(mMode)&#123; case SCROLL_MODE: final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal); mCurrX = mStartX + Math.round(x * mDeltaX); mCurrY = mStartY + Math.round(y * mDeltaY); break; ... &#125; &#125; return true;&#125; 到这里我们就基本明白了，computeScroll向Scroller获取当前的scrollX和scrollY其实是通过计算时间流逝的百分比来获得的，每一次重绘距滑动起始时间会有一个时间间距，通过这个时间间距Scroller就可以得到View当前的滑动位置，然后就可以通过scrollTo方法来完成View的滑动了。 通过动画动画本身就是一种渐近的过程，因此通过动画来实现的滑动本身就具有弹性。实现也很简单：1ObjectAnimator.ofFloat(targetView,"translationX"0,100).setDuration(100).start(); 当然，我们也可以利用动画来模仿Scroller实现View弹性滑动的过程：1234567891011final int startX = 0;final int deltaX = 100;ValueAnimator animator = ValueAnimator.ofInt(0,1).setDuration(1000);animator.addUpdateListener(new AnimatorUpdateListener()&#123; @override public void onAnimationUpdate(ValueAnimator animator)&#123; float fraction = animator.getAnimatedFraction(); mButton1.scrollTo(startX + (int) (deltaX * fraction) , 0); &#125;&#125;);animator.start(); 上面的动画本质上是没有作用于任何对象上的，他只是在1000ms内完成了整个动画过程，利用这个特性，我们就可以在动画的每一帧到来时获取动画完成的比例，根据比例计算出View所滑动的距离。 使用延时策略延时策略的核心思想是通过发送一系列延时信息从而达到一种渐近式的效果，具体可以通过Hander和View的postDelayed方法，也可以使用线程的sleep方法。下面以Handler为例：1234567891011121314151617181920212223private static final int MESSAGE_SCROLL_TO = 1;private static final int FRAME_COUNT = 30;private static final int DELATED_TIME = 33;private int mCount = 0;@suppressLint("HandlerLeak")private Handler handler = new handler()&#123; public void handleMessage(Message msg)&#123; switch(msg.what)&#123; case MESSAGE_SCROLL_TO: mCount ++ ; if (mCount &lt;= FRAME_COUNT)&#123; float fraction = mCount / (float) FRAME_COUNT; int scrollX = (int) (fraction * 100); mButton1.scrollTo(scrollX,0); mHandelr.sendEmptyMessageDelayed(MESSAGE_SCROLL_TO , DELAYED_TIME); &#125; break; default : break; &#125; &#125;&#125; View的事件分发机制点击事件的传递规则首先我们先看看下面一段伪代码，通过它我们可以理解到点击事件的传递规则：123456789public boolean dispatchTouchEvent (MotionEvent ev)&#123; boolean consume = false; if (onInterceptTouchEvnet(ev)&#123; consume = onTouchEvent(ev); &#125; else &#123; consume = child.dispatchTouchEnvet(ev); &#125; return consume;&#125; 上面代码主要涉及到以下三个方法： public boolean dispatchTouchEvent(MotionEvent ev); 这个方法用来进行事件的分发 public boolean onInterceptTouchEvent(MotionEvent ev); 这个方法用来判断是否拦截事件 public boolean onTouchEvent(MotionEvent ev); 这个方法用来处理点击事件 下面理一理点击事件的传递规则：对于一个根ViewGroup，点击事件产生后，首先会传递给他，这时候就会调用他的onDispatchTouchEvent方法，如果Viewgroup的onInterceptTouchEvent方法返回true表示他要拦截事件，接下来事件就会交给ViewGroup处理，调用ViewGroup的onTouchEvent方法；如果ViewGroup的onInteceptTouchEvent方法返回值为false，表示ViewGroup不拦截该事件，这时事件就传递给他的子View，接下来子View的dispatchTouchEvent方法，如此反复直到事件被最终处理。 当一个View需要处理事件时，如果它设置了OnTouchListener，那么onTouch方法会被调用，如果onTouch返回false，则当前View的onTouchEvent方法会被调用，返回true则不会被调用，同时，在onTouchEvent方法中如果设置了OnClickListener，那么他的onClick方法会被调用。由此可见处理事件时的优先级关系：onTouchListener &gt; onTouchEvent &gt; onClickListener 关于事件传递的机制，这里给出一些结论： 一个事件系列以down事件开始，中间包含数量不定的move事件，最终以up事件结束。 正常情况下，一个事件序列只能由一个View拦截并消耗。 某个View拦截了事件后，该事件序列只能由它去处理，并且它的onInterceptTouchEvent不会再被调用。 某个View一旦开始处理事件，如果它不消耗ACTION_DOWN事件（onTouchEvnet返回false），那么同一事件序列中的其他事件都不会交给他处理，并且事件将重新交由他的父元素去处理，即父元素的onTouchEvent被调用。 如果View不消耗ACTION_DOWN以外的其他事件，那么这个事件将会消失，此时父元素的onTouchEvent并不会被调用，并且当前View可以持续收到后续的事件，最终消失的点击事件会传递给Activity去处理。 ViewGroup默认不拦截任何事件。 View没有onInterceptTouchEvent方法，一旦事件传递给它，它的onTouchEvent方法会被View的事件体系调用。 View的onTouchEvent默认消耗事件，除非他是不可点击的（clickable和longClickable同时为false）。 View的enable不影响onTouchEvent的默认返回值。 onClick会发生的前提是当前View是可点击的，并且收到了down和up事件。 事件传递过程总是由外向内的，即事件总是先传递给父元素，然后由父元素分发给子View，通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的分发过程，但是ACTION_DOWN事件除外。 View的滑动冲突在界面中，只要内外两层同时可以滑动，这个时候就会产生滑动冲突。 常见的滑动冲突场景 外部滑动和内部滑动方向不一致； 外部滑动方向和内部滑动方向一致； 上面两种情况的嵌套。 滑动冲突的处理规则 对于场景一，处理的规则是：当用户左右（上下）滑动时，需要让外部的View拦截点击事件，当用户上下（左右）滑动的时候，需要让内部的View拦截点击事件。根据滑动的方向判断谁来拦截事件。 对于场景二，由于滑动方向一致，这时候只能在业务上找到突破点，根据业务需求，规定什么时候让外部View拦截事件，什么时候由内部View拦截事件。 场景三的情况相对比较复杂，同样根据需求在业务上找到突破点。 滑动冲突的解决方式 外部拦截法：所谓的外部拦截法是指点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截。下面是伪代码：1234567891011121314151617181920212223public boolean onInterceptTouchEvent (MotionEvent event)&#123; boolean intercepted = false; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()) &#123; case MotionEvent.ACTION_DOWN: intercepted = false; break; case MotionEvent.ACTION_MOVE: if (父容器需要当前事件） &#123; intercepted = true; &#125; else &#123; intercepted = flase; &#125; break; case MotionEvent.ACTION_UP: intercepted = false; break; default : break;&#125;mLastXIntercept = x;mLastYIntercept = y;return intercepted; 内部拦截法：内部拦截法是指父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗，否则就交由父容器进行处理。这种方法与Android事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。下面是伪代码：12345678910111213141516171819202122public boolean dispatchTouchEvent ( MotionEvent event ) &#123; int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction) &#123; case MotionEvent.ACTION_DOWN: parent.requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if (父容器需要此类点击事件) &#123; parent.requestDisallowInterceptTouchEvent(false); &#125; break; case MotionEvent.ACTION_UP: break; default : break; &#125; mLastX = x; mLastY = y; return super.dispatchTouchEvent(event);&#125; 除了子元素需要做处理外，父元素也要默认拦截除了ACTION_DOWN以外的其他事件，这样当子元素调用parent.requestDisallowInterceptTouchEvent(false)方法时，父元素才能继续拦截所需的事件。因此，父元素要做以下修改：12345678public boolean onInterceptTouchEvent (MotionEvent event) &#123; int action = event.getAction(); if(action == MotionEvent.ACTION_DOWN) &#123; return false; &#125; else &#123; return true; &#125;&#125; 至于具体的实现可以根据实际需要去修改拦截成立的条件，开发艺术艺术中也给出了实例，具体可参考书中P161-P173。 理解RemoteViewsRemoteViews提供了一组基础的操作，用于跨进程更新它的界面。RemoteViews在Andriod中的使用场景有两种：通知栏和桌面小部件(都运行在SystemServer进程)。 RemoteViews的应用通知栏主要通过NotificationManager的notify方法来实现，除了默认效果外还可以自定义布局。桌面小工具主要通过AppWidgetProvider来实现，AppWidgetProvider本质上是一个广播。两者都会用到RemoteViews，两者都运行在其他进程中，准确的说是系统的SystemServer进程。 RemoteViews在通知栏上的应用关于PendingIntent，它表示的是一种特定的Intent，这个Intent中所包含的意图必须由用户来触发。 RemoteViews在桌面小部件上的应用AppWidgetProvider实现桌面小工具的类，本质是一个广播即BroadcastReceiver。具体使用看系统自动生成的桌面小工具。桌面小部件上不管是初始化界面还是后续的更新界面都必须使用RemoteViews来完成。 PendingIntent概述PendingIntent和Intent的区别在于，PendingIntent是在将来的某个环节的不确定的时刻发生，而Intent是立刻发生。 RemoteViews的内部机制 大部分的set方法的确是通过发射来完成的。 NotificationManager和AppWidgetProvider通过Binder分别和SystemServer进程中的NotificationManagerService以及AppWidgetServer进行通信。 RemoteViews会通过Binder传递到SystemServer进程中，这是因为RemoteViews实现了Parcelable接口，因此它可以跨进程传输，系统会根据RemoteViews中的包名等信息去得到该应用的资源。 RemoteViews的意义模拟通知栏效果实现跨进程跨进程的UI更新。我们可以像系统一样使用Binder来实现，但是为了简单起见就采用广播。实际： 现在用两个应用，一个应用需要能够更新另一个应用的某个界面，这个时候我们当然可以选择AIDL去实现（跨应用更新UI），但是如果对界面的更新比较频繁，这个时候就会有效率的问题，如果采用RemoteViews来实现就没有这个问题了。（RemoteViews只支持一些常用的View,对于自定义的View是不支持的。） Android动画深入分析Android动画分为三种： 1.View动画（平移、缩放、旋转、透明度） 2.帧动画（图片切换动画） 3.属性动画（动态的改变对象的属性从而达到动画的效果） View动画View动画的作用对象是View，支持四种动画效果： 1.平移 2.缩放 3.旋转 4.透明 View动画的种类上述四种变换效果对应着Animation四个子类： TranslateAnimation 、 ScaleAnimation 、 RotateAnimation 和 AlphaAnimation 。这四种动画皆可以通过XML定义，也可以通过代码来动态创建。 xml定义动画: 1. 标签表示动画集合，对应AnimationSet类，可以包含一个或若干个动画，内部还可以嵌套其他动画集合。两个属性： i. android:interpolator 表示动画集合所采用的插值器，插值器影响动画速度，比如非匀速动画就需要通过插值器来控制动画的播放过程。 ii. android:shareInterpolator 表示集合中的动画是否和集合共享同一个插值器，如果集合不指定插值器，那么子动画就需要单独指定所需的插值器或默认值。 2.&lt;translate&gt;、&lt;scale&gt;、&lt;rotate&gt;、&lt;alpha&gt;这几个子标签分别代表四种变换效果。 3.定义完View动画的xml后，通过以下代码应用动画： 12Aniamation anim = AnimationUtils.loadAnimation(context,R.anim.animation_test);view.startAnimation(anim); 代码动态创建动画： 123AlphaAnimation alphaAnimation = new AlphaAnimation(0,1);alphaAnimation.setDuration(1500);view.startAnimation(alphaAnimation); 自定义View动画需要继承 Animation 这个抽象类，重写它的 initialize 和 applyTransformation 方法。在 initialize 方法中做一些初始化工作，在 applyTransformation 中进行相应的矩阵变换即可，很多时候需要采用 Camera 来简化矩阵变换的过程。自定义View动画的过程主要是矩阵变换的过程。 帧动画帧动画是顺序播放一组预先定义好的图片，使用简单，但容易引起OOM，所以在使用帧动画时应尽量避免使用过多尺寸较大的图片。 View动画的特殊使用场景LayoutAnimation作用于ViewGroup，为ViewGroup指定一个动画，当它的子元素出场时都会具有这种动画效果，一般用在ListView上。 Activity的切换效果我们可以自定义Activity的切换效果，主要通过在 startActivity 或者 finish 的后面增加overridePendingTransition(int enterAnim , int exitAnim)方法 属性动画API 11后加入，可以在一个时间间隔内完成对象从一个属性值到另一个属性值的改变。因此与View动画相比，属性动画几乎无所不能，只要对象有这个属性，它都能实现动画效果。API11以下可以通过 nineoldandroids 库来兼容以前版本。 属性动画有以下三种使用方法： ObjectAnimator: ObjectAnimator.ofFloat(view,&quot;translationY&quot;,values).start(); ValueAnimator 123456ValueAnimator colorAnim = ObjectAnimator.ofInt(view,"backgroundColor",/*red*/0xffff8080,/*blue*/0xff8080ff);colorAnim.setDuration(2000);colorAnim.setEvaluator(new ArgbEvaluator());colorAnim.setRepeatCount(ValueAnimator.INFINITE);colorAnim.setRepeatMode(ValueAnimator.REVERSE);colorAnim.start(); AnimatorSet 123AnimatorSet set = new AnimatorSet();set.playTogether(animator1,animator2,animator3);set.setDuration(3*1000).start(); 也可以通过在xml中定义在 res/animator/ 目录下。具体如下: 1234567&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;set xmlns:android="http://schemas.android.com/apk/res/android"&gt;&lt;objectAnimator....../&gt;&lt;animator....../&gt;&lt;/set&gt; 12345AnimatorSet set = (AnimatorSet)AnimatorInflater.loadAnimator(context , R.animator.anim);set.setTarget(view);set.start();&lt;set&gt; 标签对应 AnimatorSet,&lt;animator&gt;对应ValueAnimator,而&lt;objectAnimator&gt;则对应 ObjectAnimator。 理解差值器和估值器 时间插值器（ TimeInterpolator） 的作用是根据时间流逝的百分比来计算出当前属性值改变的百分比，系统预置的有LinearInterpolator（线性插值器：匀速动画),AccelerateDecelerateInterpolator（加速减速插值器：动画两头慢中间快）,DecelerateInterpolator(减速插值器：动画越来越慢）。 估值器（ TypeEvaluator） 的作用是根据当前属性改变的百分比来计算改变后的属性值。系统预置有IntEvaluator 、FloatEvaluator 、ArgbEvaluator。 具体来说 对于一个作用在view上改变其宽度属性、持续40ms的属性动画来说，就是当时间t=20ms时，时间流逝了50%，那么view的宽度属性应该改变了多少呢？这个就由Interpolator和Evaluator的算法来决定。 属性动画的监听器123456public static interface AnimatorListener &#123; void onAnimationStart(Animator animation); //动画开始 void onAnimationEnd(Animator animation); //动画结束 void onAnimationCancel(Animator animation); //动画取消 void onAnimationRepeat(Animator animation); //动画重复播放&#125; 为了方便开发，系统提供了AnimatorListenerAdapter类，它是AnimatorListener的适配器类，可以有选择的实现以上4个方法。1234567891011121314/*** Implementors of this interface can add themselves as update listeners* to an &lt;code&gt;ValueAnimator&lt;/code&gt; instance to receive callbacks on every animation* frame, after the current frame's values have been calculated for that* &lt;code&gt;ValueAnimator&lt;/code&gt;.*/public static interface AnimatorUpdateListener &#123; /** * &lt;p&gt;Notifies the occurrence of another frame of the animation.&lt;/p&gt; * * @param animation The animation which was repeated. */ void onAnimationUpdate(ValueAnimator animation);&#125; AnimatorUpdateListener会监听整个动画的过程，动画由许多帧组成的，每播放一帧，onAnimationUpdate就会调用一次。 对任意属性做动画 1.属性动画要求作用的对象提供该属性的get和set方法，属性动画根据外界传递的该属性的初始值和最终值，通过多次调用set方法来实现动画效果。 2.如果被作用的对象没有set/get方法，可以： i.请给你的对象加上get和set方法，如果你有权限的话（ 对于SDK或者其他第三方类库的类无法加上的） ii.用一个类来包装原始对象，间接为其提供get和set方法 1234567891011121314151617//包装View类 用于给属性动画调用 从而包装了set getpublic class ViewWrapper &#123; private View target; public ViewWrapper(View target) &#123; this.target = target; &#125; public int getWidth() &#123; return target.getLayoutParams().width; &#125; public void setWidth(int width) &#123; target.getLayoutParams().width = width; target.requestLayout(); &#125;&#125; //使用：ViewWrapper wrapper = new ViewWrapper(mButton);ObjectAnimator.ofInt(mButton,"width",500).setDuration(3000).start(); iii.采用ValueAnimator，监听动画过程，自己实现属性的改变； 12345678910111213141516171819private void performAnimate(final View target, final int start, final int end) &#123; ValueAnimator valueAnimator = ValueAnimator.ofInt(1, 100); valueAnimator.addUpdateListener(new AnimatorUpdateListener() &#123; // 持有一个IntEvaluator对象，方便下面估值的时候使用 private IntEvaluator mEvaluator = new IntEvaluator(); @Override public void onAnimationUpdate(ValueAnimator animator) &#123; // 获得当前动画的进度值，整型，1-100之间 int currentValue = (Integer) animator.getAnimatedValue(); Log.d(TAG, "current value: " + currentValue); // 获得当前进度占整个动画过程的比例，浮点型，0-1之间 float fraction = animator.getAnimatedFraction(); // 直接调用整型估值器通过比例计算出宽度，然后再设给Button target.getLayoutParams().width = mEvaluator.evaluate(fraction, start, end); target.requestLayout(); &#125; &#125;); valueAnimator.setDuration(5000).start();&#125; 属性动画的工作原理属性动画需要运行在有Looper的线程中，系统通过反射调用被作用对象get/set方法。 使用动画的注意事项 1.使用帧动画时，当图片数量较多且图片分辨率较大的时候容易出现OOM，需注意，尽量避免使用帧动画。 2.使用无限循环的属性动画时，在Activity退出时即使停止，否则将导致Activity无法释放从而造成内存泄露。 3.动画在3.0以下的系统存在兼容性问题，特殊场景可能无法正常工作，需做好适配工作。 4.View动画是对View的影像做动画，并不是真正的改变了View的状态，因此有时候会出现动画完成后View无法隐藏（ setVisibility(View.GONE） 失效）,这时候调用 view.clearAnimation() 清理View动画即可解决。 5.不要使用px，使用px会导致不同设备上有不同的效果。 6.View动画是对View的影像做动画，View的真实位置没有变动，动画完成后的新位置是无法触发点击事件的。属性动画是真实改变了View的属性，所以动画完成后的位置可以接受触摸事件。 7.使用动画的过程中，使用硬件加速可以提高动画的流畅度。 Android的线程和线程池 1.在Android系统，线程主要分为主线程和子线程，主线程处理和界面相关的事情，而子线程一般用于执行耗时操作。 2.在Android中，线程的形态有很多种： i.AsyncTask封装了线程池和Handler。 ii.HandlerThread是具有消息循环的线程，内部可以使用handler iii.IntentService是一种Service，内部采用HandlerThread来执行任务，当任务执行完毕后IntentService会自动退出。由于它是一种Service，所以不容易被系统杀死 3.操作系统中，线程是操作系统调度的最小单元，同时线程又是一种受限的系统资源，其创建和销毁都会有相应的开销。同时当系统存在大量线程时，系统会通过时间片轮转的方式调度每个线程，因此线程不可能做到绝对的并发，除非线程数量小于等于CPU的核心数。 4.频繁创建销毁线程不明智，使用线程池是正确的做法。线程池会缓存一定数量的线程，通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销。 主线程和子线程 1.主线程主要处理界面交互逻辑，由于用户随时会和界面交互，所以主线程在任何时候都需要有较高响应速度，则不能执行耗时的任务； 2.android3.0开始，网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作所阻塞从而现ANR现象。 Android中的线程形态AsyncTask1.三个参数（都可为Void)： i. Params：参数 ii. Progress：执行进度 iii. Result：返回值 2.四个方法 ： i. onPreExecute() 主线程执行，异步方法执行前调用。 ii. doInBackground(Params…params) 线程池中执行，用于执行异步任务；在方法内部用publishProgress 来更新任务进度。 iii. onProgressUpdate(Progress…value) 主线程执行，后台任务进度状态改变时被调用。 iv. onPostExecute(Result result) 主线程执行，异步任务执行之后被调用执行顺序： onPreExecute-&gt;doInBackground-&gt;onPostExecute 如果取消了异步任务，会回调onCancelled()，onPostExecute则不会被调用。 AsyncTask的类必须在主线程加载，Android4.1及以上已经被系统自动完成了；AsyncTask对象必须在主线程创建；execute方法需要在UI线程调用；一个AsyncTask对象只能调用一次；Android1.6之前串行执行，Android1.6采用线程池并行处理任务，Android3.0开始，又采用一个线程来串行执行任务，但也可以通过 executeOnExecutor() 方法来并行执行任务。 AsyncTask的工作原理 1.AsyncTask中有两个线程池（ SerialExecutor 和 THREAD_POOL_EXECUTOR ）和一个 InternalHandler ，其中线程池SerialExecutor用于任务排队，THREAD_POOL_EXECUTOR用于真正执行任务，InternalHandler用于将执行环境切换到主线程。 2.AsyncTask的排队过程：系统首先会把AsyncTask的Params参数封装成FutureTask对象，它充当Runnable的作用，接下来这个FutureTask会交给SerialExecutor的 execute() 方法处理，execute()方法首先会把FutereTask对象插入到任务队列 mTasks 中去；如果没有正在活动的AsyncTask任务，就会执行下一个AsyncTask任务；同时当一个AsyncTask任务执行完成后，AsyncTask会继续执行其他任务直到所有任务都执行为止，可以看出默认情况，AsyncTask是串行执行的（Android3.0后）。 HandlerThread 1.HandlerThread继承了Thread,是一种可以使用Handler的Thread 2.在run方法中通过 looper.prepare() 来开启消息循环，这样就可以在HandlerThread中创建Handler了 3.外界可以通过一个Handler的消息方式来通知HandlerThread来执行具体任务；确定不使用之后，可以通过 quit 或 quitSafely 方法来终止线程执行 4.具体使用场景是IntentService IntentServiceIntentSercie是一种特殊的Service，继承了Service并且是抽象类，任务执行完成后会自动停止，优先级远高于普通线程，适合执行一些高优先级的后台任务； IntentService封装了 HandlerThread 和 Handler。 1.onCreate 方法自动创建一个HandlerThread 2.然后用它的Looper构造了一个Handler对象 mServiceHandler ，这样通过mServiceHandlerAndroid的线程和线程池发送的消息都会在HandlerThread执行； 3.IntentServiced的 onHandlerIntent 方法是一个抽象方法，需要在子类实现，onHandlerIntent方法执行后，stopSelt(int startId)就会停止服务，如果存在多个后台任务，执行完最后一个stopSelf(int startId)才会停止服务。 Android线程池优点： 重用线程池的线程，减少线程创建和销毁带来的性能开销 控制线程池的最大并发数，避免大量线程互相抢系统资源导致阻塞 提供定时执行和间隔循环执行功能 ThreadPoolExecutor（熟悉后可自定义线程池）Executor是一个接口，线程池的具体实现在ThreadPoolExecutor；它提供了一系列的参数来配置线程池；Android的线程池 大部分都是通 过Executor提供的工厂方法创建的。 ThreadPoolExecutor常见构造参数 corePoolSize： 线程池的核心线程数，默认情况下，核心线程会一直存活(设置了超时机制除外， allowCoreThreadTimeOut属性为true时开启） maxinmumPoolSize： 线程池能容纳的最大线程数，当活动的线程达到这个数值之后，后续新任务会被阻塞 keepAliveTime： 非核心线程闲置的超时时长，超过这个时长，非核心线程就会被回收,当allowCoreThreadTimeOut为true时，keepAliveTime同样作用于核心线程。 unit：keepAliveTime的时间单位，这是一个枚举，常用TimeUnit.MILLISECONDS(毫秒)、TimeUnit.SECONDS（秒）、TimeUnit.MINUTES(分钟) workQueue： 线程池中的任务队列，通过execute方法提交的Runnable对象会存储在这个参数中 threadFactory： 线程工厂，为线程池提供创建线程的功能，是个接口，提供ThreadnewThread(Runnable r)方法 RejectedExecutionHandle：当线程池无法执行新任务时，可能由于线程队列已满或无法成功执行任务，这时候 ThreadPoolExecutor会调用handler的 rejectedExecution的方法，默认会抛出RejectedExecutionException ThreadPoolExecutor执行任务大致遵循如下规则: 如果线程池中的线程数量未达到核心线程的数量，那么会直接启动一个核心线程来执行任务Android的线程和线程池 如果线程池中的线程数量已经达到或超过核心线程数量，那么任务会被插入到任务队列中排队等待执行 如果步骤2中无法将任务插入到任务队列中，往往是因为任务队列已满，这个时候如果线程数量未达到线程池规定的最大值，那么会立刻启动一个非核心线程来执行任务 如果步骤3中线程数量达到线程池规定的最大值，线程池会拒绝执行任务，并会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者 AsyncTask的THREAD_POOL_EXECUTOR线程池配置: 核心线程数等于CPU核心数+1 线程池最大线程数为CPU核心数的2倍+1 核心线程无超时机制，非核心线程的闲置超时时间为1秒 任务队列容量是128 常见的4个线程池 1、FixedThreadPool ：线程数量固定的线程池，当所有线程都处于活动状态时，新任务会处于等待状态，只有核心线程并且不会回收（无超时机制），能快速的响应外界请求。 2、CachedThreadPool ：线程数量不定的线程池，最大线程数Integer.MAX_VALUE(相当于任意大),当所有线程都处于活动状态时，会创建新线程来处理任务；线程池的空闲进程超时时长为60秒，超过就会被回收；任何任务都会被立即执行，适合执行大量的耗时较少的任务。 3、ScheduledThreadPool ：核心线程数量固定，非核心线程数量无限制，非核心线程闲置时会被立刻回收，用于执行定时任务和具有固定周期的重复任务。 4、SingleThreadExecutor ：只有一个核心线程，所有任务都在这个线程中串行执行，不需要处理线程同步问题。 相关资料 Android开发艺术探索，脑图笔记]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Android群英传 神兵利器》读书笔记]]></title>
    <url>%2F2018%2F02%2F04%2F%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0-%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《Android群英传 神兵利器》 - Android开发的工具使用 这是一本Android开发的工具书，里面的提到的工具基本上是每个Android开发者必备的技能，买这本书的起因是看到有介绍Gradle和性能优化。里面提到的很多工具之前都是用过，所以看得很快，只care自己不熟知的，所以这篇读书笔记是对自己不熟的地方的整理和摘录。 与Gradle的爱恨情仇配置全局参数 配置后就可以统一管理com.android.support:design版本号了 1234567891011根目录的build.gradle中ext &#123; // Support library and architecture components support minSdk 19 and above. minSdkVersion = 19 targetSdkVersion = 26 compileSdkVersion = 26 buildToolsVersion = '26.0.2' // App dependencies supportLibraryVersion = '27.0.2'&#125; 使用： 1234567defaultConfig &#123; applicationId "com.example.jingbin.cloudreader" minSdkVersion rootProject.ext.minSdkVersion targetSdkVersion rootProject.ext.targetSdkVersion &#125; compile "com.android.support:design:$rootProject.supportLibraryVersion" 构建defaultConfig1234567defaultConfig&#123; versionName getCustomVersionName();&#125;// build.gradle定义方法：def getCustomVersionName&#123; ......&#125; 构建buildTypes123456buildTypes&#123; // xys.initWith(buildTypes.debug) 也可以继承其他的构建类型 xys&#123; applicationIdSuffix ".xys" &#125;&#125; gradle assembleDebug / assembleRelease / assembleXys 生成另一个包，在包名后加上”.xys”，这样就可以双开了，不用手动更改包名！ 关于签名签名文件保存在住module的根目录下。系统有一个默认的debug签名 Android Studio中签名文件是“.jks”文件Eclipse中签名文件是”.keystore”文件 配置签名： 12345signingConfigs&#123; xys&#123; ... &#125;&#125; 可选配置12345CompileOptions : 配置编译的选项 JDK// 使用lint检查代码时错误的话停止，加上这个之后就会继续，但是一般不启动lint，因为启动后会编译很慢lintOptions&#123; abortOnError false&#125; 构建Proguard 混淆 混淆能精简代码、资源、优化代码 12345678910111213buildTypes &#123; release &#123; // 混淆 minifyEnabled true // Zipalign优化 zipAlignEnabled true // 移除无用的resource文件 shrinkResources true // 前一部分代表系统默认的android程序的混淆文件，该文件已经包含了基本的混淆声明，后一个文件是自己的定义混淆文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' signingConfig signingConfigs.release &#125; &#125; 动态设置参数使用key/value的方式，引入签名的配置，而不是直接写入，这样会增强安全性，特别是对于开源项目 123456789101112131415//配置签名文件 signingConfigs &#123; release &#123; storeFile file(pStoreFile) storePassword pStorePassword keyAlias pKeyAlias keyPassword pKeyPassword &#125; debug &#123; storeFile file(pStoreFile) storePassword pStorePassword keyAlias pKeyAlias keyPassword pKeyPassword &#125; &#125; 然后在gradle.properties中配置 12345# 签名信息pStoreFile = ./xxxxx.keystorepStorePassword = xxxxxpKeyAlias = xxxxxpKeyPassword = xxxxx 多渠道打包 过程相对比较复杂，且网上很多教程，AS3.0和以上的版本略有不同就不列出详细信息 在清单文件创建占位符 -&gt; 配脚本 -&gt; 生成重命名包(注意AS3.0变化) 系统有一个BuildConfig类文件，是无法改变值的。里面有一些常用的配置参数，比如版本号什么的，我们可以手动配置，然后从这个类里面取值。手动配置：1234567buildTypes&#123; xys&#123; buildConfigField "boolean","testFlag","false" signingConfig signingConfig.xys applicaitonIdSuffix ".xys" &#125;&#125; 这样： 12345678910public final class BuildConfig&#123; public static final boolean DEBUG = Boolean.parseBoolean("true"); public static final String APPLICATION_ID = "com.example.jingbin.cloudreader"; public static final String BUILD_TYPE = "debug"; public static final String FLAVOR = ""; public static final int VERSION_CODE = 14; public static final String VERSION_NAME = "2.0.0"; // Fields from build type: xys 额外生成了这个 pubic static final boolean testFlag = false;&#125; 其他注意事项引用Maven中央库： http://mvnrepository.com/ 上传和使用 使用Gradle上传aar到Maven库 12345// gradle编译加速 dexOptions &#123; incremental true javaMaxHeapSize "4g" &#125; 不同包或相同包下，最好不要出现相同的文件，Merge到一起时，相同的资源名就会发生冲突！ Grovvy Grovvy(语言)对于Gradle(脚本)，好比于Java对于Android。 Grovvy核心是Task。Task依赖：增加一个依赖方法，连接起来，让不在一起的Task能够有一个先后执行的关系。 三个阶段 do Something Initiliacation 初始化阶段，执行项目中的setting.gradle脚本 Configration 解析每个Profect中的build.gradle脚本，生成有向关系图–tashgrash Build 编译运行阶段，按照tashgraph执行编译 深藏功与名的开发者工具AAPT Android Asset Packaging Tool -&gt; SDK - build-tools 可以查看，创建，修改压缩文件(Zip、jar、APK),也可将资源编译成二进制文件。查看报信息，资源目录等。 Lint用于检测各项目中(包含库)中的一些错误问题，比如资源未用或过时的api等。在AS命令行使用gradle lint。(如果gradle版本更新则要更改配置) 1234// 使用lint检查代码时错误的话停止，加上这个之后就会继续，但是一般不启动lint，因为启动后会编译很慢lintOptions&#123; abortOnError false&#125; 无线调试基于ADB的TCP/IP模式 - 《图解TCP/IP》 9Patch工具SDK -&gt; tools -&gt; draw9patch(画单边就行)在AS中点击鼠标右键生成9patch图 Hierarchy viewer检测UI性能的工具testCompile 只有Debug生效，Release解除 查看UI iautomatorviewer 开发者模式 调试GPU过渡绘制 App背后的故事 - 性能检测与分析工具UI性能分析 调试GPU过渡绘制 16ms黄金准则 布局核心准则： 尽量使布局的view树扁平，降低布局的层次 Google建议View不宜超过8层 使用组合控件 LinearLayout与RelativeLayout 使用LinearLayout：保证层级不深 使用RelativeLayout：避免嵌套 Hierarchy viewer：检测UI性能的工具 Merge与Viewstub 布局懒加载 图片重绘 Overdraw Debug Gpu Overdraw查看重绘界面 1、改善布局，避免重叠 2、控件与主背景颜色相同：可移除控件背景 3、自定义view背景，使用dipRect属性减少重绘区域 Profile Gpu rendering 在开发者模式中，GPU呈现模式分析 -&gt; 在屏幕上显示条形图 内存区分 寄存器 Registers：用于存储指令、地址、数据。 栈 Stack：存放基本类型的数据、对象的引用和函数地址等，由系统控制。 堆 Heap：存放对象本身和数组，由开发者控制。 静态域 static field：存储静态变量。 常量池 constant pool：存储常量。 开发者能够控制的内存，基本在于堆和栈区域，他们的区别如下： 堆/栈 GC管理 存取速度 推 由GC系统控制。变量生命周期结束后，由GC系统决定何时回收 慢 栈 由虚拟机控制。变量生命周期结束后，由虚拟机释放该变量占用的内存空间 快 常用的内存类型： VSS - Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）。 RSS - Resident Set Size 实际使用物理内存（包含共享库占用的内存）。 PSS - Proportinal Set size 实际使用的物理内存（比例分配共享库占用的内存）。 USS - Unique Set Size 进程独自占用的物理内存（不包含共享库占用的内存）。 一般来说内存占用大小有如下规律：VSS≥RSS≥PSS≥USS GC系统GC系统遵循GC Root搜索算法，根据是否包含其他对象的引用来判断是否需要进行GC。在Android2.3之后，系统修改了GC，将GC作为并发线程，同时每次GC并不会遍历整个Heap，而是只遍历一部分内存。 GC系统根据GC Root算法进行GC工作，该算法会以一个GC Root对象为起点，搜索与之相关联的对象。如果某个对象与GC Root对象没有找到引用链，则表示該对象需要进行回收，常见的GCRoot对象有以下几种。 class：由System class loader 加载的对象。 JNI：jni相关调用的引用、变量、参数。 Thread：活着的线程。 Stack：栈中的对象。 静态：方法区类的静态属性引用的对象。 常量：方法区中的常量引用的对象（final类型）。 获取更多内存通过子线程 安卓系统的内存分配通过进程分配。 WebView内存回收非常麻烦，需要运行在单独进程中(android:process)。然后通过kill process回收内存。 Native Heap 安卓系统限制的是JavaHeap的内存大小。 系统控制的，不受大小限制 -&gt; Fresco. openGL 图像处理 LargeHeap通过清单文件配置加大GC难度，使GC变慢，退到后台时，很容易被回收。 系统内存警告 根据情况释放内存 onLowMemory onTrimMemory 检测内存泄漏工具 MAT - Memory Analysis Tool LeakCanary]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Books</tag>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[京东CPS商品推广接入流程]]></title>
    <url>%2F2018%2F02%2F02%2F%E4%BA%AC%E4%B8%9CCPS%E5%95%86%E5%93%81%E6%8E%A8%E5%B9%BF%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[京东CPS与阿里百川CPS有很大不同，认清基本概念后集成时就容易的多。 基本操作京东CPS，只需要一个链接足以，这条链接放在自身的WebViewActivity中，如果设置了唤起App，则链接会返回一个打开京东App的规则字符串，我们获取到后跳转到京东App就可以了。 设置后得到一个链接，然后用自身的WebView请求，当然也可以用系统自带的浏览器打开，可以直接唤起App。有时候我们不想用户离开自己的应用，使用自身的App的WebView控件打开就成了首选，这里就需要配置一些参数。 继承WebViewClient复写里面的shouldOverrideUrlLoading方法：1234567891011121314151617181920212223242526272829303132@SuppressWarnings("deprecation")@Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;// DebugUtil.error("----url:"+url); if (TextUtils.isEmpty(url)) &#123; return false; &#125; if (url.startsWith("http:") || url.startsWith("https:")) &#123; // 可能有提示下载Apk文件 if (url.contains(".apk")) &#123; startActivity(url); return true; &#125; return false; &#125; startActivity(url); return true; &#125;private void startActivity(String url) &#123; try &#123; Intent intent1 = new Intent(); intent1.setAction("android.intent.action.VIEW"); Uri uri = Uri.parse(url); intent1.setData(uri); intent1.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); mActivity.startActivity(intent1); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; 请求京东的推广url后，会返回一串这样的URL SCHEME：openApp.jdMobile://virtual?params={参数}这就是跳转京东页面的SCHEME 另外其他App的URL SCHEME 淘宝： taobao://微博： weibo://qrcode微信： weixin://scanqrcode支付宝： alipayqr://platformapi/startapp?saId=10000007豆瓣： douban://京东： openApp.jdMobile://virtual?params={参数}电话： mobilephone://备忘录： mobilenotes://Chrome谷歌浏览器： googlechrome://12306订票助手： trainassist://飞信： fetion://豆瓣FM： doubanradio://爱奇艺PPS： ppstream://哔哩哔哩动画： bilibili://56视频： com.56Video://365日历： rili365://58同城： wbmain://遇见： iaround://陌陌： momochat://有道词典： yddict://优酷： youku://掌阅iReader： iReader://天涯社区： tianya://天气通Pro： sinaweatherpro://天气通： sinaweather://墨迹天气： rm434209233MojiWeather://腾讯新闻： qqnews://腾讯微云： weiyun://腾讯地图： sosomap://淘宝旅行： taobaotravel://人人： renrenios:// 阿里百川CPS与京东CPS两者对比： CPS类别 是否需要SDK WebView处理 打开App方式 App左侧是否有标识 接入复杂程度 阿里百川 是 无需处理 通过SDK打开 有 相对复杂 京东 否 要处理 使用规则协议打开 无 简单 联系我：GitHub、简书]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar去除标题与返回键间的间距]]></title>
    <url>%2F2018%2F01%2F22%2FToolbar%E5%8E%BB%E9%99%A4%E6%A0%87%E9%A2%98%E4%B8%8E%E8%BF%94%E5%9B%9E%E9%94%AE%E9%97%B4%E7%9A%84%E9%97%B4%E8%B7%9D%2F</url>
    <content type="text"><![CDATA[很早就遇到一个问题，如下图： 标题和左侧的返回键间距过大，之前在做CloudReader的时候就遇到了，一直没有解决，由于自身强迫症，心里始终和这个过不去，就研究了很久终于解决了。 之前在网上找了各种解决方法，比如给ToolBar设置12app:contentInsetLeft="0dp"app:contentInsetStart="0dp" 不直接给ToolBar设置字体，在ToolBar里面包裹TextView，还是不行。等等… 最后：将1mTitleToolBar.setNavigationIcon(R.drawable.icon_back); 去掉后，发现标题顶格了，于是怀疑是NavigationIcon的问题。将1app:navigationIcon="@drawable/icon_back" 设置在ToolBar属性上后可以直接看到效果，开始考虑是不是有一个属性是设置NavigationIcon与title之间的间距，果然发现了：1app:contentInsetStartWithNavigation="0dp" 附上完整代码：1234567891011121314&lt;android.support.v7.widget.Toolbar xmlns:app="http://schemas.android.com/apk/res-auto" android:id="@+id/title_tool_bar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="@color/colorTheme" app:contentInsetLeft="0dp" app:contentInsetStart="0dp" app:contentInsetStartWithNavigation="0dp" app:layout_scrollFlags="enterAlways|scroll" app:navigationIcon="@drawable/icon_back" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:theme="@style/ToolbarStyle" app:title="标题" app:titleTextColor="@color/colorWhite"&gt; 后来直接搜了这个属性查了一下，发现之前还是有很多人遇到过，只不过我没检索出来，推荐一个分析的很好的： 关于Toolbar中navigationIcon和title之间距离及展开 app:contentInsetStartWithNavigation=“0dp” isn’t working in ToolBar - 在外面包裹AppBarLayout应该也能达到效果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 阿里百川cps SDK接入流程]]></title>
    <url>%2F2018%2F01%2F19%2FAndroid-%E9%98%BF%E9%87%8C%E7%99%BE%E5%B7%9Dcps-SDK%E6%8E%A5%E5%85%A5%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言因公司业务需求，需接入阿里百川SDK和京东联盟cps相关服务，为了跳到淘宝和京东，用户购买后得到佣金。接入过程中遇到很多坑，网上相关资料也甚少，虽然东西不算多，但花了不少时间，在此记录下来，为了以后的人能有个参考。这里只跳转到天猫，淘宝的产品详情页，京东产品详情会另作文章分享。 准备工作 阿里百川 开发者控制台 1.申请百川无线应用 注意：Android端和IOS端各申请一个应用，虽然会提示名字不能重复但不影响，也是可以正常使用的。 2.开通业务产品的使用权限 3.获取安全图片 注意：1.一定要使用gradle3.0以下的编译环境的包，不然会提示“上传失败”(这个坑了我好长时间)。2.对应的keystore要一致，虽然我没有遇到问题，但看到其他人反馈过，小心为妙。 接入 下载百川电商SDK里面会有很详细的说明，这里只快速的过一遍，总结一下自己遇到的坑及解决方法。 添加安全图片 yw1222.jpg获得安全图片，并放在/res/drawable目录下，如果已经有安全图片，需要替换。 项目中的build.gradle文件1234567891011121314151617 maven &#123; url 'http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories/' &#125;classpath 'com.neenbedankt.gradle.plugins:android-apt:1.8'//Added lineallprojects &#123; repositories &#123; jcenter() maven &#123; url 'https://maven.google.com/' name 'Google' &#125; maven &#123; url 'http://repo.baichuan-android.taobao.com/content/groups/BaichuanRepositories/' &#125; &#125;&#125; modle的build.gradle文件123456789101112131415161718192021222324252627282930313233343536repositories &#123; maven &#123; url "http://mvnrepo.alibaba-inc.com/mvn/repository" &#125; flatDir &#123; dirs 'libs' &#125;&#125; //fastjson compile 'com.alibaba:fastjson:1.2.9' //支付 compile 'com.alibaba.alipay:alipaySingle:20160825@jar' //登陆 compile 'com.ali.auth.sdk:alibabauth_core:1.4.3@jar' compile 'com.ali.auth.sdk:alibabauth_ui:1.4.3@aar' compile 'com.ali.auth.sdk:alibabauth_ext:1.4.3@jar' //安全基础 compile 'com.taobao.android:securityguardaar3:5.1.81@aar' //Mtop网关 compile 'com.taobao.android:mtopsdk_allinone_open:1.2.2.4@jar' //applink compile 'com.alibaba.sdk.android:alibc_link_partner:1.1.0.0' //UT (因为和友盟推送的jar重复，所以去掉，不然会报错！！！) //compile 'com.taobao.android:utdid4all:1.1.5.3_proguard@jar' compile 'com.alibaba.mtl:app-monitor-sdk:2.5.1.3_for_bc_proguard@jar' //联盟SDK compile 'com.alimama.tunion.sdk:tuniontradesdk:0.3.2' //电商SDK compile 'com.alibaba.sdk.android:alibc_trade_common:3.1.1.206' compile 'com.alibaba.sdk.android:alibc_trade_biz:3.1.1.206' compile 'com.alibaba.sdk.android:alibc_trade_sdk:3.1.1.206' Proguard 规则1234567891011121314-keepattributes Signature-keep class sun.misc.Unsafe &#123; *; &#125;-keep class com.taobao.** &#123;*;&#125;-keep class com.alibaba.** &#123;*;&#125;-keep class com.alipay.** &#123;*;&#125;-dontwarn com.taobao.**-dontwarn com.alibaba.**-dontwarn com.alipay.**-keep class com.ut.** &#123;*;&#125;-dontwarn com.ut.**-keep class com.ta.** &#123;*;&#125;-dontwarn com.ta.**-keep class org.json.** &#123;*;&#125;-keep class com.ali.auth.** &#123;*;&#125; AndroidManifest.xml123&lt;!--cps--&gt;&lt;uses-permission android:name="android.permission.MOUNT_UNMOUNT_FILESYSTEMS" /&gt;tools:replace="android:allowBackup" Application初始化1234567891011121314// AlibcTradeCommon.turnOnDebug();// AlibcTradeBiz.turnOnDebug();//电商SDK初始化AlibcTradeSDK.asyncInit(app, new AlibcTradeInitCallback() &#123; @Override public void onSuccess() &#123; Toast.makeText(app, "初始化成功", Toast.LENGTH_SHORT).show(); &#125; @Override public void onFailure(int code, String msg) &#123; Toast.makeText(app, "初始化失败,错误码="+code+" / 错误消息="+msg, Toast.LENGTH_SHORT).show(); &#125;&#125;); 工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 private final static String H5 = "H5"; private final static String TAOBAO = "taobao"; private final static String TMALL = "tmall"; private final static String AUTO = "auto"; private static void showDetailPage(Activity activity, String id, String type) &#123; AlibcShowParams alibcShowParams; switch (type) &#123; case H5: alibcShowParams = new AlibcShowParams(OpenType.H5, false); break; case TAOBAO: alibcShowParams = new AlibcShowParams(OpenType.Native, false); alibcShowParams.setClientType("taobao_scheme"); break; case TMALL: alibcShowParams = new AlibcShowParams(OpenType.Native, false); alibcShowParams.setClientType("tmall_scheme"); break; case AUTO: alibcShowParams = new AlibcShowParams(OpenType.Auto, false); break; default: alibcShowParams = new AlibcShowParams(OpenType.Auto, false); break; &#125; AlibcBasePage alibcBasePage = new AlibcDetailPage(id); HashMap&lt;String, String&gt; exParams = new HashMap&lt;&gt;(); // 固定写法 exParams.put(AlibcConstants.ISV_CODE, "appisvcode"); // 若非淘客taokeParams设置为null即可 mm_memberId_siteId_adzoneId // pid:广告位id AlibcTaokeParams alibcTaokeParams = new AlibcTaokeParams(); // adzoneid 为mm_memberId_siteId_adzoneId最后一位 alibcTaokeParams.adzoneid = "33333"; alibcTaokeParams.pid = "mm_11111_22222_33333"; alibcTaokeParams.subPid = "mm_11111_22222_33333"; alibcTaokeParams.extraParams = new HashMap&lt;&gt;(); alibcTaokeParams.extraParams.put("taokeAppkey", "xxxxxxx"); AlibcTrade.show(activity, alibcBasePage, alibcShowParams, alibcTaokeParams, exParams, new AlibcTradeCallback() &#123; @Override public void onTradeSuccess(AlibcTradeResult alibcTradeResult) &#123; &#125; @Override public void onFailure(int i, String s) &#123;// Toast.makeText(App.getInstance(), "初始化失败,错误码=" + i + " / 错误消息=" + s, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; /** * 跳淘宝详情 */ public static void showTaobaoDetail(Activity activity, String id) &#123; if (Tools.isApplicationAvilible(activity, "com.taobao.taobao")) &#123; showDetailPage(activity, id, TAOBAO); &#125; else &#123; showDetailPage(activity, id, AUTO); &#125; &#125; /** * 跳天猫详情 */ public static void showTmallDetail(Activity activity, String id) &#123; if (Tools.isApplicationAvilible(activity, "com.tmall.wireless")) &#123; showDetailPage(activity, id, TMALL); &#125; else &#123; showDetailPage(activity, id, AUTO); &#125; &#125; 资源销毁在使用完成后，可以调用destroy方法，释放百川相应的资源引用1AlibcTradeSDK.destroy(); 参考 阿里百川电商SDK(3.1)接入与使用 电商交易功能详解－Android 百川电商SDK接入Android常见问题 淘宝客基础API 联系我：GitHub、简书]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《非暴力沟通》读书笔记]]></title>
    <url>%2F2018%2F01%2F07%2F%E3%80%8A%E9%9D%9E%E6%9A%B4%E5%8A%9B%E6%B2%9F%E9%80%9A%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[《非暴力沟通》是2009年1月华夏出版社出版的图书，作者是马歇尔·卢森堡。著名的马歇尔·卢森堡博士发现了一种沟通方式，依照它来谈话和聆听，能使人们情意相通，和谐相处，这就是”非暴力沟通”。非暴力最重要的应用也许是培养对自己的爱。 很早之前就看了，大约大半年了，之前记录日记本上，现在整理出来。 听到不中听的话时，我们有四种选择： 责备自己 指责他人 体会自己的感受和需要 √ 体会他人的感受和需要 √ 观察 - 感受 - 需要 - 请求 需要的三个阶段: “情感的奴隶” “面部可憎” “生活的主人” 委曲求全 说出心里话 尊重他人的需要 既表达自己，又关心他人 我希望你告诉我，即使不喜欢我做的一些事情，你仍然会和我在一起，请让我成为我自己的明确要求。 如果一个人想要别人了解他的处境，听到的却是安慰和建议，那么，他就有可能觉得不太舒服。 沟通可以是一扇窗，也可以是一面墙。 我们无法给别人我们自己都没做的东西。 1.体会自己的感受和需要。 2.大声地提出请求。 3.换一个环境。 观察我们仔细观察正在发生的事情，并清楚地说出观察结果注意观察和评论的区别。不带评论的观察是人类智力的最高形式 感受需要得到满足时的感受 兴奋 喜悦 欣喜 甜蜜 精力充沛 兴高采烈 感激 感动 乐观 自信 振作 开心 高兴 快乐 愉快 幸福 陶醉 满足 平静 自在 舒适 放松 踏实 安全 温暖 放心 心旷神怡 喜出望外 无忧无虑 安心 需要没有得到满足时的感受 害怕 担心 焦虑 着急 紧张 心神不灵 心烦意乱 忧伤 沮丧 灰心 气馁 泄气 绝望 伤感 凄凉 悲伤 恼怒 愤怒 烦恼 苦恼 生气 厌烦 不满 不快 不耐烦 不高兴 震惊 失望 困惑 茫然 寂寞 孤独 郁闷 难过 悲观 沉重 麻木 精疲力竭 萎靡不振 疲惫不堪 昏昏欲睡 不舒服 无精打采 尴尬 惭愧 内疚 嫉妒 遗憾 基本需要非暴力沟通把需要看作是有助于生命健康成长的要素。 1.自由选择选择梦想/目标/方向自由制定计划来实现这些梦想、目标和方向 2.庆祝庆祝生命的创造力以及梦想的实现纪念人生的失落：亲人的去世或梦想的破灭等(表达悲伤) 3.言行一致真诚 创造 意义 自我肯定 4.滋养身体空气 食物 运动免于病毒、细菌、昆虫及肉食性动物的伤害。休息 住所 触摸 水 5.玩耍乐趣 欢笑 6.情意想通美 和谐 激励 秩序 平静 7.相互依存 接纳 欣赏 亲密关系 社区 体贴 成长 安全感 倾听 诚实 爱 信心 尊重 支持 信任 理解 诚实使我们能够认识和超越自己的局限性。 请求我们告诉人们，为了改善生活，我们希望他们做什么。我们避免使用抽象的语言，而借助具体的描述，来提出要求。]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《前任3:再见前任》观后感]]></title>
    <url>%2F2018%2F01%2F07%2F%E3%80%8A%E5%89%8D%E4%BB%BB3%EF%BC%9A%E5%86%8D%E8%A7%81%E5%89%8D%E4%BB%BB%E3%80%8B%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[多余的话本来定位的是个人博客，无非是自己生活所感所想发泄之所。因为不想一个人写了自己锁起来，想有些人看见有个倾述，又有些东西不想发出来给人看，心理有时候会很矛盾。不像很多人那么有才华，写的幽默并有内涵，自持喜欢读书，看着书架很舒服，但感觉也没有读多少书。 以前的很多博客都是凌晨之后更新的，我看有很多作品也是，也许经过了一天的事务，凌晨是沉淀的最佳时刻。自从健身以后凌晨就很少进行剧烈的脑力运动了，很担心会失去了健身效果，今天是健身后的第一天晚睡，就放肆一回。 今天和一个高中同学的初中女同学去看了《前任3:再见前任》，第二次见面第一次约出去看电影，至于什么关系我也搞不清楚。看了之后心情很沉重，送别人回去后，回来又把《前任攻略》、《前任2:备胎大作战》刷了，看完后就很想理清楚什么。 曾经的感情 这是一段很长的故事，之前已经写了很多很多，后来隔了一夜看了觉得好幼稚，所以这里只写重点吧。 之后看了《前任2》，我觉得我错太多了。女主当初那么单纯的感受就是我最初恋爱的感受。因为当时我是一个弱鸡，我觉得自己还没有能力说那句话，我给自己的定位就是我来好好努力让你接受我，和我结婚。而这就是导致我们分手的罪魁祸首。 搞清自己的定位非常关键，两个人在一起不是谁对谁的好是理所当然的，我喜欢你所以我对你这么好，我愿意付出，愿意花心思在你身上。当然两个人在一起的技巧也就是套路非常重要，直白点就是会撩，可惜的是我不是这块料，不会说特好听的话，做一些暖心的事，曾经以为每个人不一样，有些人不用说很好听得话就能在一起，后来知道这样想就太错了，这是懒惰的借口。 开始想改善自己的这方面的缺点，我不会演讲所以我报了专门改善演讲的课程，而两个人之间的相处天天发生，我却对这没有足够的重视。之前买了这类型的书籍，也没有看完，现在准备慢慢看这方面的，心理学，沟通类及收集一些情话。 结今年除了Android方面的书籍外，开始慢慢看心理学相关的书籍。很早之前就有这个打算，今年定为学习的一年，技术和心理学，如果有时间再扩展其他的学科。]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云阅：一个基于网易云音乐UI，使用Gank.Io及豆瓣Api开发的开源项目]]></title>
    <url>%2F2018%2F01%2F03%2F%E4%BA%91%E9%98%85%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90UI%EF%BC%8C%E4%BD%BF%E7%94%A8Gank-Io%E5%8F%8A%E8%B1%86%E7%93%A3Api%E5%BC%80%E5%8F%91%E7%9A%84%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[CloudReader一款基于网易云音乐UI，使用GankIo及豆瓣api开发的符合Google Material Desgin阅读类的开源项目。项目采取的是Retrofit + RxJava + MVVM-DataBinding架构开发。开发中所遇到的各种问题已归纳在这里。 github地址：CloudReader 版本更新日志 效果图 部分效果图 gif演示 Introduction网易云音乐于2013年4月23日正式发布，是一款主打发现和分享，带有浓厚社交基因的网络音乐产品。相信用过的人都知道它给人的体验是极好的，我看过了绝大多数仿写的案例，基本UI都不够细致，于是决定自己动手写一个，起初也不知道具体它是怎么布局的，后来使用SDK提供的工具uiautomatorviewer慢慢分析后再逐渐完善的，争取效果一致~ 模块分析干货（gank.io） API使用的是动听（轮播图）和代码家的Gank.Io。 每日推荐： 干货集中营推送的每日内容，包括每天一个妹子图，相关Android、IOS等其他干货。每天第12：30之后更新，因为双休不更新所以内容缓存三天网络取不到就取缓存。 福利： Glide加载图片，点击查看大图，支持双指缩放，一下可查看列表的所有图片，再也不用逐个点击每张图啦。 干货订制： 可以筛选自己喜欢干货的类别，有全部、IOS、App、前端、休息视频和拓展资源。 大安卓： 显示安卓的全部资讯。支持下拉刷新方便查看最新的资源。 电影（豆瓣） API是豆瓣提供的，因为限制了每个ip每分钟请求的次数，所以请酌情使用，由此带来的不便请见谅。 电影热映区： 每日更新，展示最新上映的电影热度排行榜。 豆瓣电影Top250： 豆瓣高分电影集锦，让你放心找好片~ 书籍（豆瓣） 使用的是豆瓣的搜索API。更多订制内容由于时间原因第一版还未添加，第二版会加上。 综合： 检索豆瓣综合类的书籍并展示。 文学： 检索豆瓣文学类的书籍并展示。 生活： 检索豆瓣生活类的书籍并展示。 抽屉界面 完全仿网易云音乐抽屉界面，包括诸多细节如透明标题栏，背景透明度，水波纹颜色等。 项目主页：展示项目介绍信息，及内容说明，可以分享给你的好友哦。 扫码下载：扫码即可下载App，帮助您快速试用~ 问题反馈：常见问题归纳，反馈地方，联系方式都在这里哦！ 关于云阅：更新日志在这里可见，主人是利用工作外时间做的，周期较长，满意的小伙伴给个Star吧，这将是我继续迭代的动力，谢谢~ Features 特性 1、干货集中营内容与豆瓣电影书籍内容。 2、高仿网易云音乐歌单详情页。 3、NavigationView搭配DrawerLayout的具体使用。 4、MvvM-DataBing的项目应用。 5、RxBus代替EventBus进行组件之间通讯。 6、ToolBar及TabLayout的使用姿势。 7、Glide加载监听，获取缓存，圆角图片，高斯模糊。 8、水波纹点击效果详细使用与适配。 9、RecyclerView下拉刷新上拉加载。 10、基于DataBinding的ViewHolder。 11、基于DataBinding的BaseActivity和BaseFragment。 12、Fragment懒加载模式。 13、透明状态栏使用与版本适配。 14、SwipeRefreshLayout结合RecyclerView下拉刷新上拉加载。 15、CoordinatorLayout + Behavior实现标题栏渐变。 16、NestedScrollView嵌套RecyclerView的使用。 细节分析 - ToolBar 上的按钮点击效果仔细研究的人知道，网易云音乐的UI做的很精致，就拿一个ToolBar为例，上面的每个按钮的点击操作都有各自的效果。这给了用户一个很好的反馈，就是如下的效果： 上图是在android 5.1系统下的效果图。在6.0上搜索的点击效果有些许改变，其他基本类似；5.0以下点击则都表现出一般选择器的效果。 然而做到以上的效果并不容易，需要你对ToolBar有深入的了解；不仅如此，水波纹的点击效果在不同的主题下是有不同的表现。下面一起来谈谈如何达到以上的效果。 关于ToolBar的布局看到上图我们了解到一个ToolBar上有三种点击效果.. 这就有点尴尬了..不急，我们慢慢来分析。利用SDK下的工具uiautomatorviewer可得知：左边的菜单按钮是ToolBar内部包裹的一个Fragment,其中是一个ImageView和一个小红点；然后中间是HorizontalScrollView，其中是三个ImageView；右边的搜索键则是通过设置Menu菜单而来，这样会有长按弹出“搜索”二字的提示。 现总结出两个问题：1、ToolBar上按钮的设置；2、不同按钮点击的水波纹效果 对于1： ToolBar上按钮的设置 些许研究了ToolBar的使用后得知，可以直接在其内部包裹Imageview外，还可以通过菜单文件设置： 12345@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.main, menu); return true;&#125; 其中，main.xml内容如下： 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;menu xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto"&gt; &lt;item android:id="@+id/action_search" android:icon="@drawable/actionbar_search"// 显示图标 android:orderInCategory="100"// 菜单显示优先级 android:title="@string/actionbar_search"// Toast文字“搜索” app:showAsAction="always" /&gt;// 总是显示，其中还有"never"点击后弹出显示；``ifRoom``根据空间判断是否显示&lt;/menu&gt; 然后再找到菜单相应的id处理点击事件： 12345678910@Overridepublic boolean onOptionsItemSelected(MenuItem item) &#123; switch (item.getItemId()) &#123; case R.id.action_search:// Toast.makeText(this, "打开搜索页面", Toast.LENGTH_SHORT).show(); return true; default: return super.onOptionsItemSelected(item); &#125; &#125; 这样就完成了两者点击效果不同的处理。 对于2：不同按钮点击的水波纹效果 这里不是使用ripple属性了，而是使用系统自带的点击水波纹选择器，给要产生点击效果的控件设置： 1android:background="?attr/selectableItemBackgroundBorderless" 然而设置后你会发现所有点击的颜色都是一致的，如果你使用主题：1theme="@style/Theme.AppCompat.Light.NoActionBar" 点击效果就会全部是黑灰的，就是中间三个按钮的那种效果，如果想要点击效果是白色的话，需要设置主题：1theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar" 知道这样后我们给不同的布局设置不同的主题就解决了这个问题。最终布局文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;android.support.v7.widget.Toolbar android:id="@+id/toolbar" android:layout_width="match_parent" android:layout_height="?attr/actionBarSize" android:background="@color/colorTheme" app:contentInsetStart="0.0dp" app:popupTheme="@style/ThemeOverlay.AppCompat.Light" app:theme="@style/ThemeOverlay.AppCompat.Dark.ActionBar"&gt; &lt;FrameLayout android:id="@+id/ll_title_menu" android:layout_width="wrap_content" android:layout_height="match_parent" android:background="?attr/selectableItemBackgroundBorderless" android:paddingLeft="15dp" android:paddingRight="15dp"&gt; &lt;ImageView android:id="@+id/iv_title_menu" android:layout_width="23dp" android:layout_height="wrap_content" android:layout_gravity="center" android:src="@drawable/titlebar_menu" /&gt; &lt;/FrameLayout&gt; &lt;HorizontalScrollView android:layout_width="wrap_content" android:layout_height="match_parent" android:layout_gravity="center"&gt; &lt;LinearLayout android:layout_width="wrap_content" android:layout_height="match_parent" android:background="?attr/selectableItemBackgroundBorderless" app:theme="@style/Theme.AppCompat.Light.NoActionBar"&gt; &lt;ImageView android:id="@+id/iv_title_gank" android:layout_width="55dp" android:layout_height="wrap_content" android:layout_gravity="center" android:background="?attr/selectableItemBackgroundBorderless" android:src="@drawable/titlebar_disco" /&gt; &lt;ImageView android:id="@+id/iv_title_one" android:layout_width="55dp" android:layout_height="match_parent" android:background="?attr/selectableItemBackgroundBorderless" android:src="@drawable/titlebar_music" /&gt; &lt;ImageView android:id="@+id/iv_title_dou" android:layout_width="55dp" android:layout_height="match_parent" android:background="?attr/selectableItemBackgroundBorderless" android:src="@drawable/titlebar_friends" /&gt; &lt;/LinearLayout&gt; &lt;/HorizontalScrollView&gt; &lt;/android.support.v7.widget.Toolbar&gt; 这样就得到了我们想要的效果~更多细节优化我会慢慢整理在Wiki文档，或你也可以直接查看源代码。 DownLoad 火速跳转 宝贵意见如果有任何问题，请到github的issue处写上你不明白的地方，也可以通过下面提供的方式联系我，我会及时给予帮助。另外常见的问题已总结在这里。 Thanks 图片来源：iconfont、UI工程师Sandawang和网易云音乐App。 参考项目：ImitateNetEasyCloud、banya；主要数据来源：Gank.Io、豆瓣Api。 使用到的开源库：glide、bottomsheet、nineoldandroids、rxandroid等等。 感谢代码家、张鸿洋、drakeet、yang747046912、GiitSmile、forezp等众多开发者贡献的开源项目，让我从中学到了很多! Statement感谢网易云音乐App提供参考，附上《网易云音乐Android 3.0视觉设计规范文档》。本人是网易云音乐的粉丝，使用了其中的部分素材，并非攻击，如构成侵权请及时通知我修改或删除。大部分数据来自于干货集中营和豆瓣APIV2.0，一切数据解释权都归代码家和豆瓣所有。 End如果你觉得不错，对你有帮助，可以帮忙分享给你更多的朋友，这是给我们最大的动力与支持，同时希望你多多fork，star，follow，我将贡献更多的开源项目O(∩_∩)O~。开源使生活更美好！ About me CSDN：Jingbin_ Blog：http://jingbin.me Email：jingbin127@163.com GitHub：https://github.com/youlookwhat]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>cloudreader</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2018不畏将来 | 2017不念过往]]></title>
    <url>%2F2018%2F01%2F02%2F2018%E4%B8%8D%E7%95%8F%E5%B0%86%E6%9D%A5%20%7C%202017%E4%B8%8D%E5%BF%B5%E8%BF%87%E5%BE%80%2F</url>
    <content type="text"><![CDATA[2017年终总结2016年也准备写年终总结，忙着写云阅就没有写，之后写了《在帝都独居一年多，让我体会到什么》,算了离开和年终总结一起了。2017年发生太多的事，真的需要好好的回想梳理一下。工作，身体都有很大的改变。本打算在2018年之前，将CloudReader架构规范一下，看来要延期了，不过也是最近一端时间的事。很庆幸自己当初选择这份职业，工作了近三年，现在依然对它非常热爱，前面的路也越来越清晰。 深圳找工作的两个月自从三月份离职去了深圳，在那找了大约两个月的工作，现将能记得的归纳于此。 3月份去了之后住在我一个叔叔那里，在龙华区，记得大二暑假打完暑期工后去那里玩了两天，现在还在那一块但是搬了一点距离，感觉没有多大的变化，他在那边已经住了四年左右。 面试 直接进入找工作吧，刚开始在拉钩上投简历，但基本上没有面试的，有时候真怀疑那个平台有问题，投了将近百来份邀请面试的差不多3家。在智联投的最多，也邀请面试的最多。前程无忧投了很多但没有一次邀请面试的。 最初面试的一家是一家做智能硬件的，深圳有很多做智能硬件的，面试了好几家都是。他们的需求很简单，就是一个智能摄像头，厂家给了开发这个摄像头的SDK文档，然后你用它的文档开发一个Android上运行的软件，在上面操作摄像头的上下左右旋转来达到监控的作用。公司是一层大厅是办公区域，其中隔了一部分，那一部分应该是车间，里面有很多设备。过去后老板直接给了一个软件和文档给我看，软件是厂家提供的但是没有源码，公司之前也没有开发类似的软件，因为自己也没有这方面的经验而且公司也不适合长期发展随便聊了一下就走了。 因为面的太多，之后的就不记录顺序了。 有一家是在关内 南山区，关内的规划很好，道路，环境，建筑都和关外有很大差别。面试是在一家高楼里，里面的人都穿西服打领带很正式，但一家互联网公司一般不会穿如此。进去是CTO接待的我，因为公司想出了一个idea，就差程序员了。这仿佛是一个段子，哈哈哈。CTO是做全栈的，Android端的基本实现了功能，只是UI和性能需要重新优化，各方面都问了，当然基本没有问题，谈薪资时发现公司是初创公司，正在招人而且是独立开发，就叫的16K，处于两点考虑，第一自己不是很想进这家公司，说不定公司马上就没了，第二这活很麻烦而且得不到多大的提升，不适合长待。公司招聘上面写的是10-15k，叫16k也不过分，多了可以要求降低嘛。事实并非如此，过了大约十天，没有联系我，我再次看了一个招聘信息，薪资改为8-10k了…之后面了很多公司，他们都写的10-15k，然而他们根本不能给这个范围的工资，关外的基本是这样。 期间面试，遇到各种奇葩公司，当然也有几家很好的。 有一家位置有点偏，那个地方是个科技园，楼栋编排的很好，而且每一栋都有它的别名，很文艺。进去后，那家公司有自己的Android团队，公司是一整层楼，布局很优雅，还带有一个大的阳台，面试我的是一个小组组长，问了一些工作中的遇到的问题和内存优化方面的问题，他表示很满意，只是那时候已经是午饭时间，人事和CTO去吃饭了就把简历留下了说会通知下一轮面试，但是也是没有结果了。 有一家是做订制外包的，在猪八戒网有店铺。地方在稍微中心一点的一个科技园，在那个科技园面试了三家，这个还算靠谱，面试了估计有一个小时左右，知道了我的能力范围，觉得可以，然后让我和人事沟通，本以为到这一轮很稳了，但没想到的是居然被人事pass了，不知道是不是工资要高了，后来问了一个做ios的，他的工资是8-9k，我要的是12k，当然还可能是其他的原因，具体也不清楚。那地方有一个公司刚成立，公司还没有10个人，正在组建团队，面试的是老板也没有技术面，也是无果。还有一个更奇葩了，去了以后让我在茶水室坐了一会儿，然后过来跟我说今天面试技术的没有来，让我回去，WTF，跑了几个小时过来得到这句话，真TM有病的公司。 总结一下 一家做摄像头智能硬件的，由于没有相关经验和公司没有人带无果。 一家关内的做手画板的，就是聊天的时候可以自己画东西发给对方的那种。 一家做订制外包的，被人事Pass了。 一家公司刚起步，忘了做什么的了，10人以内。 一家去了后，说面技术的没来，呵呵🙂 一家不知道做什么的，应该不止一个App，无果。 一家做语音的，差不多和科大讯飞业务一致，得到阿里的投资。两个人问了几个问题就让我走了(是不是人事为了kpi？)。 一家集团的分公司，做智能硬件的，不过之前有人做了接着优化，面了满意，工资最高给的是10k，我只能要10K那就10k，公司条件也很差。无果。 一家去了后有大约7个人左右一起笔试，android端估计爆了，招了这么多人来面。 还有一家还可以，不过公司的位置不大，但人员很多，比较拥挤，面试了以后我之后很明确的问了她有没有录用的可能，那边说工资给不了那么高，我当时要的12K，她说最多只能给到7K。 之前可能还有忘记写的，说最后一个吧。最后一个在龙岗，一家自己在家开的公司…位置不大，招了二十个左右的人，聊了很长时间，想了想还是拿一份offer吧，就答应了。 面试资料：Android 面试资料集锦 武汉房价 2015年没买，2016年涨疯，2017年持续。 本打算在武汉远城区买套房，深圳工作还房贷，可事实是残酷的。远城区太远以后居住根本不现实，买了也不会增值多少，深圳工作工资也比预想中的少很多，看了一下武汉的Android开发工资和深圳差不多。于是思考后觉得最靠谱的是，马上回武汉。 远城区房价也不便宜，平均1w一平，本来不贵，因为限购所以涨了起来。反而主城区的价格还不是很贵，但是就是限购。于是当时想的是工作两年，然后转为武汉户口再在主城区买。 工资差不多，关键是离家近，而且弟弟马上来武汉读书，可以有个照顾。 迟早会回武汉，如果以后回武汉，那在深圳积累的人脉关系就又断了，在武汉还得重新开始。 后来出乎意料的是，武汉出台了300万大学生留汉的政策，放宽了落户标准，很快就落户武汉了。然后经过一些波折看中了武昌理工学院的一套房子，虽说交通现在不太方便，但距离光谷，软件园和金融港不远，价格相对不贵性价比很高，但很难买到，武汉现在楼市万象，各种内定的，不给茶水费基本拿不到房子。刚好有一个同学再做个，找了帮了个忙，但由于出了点问题，现在还是没有没有拿到房子，开盘秒，内定的也都没有拿到，现在等待后续的预留房源在。 那边房子出了问题，房子暂时没看到合适的，看了年后的几个盘，等年后再考虑了。 健康自己的身材一直是偏瘦型，身高177cm，体重基本没有突破60kg，今年是实在看不下去了，刚好看见住的附近有一家健身房，果断进去办了健身卡，并买了私教会员。花费的钱是在不少，有2W左右，因为实在想改变。之后锻炼基本每周三四次，工作日晚上九点过去，周末抽时间去上两节课，从以前的57kg，到现在68kg，今天是02月03日，体重基本在70kg左右，很喜欢那种有肉的感觉，哈哈！健身真的很需要坚持，生活作息，饮食和锻炼是一体的。 锻炼这么久深有感触的是： 1.每天12点左右休息(根据每个人生活习惯了)。因为我是10点上班起床较晚，所以睡的相对较晚。不休息好会影响食欲和精神，这是个恶性循环，可个人感觉很难坚持，坚持了四个月还是开始晚睡了，总感觉时间不够用。现在开始慢慢调整。 2.早餐一定要吃，而且最好是上午8-9点吃。吃晚了就没有食欲吃午饭了。 3.锻炼频率每周3次足矣，每次一个小时左右，强度尽量每次比上次重点，有所突破，有氧和无氧合理把握。(这个看个人的，因为我们时间不多，这个时间已经比较难坚持了，相对于锻炼后期我个人来说) 4.饮食很重要，尽量吃高蛋白的食物，用于肌肉生长，买鸡胸肉自己在家做最好了。没有条件买蛋白粉也可以，在锻炼完之后喝一勺，多了吸收不了对身体是个负担。多吃鸡蛋，前四个月我每天早餐四个鸡蛋，一杯豆浆，一个馒头。 基本做到上面四点，自己坚持几个月基本就会有效果，健身前期进度很快，从57涨到65用了2个月，但从65涨到69用了5个多月。 这会另外写一个健身记录，用于记录锻炼哪个部位做的什么动作等，肌肉有记忆力，尽量前几次动作做规范，做错误动作有时候不但没锻炼好，而且会对身体不好，产生形体错位。 开源项目今年定的目标是CloudReader达到2000start，算是超额完成了，帮助了很多人感到非常高兴，但发现MVVM架构不规范，只是使用了databinding而已，与之前自己理解的有出入，于是决定结合官方的demo规范一下，现在正在进行中。 现在已经基本完成了，参考了官方的Demo，但是Demo过于简单，没有使用到列表的情况，看了很多其他人写的也没有一个完善的解决方案，根据自己的理解重构了。感觉现在更多的像是MVP-databing，P–VM，写的VM像P层，由于列表刷新不好和数据联动，还是要通过Adapter，而设置Adapter还是要使用那部分设置逻辑，将数据显示到UI上则使用了databinding。 2018学习计划今年的计划主要是深耕Android和Java类知识，然后浅尝Kotlin，部分时间看心理学相关知识。 现在在看《Effective Java中文版》、《Android群英传 神兵利器》《Effective Java中文版》：记录的java一些重要的知识点，很值得学习。如果想要更系统的了解java还是推荐《Java编程思想》。《Android群英传 神兵利器》：一本工具书，里面的提到的每个点，几乎都需要掌握，很多之前都用到过，现在在看gradle部分。 2018.01.02 23:53 ——– 2018.02.02 续]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 记一次清除缓存所导致的bug]]></title>
    <url>%2F2017%2F12%2F21%2FAndroid-%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%B8%85%E9%99%A4%E7%BC%93%E5%AD%98%E6%89%80%E5%AF%BC%E8%87%B4%E7%9A%84bug%2F</url>
    <content type="text"><![CDATA[前提Android五种数据存储方式： 使用SharedPreferences存储数据 文件存储数据 SQLite存储数据 ContentProvider 网络存储 Android几种数据存储方式的应用场景 正文前段时间由于很多人反馈页面无数据的bug，对此考究了一段时间，遂将结果记录于此。 之前：设计的是，一个存储在SharedPreferences的状态值，控制页面是否取本地页面缓存，本地页面缓存也存储在SharedPreferences里。 这样如果用户清除了SharedPreferences的状态值，那就会请求网络数据，如果没有清除状态值，就会取本地页面缓存数据，也是取保存在SharedPreferences里的数据，这样是没有问题的。 之后：由于可能页面缓存数据有点多，将存储方式改为了文件存储方式，而没有做取不到缓存数据的措施。误认为用户清空本地页面缓存数据的同时也清空了SharedPreferences里的数据，而没有采取取不到数据时的措施。 清除数据：清除数据主要是清除用户配置，比如SharedPreferences、数据库、文件储存等等，这些数据都是在程序运行过程中保存的用户配置信息，清除数据后，下次进入程序就和第一次进入程序时一样； 清除缓存：缓存是程序运行时的临时存储空间，只会清空文件存储数据。 文件缓存是不稳定的，手机存储空间不足时，可能会删除文件缓存中的内容。 另外，如果需要持久化数据到本地且不可轻易更改的，还是使用数据库储存为宜。 参考资料 Android五种数据存储方式 Android清除数据、清除缓存、一键清理的区别]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发中所遇问题归纳]]></title>
    <url>%2F2017%2F11%2F23%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E6%89%80%E9%81%87%E9%97%AE%E9%A2%98%E5%BD%92%E7%BA%B3%2F</url>
    <content type="text"><![CDATA[持续更新，主要记录CloudReader及工作上所遇到的问题。 DataBinding DataBindingHelper.jar的使用：作为插件导入后，和生成Get、Set方法的使用类似。在对应的Bean里，可自动生成@Bindable和notifyPropertyChanged(BR.title);。此杰作是同事做的。网上也有类似的插件可以使用。 神坑！windows下databinding引入文字会有问题，而mac上没有！使用@string/string_type引入字符串！ layout节点写了xmlns:android=&quot;http://schemas.android.com/apk/res/android后，子布局不能写. include 子布局时子布局根节点也要声明id，不然引用不到子布局id 内部类加”private”,导致编译不通过,DataBinding出问题的bug。Adapter里有多个Holder，Holder类前加private后编译不通过，去掉就好了。暂时不清楚具体原因！ databinding 绑定子布局。先绑定,后父布局再addView() 注入 databinding 后，AndriodStudio包结构变乱。解决：Android Studio2.2会出现此情况，升级到2.2.2就可以了。 databinding绑定bean时，里面的子类也需要继承BaseObservable,否则会报错。 recyclerview 的viewhodler 里，获得绑定 view 的databinding:DataBindingUtil.getBinding(this.itemView);。 布局里没有声明id,则对应的 ItemEverydayBinding 无法生成。 更改包名之后（rename – gradle.applicationId）， databinding 相关文件会报错，进入Build --&gt; Rebuild Project就好了！ AS里更改包名：保险的方法(费了几个小时的时间的总结)：在目录下新建想要的工程目录，把activity等包拖到新建的目录底下，然后修改gradle下的applicationId。这时候已经好了，可以跑起来了。但是AndroidManifest.xml未更改package，更改后你会发现项目中的databinding会报错，需要使用全局替换，将之前的包名替换成想要的包名，然后进入Build --&gt; Rebuild Project就好了！ 注意：引用如：android:showImg=’@{bean.images.large}’时，里面的bean写错会造成编译错误！ 注意：text=&#39;@{xx}&#39;里面的值应为String类型。引用方法里的参数类型应一致。报错是不告诉具体的哪行代码，写多了只能自己一个个地方找。 android:showImg=’@{bean.images.large}’这样设置图片会闪一下！尤其是在recyclerview里面，效果很不好，如果是写在 adapter里就好了：ImgLoadUtil.displayEspImage(bean.getImages().getLarge(), binding.ivTopPhoto, 0);。不仅仅图片，文字也会闪。加上这句就好了：binding.executePendingBindings();，意思是：当数据改变时，binding会在下一帧去改变数据，如果我们需要立即改变，就去调用executePendingBindings方法。 布局里面的子布局里引用的bean可以一样（type一样），但是最好name不一样，不然可能会导致setBean()无效。改变name名就好了。 布局里使用了引用方法，一定要生成该布局的databinding类，不然方法会失效。 文件里引用bean: 123&lt;variable name="subjectsBean" type="com.example.jingbin.bean.moviechild.SubjectsBean" /&gt; 文件里调用静态方法： 123&lt;import type="com.example.yunyue.utils.StringFormatUtil"/&gt;// 布局调用android:text="@&#123;StringFormatUtil.formatName(subjectsBean.directors)&#125;" 字符串和静态方法拼接(注意外层引号的区别，里面没有字符串时任意都行，有则使用单引号)： 1android:text='@&#123;"类型："+StringFormatUtil.formatGenres(subjectsBean.genres)&#125;' 使用@BindingAdapter()，自定义loader用来异步载入图像： 一个参数时： 1234567 // 任意类里声明 @BindingAdapter("android:showImgBg") public static void showImgBg(ImageView imageView,String url) &#123; displayGaussian(imageView.getContext(),url,imageView); &#125;// 布局调用android:showImgBg='@&#123;subjectsBean.images.large&#125;' 两个或多个参数时： 123456789101112/** * 妹子，电影列表图 * @param defaultPicType 妹子：1 电影：0 */@BindingAdapter(&#123;"android:displayFadeImage","android:defaultPicType"&#125;)public static void displayFadeImage(ImageView imageView, String url,int defaultPicType) &#123; displayEspImage(url, imageView, defaultPicType);&#125;// XML里使用：android:defaultPicType="@&#123;1&#125;"android:displayFadeImage="@&#123;bean.url&#125;" 注意： 1. 方法参数第一个是控件声明,放在第二位不可以！ 2. 布局调用时，命名空间可自动生成。 建议： 1. android:showImgBg可任意写，但是项目里不能出现相同的命名，否则会被后来的覆盖掉！ 2. 如果 imgload:showImgBg 这样写,第一次编译会提示找不到该命名空间，跳到声明处。建议写成 android:showImgBg。 三元运算法： 123导入：&lt;import type="android.text.TextUtils" /&gt;使用：android:text='@&#123;TextUtils.isEmpty(resultsBean.who)?"佚名":resultsBean.who&#125;'也可以直接使用这时返回为null会不显示。 若在EditText中使用双向绑定，则设置值的时候要使用android:text=&quot;@={viewmodel.username}&quot;,注意中间的=不然会达不到双向绑定的效果。 RecyclerView ✔️ NestedScrollView里嵌套 RecyclerView 官方后期已经解决了显示不全问题！看引用的包是什么版本的！还需要加上这两行代码：(这样不推荐，会把内容全部一次性的加载进内存，造成卡顿) 12recyclerView.setNestedScrollingEnabled(false);recyclerView.setHasFixedSize(false); ❌ NestedScrollView里嵌套 RecyclerView ,在recyclerView.setLayoutManager(new FullyLinearLayoutManager(getActivity()));之后，需要加上,不然滑动不流畅: 12recyclerView.setNestedScrollingEnabled(false);recyclerView.setHasFixedSize(false); 以上切换还是会卡顿，原因是角标越界，虽然try了，还是会卡。使用MyScrollView也不可以。显示不全！FullyLinearLayoutManager&amp; MyScrollView RecyclerView 的item显示出现控件显示不全,item只显示一部分，非常怪异！在adapter中的onCreateViewHolder()中View inflate = layoutInflater.inflate(R.layout.xxx, parent, false);注意要依附于parent。这样就好了！ RecyclerView: No adapter attached; skipping layout 没有数据时，gone掉，不然一直会提示这个！ addFooterView时，使用LinearLayout 包裹时会显示部分，改为RelativeLayout或FrameLayout正常。 NestedScrollView包裹RecyclerView如果没关联下面design包会显示不出，加了就好了！ 1compile 'com.android.support:design:24.2.1' 同时此包里还含有Toolbar的属性： 12app:layout_collapseMode="pin" app:layout_scrollFlags="enterAlways|scroll" NestedScrollView里嵌套 RecyclerView 需要在onResume里加上.setFocusable(false)，不然进入页面会定位到列表第一条或其他问题。 添加headerview后，隐藏显示，进度条不会到达屏幕顶端。 完美解决隐藏Listview和RecyclerView去掉滚动条和滑动到边界阴影的方案 把WebView做为headerview添加，会有很多问题： 1.有时候webview底部会显示会出现一大片的空白区域：把WebView的layout_height设置为wrap_content。 2.加载完成后，点击webview区域，会滚动到webview的顶部：使其失去焦点，在headerview的根布局里加上：android:descendantFocusability=&quot;blocksDescendants&quot; 3.点击item进入详情后返回，会自动滚动到webview的顶部，在activity里加上：12345678910@Overrideprotected void onResume() &#123; super.onResume(); if (detailBinding!=null) &#123; detailBinding.getRoot().setFocusable(false); detailBinding.getRoot().setFocusableInTouchMode(false); detailBinding.wvDetail.setFocusable(false); detailBinding.wvDetail.setFocusableInTouchMode(false); &#125;&#125; ViewPager 与 Fragment 父布局使用FrameLayout或Scrollview下拉会有阴影效果，颜色是你配置的主题上指定的颜色。 viewpager左右预加载页面的个数设置：setOffscreenPageLimit(3);,设置后保证页面不被销毁，切换时就不会卡顿了（显示时加载数据）。注意，如果是这个viewpager本身就在父一个viewpager的一个页面里，则设置adapter时，应传getChildFragmentManager(),不然以上会设置不上，非法状态异常！ Fragment 和当前自身所在的Activity 走一套生命周期，意思就是Activity走了onResume(),fragment才会走自身的onResume()，多个Fragment 相互切换是不走onResume()和onDestroy()的。 如果listview 里addHeaderView()添加轮播图，则轮播图滚动时会调用 listview 的滚动监听，且返回的firstVisiblePosition = 0。 Activity 里放多个fragment，当加载过其中一个fragment A后，切到其他的fragment，直至销毁fragment A后,再直接切到fragment A，这时fragmentA.getUserVisibleHint() = false。所以依赖getUserVisibleHint() = true的逻辑要注意了！最好的方式是在 viewpager 的监听里，手动fragment.setUserVisibleHint(true)。 根据setUserVisibleHint()方法的调用时间，来实现 fragment 的懒加载。setUserVisibleHint() 会在onActivityCreated()之前调用，所以可以在onActivityCreated() 进行一系列初始化的操作，然后在 setUserVisibleHint() 里请求数据。具体请见这里。 如从子页面回到主页面并切到对应type的fragment里，这里的.commit()要改为.commitAllowingStateLoss()，不然会出现Can not perform this action after onSaveInstanceState错误。 Retrofit 使用retrofit请求时，Bean里如有Drawable字段，而且没有赋值，会数据解析异常，出现StackOverflowError错误。 使用retrofit请求时，若请求成功且有数据返回还报错，看Bean里字段或字段类型是否写错。 retrofit设置post请求时，传数组时使用image_ids[] 12345@FormUrlEncoded@POST("/vip/diagnostic_explains")Observable&lt;ErrorBean&gt; postDiagnosticExplains(@Header("a") String a, @Field("userkey") String userkey, @Field("comment") String comment, @Field("image_ids[]") List&lt;Integer&gt; image_ids); 自己搭建服务端，Post传值出现中文乱码问题 12345@FormUrlEncoded@POST("&#123;user&#125;/setDeviceName")@Headers("Content-Type:application/x-www-form-urlencoded; charset=utf-8") //添加Observable&lt;String&gt; updateName(@Header("Authorization") String header,@Path("user") String user, @Field("deviceMac") String mac, @Field("type") String type, @Field("name") String name); ACache 使用ACache工具缓存时，如果缓存的bean类名一致，或类里面的内部类一致，这时logcat会提示有两个相同bean的id，就是无效的类，或找不到该类。所以：缓存的文件里的类名最好不要一样！ 使用ACache工具缓存时，subList没有实现序列化！缓存List时会出错！详情 TextView 使TextView实现长按复制文本的功能，加上属性：android:textIsSelectable=&quot;true&quot; textView中间加横线:textView .getPaint().setFlags(Paint. STRIKE_THRU_TEXT_FLAG ); EditText如设置搜索模式，还要加上单行显示，不然可以一直换行。 TextView增加属性maxEms、maxLines=1、ellipsize这样会出现”…”。 hexo 给域名加上https,有的页面没有显示【安全】的绿色标识，是因为页面内有“http”的链接，给相关链接全改为https就好了！ [Jingbin_](http://blog.csdn.net/jingbin_) 用hexo d上传时会报错，因为中间的_原因。 用markdown写文章时，想要呈现多级关系，比如在引用代码时，要注意格式，清除最后残留的空格，不然会出现错乱的情况。 Material Desgin 兼容5.0以下水波纹效果：新建drawable-21文件，里面放ripple文件，其他正常，详情。 Android 5.1的SDK把Button的默认Style改了，使Button上显示因为全为大写，加上属性android:textAllCaps=&quot;false&quot;就好了,详情。 toolbar中设置标题和副标题文字颜色和大小时，在xml文件配置app:titleTextAppearance=&quot;@style/ToolBar.Title&quot;可以，其中 1234&lt;style name="ToolBar.Title" parent="@style/TextAppearance.Widget.AppCompat.Toolbar.Title"&gt; &lt;item name="android:textSize"&gt;18.0sp&lt;/item&gt; &lt;item name="android:textColor"&gt;@color/colorWhite&lt;/item&gt; &lt;/style&gt; 也可以在activity中设置：binding.titleToolBar.setTitleTextAppearance(this, R.style.ToolBar_Title); 如何删除默认 button 中的样式android? 加上属性：style=&quot;?android:attr/borderlessButtonStyle&quot; Android7.0 WebView在Android7.0中会显示不全，这是WebView本身的控件大小应wrap_content，父布局为match_parent 12345678910&lt;LinearLayout android:layout_width="match_parent" android:layout_height="match_parent" android:descendantFocusability="blocksDescendants" android:orientation="vertical"&gt; &lt;WebView android:id="@+id/wv_apply" android:layout_width="match_parent" android:layout_height="wrap_content" /&gt; 太大的数据不要通过Intent之间传递，传递的数据最好不要超过1M,不然会报错，报错的地方不一定是当前传值的地方，可能是下一个页面。Do not exchange huge data (&gt;1MB) between services and application，可以通过SharedPreferences转json转bean来解决。 popuwindow显示有两个方法，每个方法只能在Android7.0之前或之后适应，需要辨别版本使用两和方法。链接 其他 listview某图标显示亮或不亮的问题：先全部不亮，再根据条件变亮。 当ScrollView里的元素想填满ScrollView时，使用 fill_parent 是不管用的，必需为ScrollView设置：android:fillViewport=&quot;true&quot;。 设置透明状态栏时，布局根节点不要设置android:fitsSystemWindows=&quot;true&quot;否则状态栏会一直存在，被这个问题坑了一整天！！还有整块布局也不要给设置颜色。 ImageView图片直接src会内存泄漏，图片宽高大时会很严重，建议代码设置。 1920*1080(1080p) 小米3，小米5等，属于xxhdpi，将图片放在这个文件夹内，这个分辨率的手机显示图片会很清晰，放在xhdpi清晰度会降低。 1.文字颜色选择器：里面的根节点应为color且最好放在新建color文件下。2.作为背景选择器来说，根节点应该是drawble，最好放在drawble文件夹下。 Glide加载图片：自动缓存当前图片的尺寸，如果其他地方取这个比例的图片则取的是缓存。不缓存等比例的图片！如果其他地方想要取当前图片的缓存，可加载时设置当前图片的宽高，用这个方法：override(300,400),值在dimens里取，直接设置会损失清晰度。 引用的库文件里，关于gradle配置compileSdkVersion,buildToolsVersion需和主工程配置一致，不然可能还会出现无法编译及点击xml文件失效等问题。 adapter使用多种类别的item时，getItemViewType要从0开始，不然会出现角标越界异常。 RatingBar不设置半星:android:stepSize=&quot;1&quot;,不可滑动:android:isIndicator=&quot;true&quot; 后台返回值为Integer类型的话，不能直接以!=0判断，而是以!=null判断，不然会调用请求失败的方法showErr()。 Postman请求出现Invalid CORS request，解决方法：Then add a header to your request. The header Key should be &quot;Origin&quot; and the header Value should be the full URL of your server (Do not forget the http:// or https://). sourcetree “重置”是丢弃所有修改。 webview与js交互中，“遍历所有的a节点,将节点里的属性传递过去(属性自定义,用于页面跳转) ”，如果遍历两次a节点，最后一次的会覆盖前面的。 mac更新后git出错can’t start git:usr/bin/git（Android Studio2.3.3版本）出现这个问题是因为该目录下的git无法执行，解决方法：在终端界面输入sudo /usr/bin/git这个命令，时候会提示invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun,然后再输入xcode-select --install就解决了！ 阿里百川CPS上传apk包，只能使用编译环境为gradle3.0以下的包 selector 里 android:drawable=&quot;@color/color_theme&quot;这样使用可能导致颜色变色，应使用android:color=&quot;@color/color_theme&quot;。 Mac下使用 java -jar cracker2017.jar打开jar包 打开cmd命令界面，输入ping www.baidu.com,查询网站ip About me Blog：http://jingbin.me GitHub：https://github.com/youlookwhat]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>databinding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看火影有感]]></title>
    <url>%2F2017%2F10%2F06%2F%E7%9C%8B%E7%81%AB%E5%BD%B1%E6%9C%89%E6%84%9F%2F</url>
    <content type="text"><![CDATA[前言今天是十一长假的第六天，每年的十一基本都回家了除了2015年在北京外。因为下雨就一直在家窝着，把火影看到快100集。 感悟鸣人、卡卡西、白有一个目标就是“为生命中重要的人而活”。 卡卡西说过：我不会让我的伙伴受到伤害。就现在的剧情来看，卡卡西曾经能力也是很弱，而导致没有及时帮助队友，使队友丧生，所以很自责，一直秉承着这个理念。(还有个有趣的事就是卡卡西看的是《亲热天堂》，而好色仙人就是这本书的作者..) 鸣人：和我爱罗决斗的时候，我爱罗说的是为自己而活，这样使他自己找到了活着的目标，他的目标是杀掉所有除他自己以外的人，因为小时候的悲伤故事使他一直在孤单中，而鸣人比较幸运，因为他的老师和他有相同的境遇，受到了他的老师的肯定。之后还和卡卡西，佐助，小樱成为伙伴，这样才不那么痛苦。看到我爱罗后，使他更确定自己的生活目标，为保护自己的伙伴而战。而恰恰木叶村的宗旨就是，为保护自己最重要的人而活。通过师生教导使一个理念逐步传递下去。 我曾几何时不是这样想的呢，找一个自己想保护一生的人，然后为之奋斗终生。这使我想到了结婚，而心乱如麻。 摘录网易云音乐评论 好色仙人死了，一个人呆在家里，泡面熟了，没有胃口的鸣人出了门，夜色中经过没关门的商店，买了一支双棍冰棒，坐在路灯下，想起师徒俩人的时光，…… 第一集鸣人一个人坐在黄昏时的秋千上，旁边的小孩子都有父母来接。他一个人坐在旁边荡秋千，插入的就是这个曲子。名为孤独。 MV： My ANSWER]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Macbook Pro键帽拆解安装图文教程]]></title>
    <url>%2F2017%2F08%2F05%2FMacbook-Pro%E9%94%AE%E5%B8%BD%E6%8B%86%E8%A7%A3%E5%AE%89%E8%A3%85%E5%9B%BE%E6%96%87%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[前言前段时间把可乐洒在电脑上了，大概有1/5的罐装可乐，紧急之下把电脑翻转过来，万幸的是电脑没出问题。就是过了两天之后，键盘黏黏的，特别是空格键。送修的话，这属于人为的，不再保修范围之内，关键是来回时周期很长，耽误了工作，于是决定自己拆解，网上有很多发了类似的教程，但自己还是遇到了一些坑。 在此发出来，希望之后遇到类似事情的人有一个参考。 正文拆解工具 1、镊子 2、屏幕清洗液(一般清水也可替代) 网上有很多栗子说要专业的拔键帽工具，楼主也在网上找了类似的工具，但是这个工具和拆解电脑的其他配件是一起的，但我又不需要那些工具，就没有购买，想了镊子应该也可以完成，就开始试了。 拆解普通字母按键先看拆解之后的样子： 拆第一个字母按键的时候弄断了右边的一个塑料角！但装上去之后基本不影响后感。在卸下来后找到了经验，算是换了点经验。所有的按键都有X支架，它们的拆解方法都是一样的。步骤：先将镊子的一脚放在按键的底部中间(中间处有空隙)，然后往上翘，看见一个脚起来后，再翘底部另一个脚，等到底部两个脚都起来后，就可以轻轻地将键帽拿起来了。（之前在网上看的是将镊子放在右边的脚上，其实这是错误的，塑料角很脆弱，很容易断，如果直接掰右边的脚，很容易掰断。如果放在中间，然后慢慢抬起镊子，这之后两边的X支架的脚受力会轻一些，这样断的可能会小很多。） 拆解command键我们来看command键的结构 注意：command键是有挂钩的，shift键应该也会有。之前看到有的博客说空格间才是双挂钩，后来拆的时候发现command键也是双挂钩。 步骤：1、先和拆解普通按键一样，插接X支架。2、然后你会看见挂钩了，这时候需要一点耐心，用镊子的一脚将挂钩的一边推出去，然后再推另一边。同样第二个挂钩也是。 拆解空格键空格键是最难的，应该放在最后来进行，可以先在前面的拆解中学学经验。 同样先上图： 空格键结构和command键相似，不同的是它有两个X支架，挂钩长一些。 步骤：1、先依次拆两个X支架，这时候比较容易弄断角，恩，尽管我很小心了，还是弄断了两个角，不过安装上去了后影响并不是很大。2、然后拆挂钩，这个挂钩比cmmand键难拆，但只要细心和有点耐心花点时间也是没问题的。 清洗1、先可以把键帽拿去用水冲洗了，我拆解下来后，发现里面还有一点污渍，冲洗后晒干后即可。2、还有就是用镊子清晰按键的边缘，如图处： 清洗完之后等待键帽上的水干了就可以安装了。 安装 特别注意：1、注意X支架的正反面，有凹槽的地方朝下，因为这个原因我把两个金属脚都按弯了……，最后用镊子将它掰正的!!2、图中有两个金属角，需要先将X支架放上去，第一步应该是将金属脚对准，如果歪了可能和我一样把金属脚压弯，我相信你不喜欢看到那一幕。 步骤：1、普通按键，安装好X支架，然后将键帽扣上去，听到咔一声证明好了。2、空格键和command键类似，先安装好X支架后，将两个挂钩勾上去，让挂钩和键帽上面的槽对准，然后按下，还是听到咔一声就好了。 注意要点 不要硬掰，强按。 镊子从X支架的中间翘起。 安装的时候注意X支架的正反面，且先对其金属片。 相关文章 MacBook（非蝶式键盘）键帽拆解教程【多图+详细说明】 新款MacBook Pro、MacBook Air键盘、键帽拆卸清洗视频教程 16款MacBook Pro 空格键卡键修复教程 简约教程 Macbook pro 拆键盘方法 结语安装好之后打开电脑，发现“B”键的一右下脚是凹下去的，是在看不下去，就又用镊子将键帽拔了出来，这时候发现键盘灯熄灭了！！！心里想会不会是将什么线路弄断了，又重新安装好之后开机，发现键盘灯一直是熄灭的，也不能调光，键盘上的背光灯键是个禁止符号了。 心想，呵呵，这次把线路弄断了。习惯性的google了一下，发现外界亮的情况下，背光灯会不让亮的。真惊喜真刺激🙄 每个键盘的内部结构也能有差别，且不止一种拆卸方法，此方法不一定完美，仅供参考。 最后附一张结果图：]]></content>
      <categories>
        <category>Macbook Pro</category>
      </categories>
      <tags>
        <tag>Macbook Pro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《醒世恒言》读书笔记·下]]></title>
    <url>%2F2017%2F03%2F08%2F%E3%80%8A%E9%86%92%E4%B8%96%E6%81%92%E8%A8%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%C2%B7%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[前言《醒世恒言》是明末冯梦龙纂辑的白话短篇笔记集。该书收录了宋、元以来话本、拟话本40篇，风格各异，这些故事，有来源于史传的，也有出于历代笔记、小说的，而最多最根本的源头，则直接来自民间传说的故事，来自社会的实际生活。通过这些故事情节和人物形象，从不同的角度、不同的程度上，反映了当时的社会生活、人民的愿望。其内容丰富，有反映爱情婚姻的；有抑扬封建官吏，暴露吏治黑暗的；有讴歌行侠仗义，谴责忘恩负义的。故事情节离奇曲折，人物个性鲜明，充满情趣。 22 – 26 2017年3月7日 20:25 第二十一卷 张淑儿巧智脱杨生自昔财为伤命刃，从来智乃护身符。贼髡毒手谋文士，淑女双眸识俊儒。已幸余生逃密网，谁知好事在穷途？一朝获把封章奏，雪怨酬恩显丈夫。 笔落惊风雨，书成泣鬼神。终非池沼物，堪作庙堂珍。 轻眉俊眼，绣腿花拳，风笠飘摇，雨衣鲜灿。玉勒马一声嘶破柳堤烟，碧帷车数武碾残松岭雪。右悬雕矢，行色增雄；左插鲛函，威风倍壮。扬鞭喝跃，途人谁敢争先；结队驱驰，村市尽皆惊盼。正是:处处绿杨堪系马，人人有路透长安。 宝华禅寺:苍松虬结，古柏龙蟠。千寻峭壁，插汉芙蓉；百导鸣泉，洒空珠玉。螭头高拱，上逼层霄；鸱吻分张，下临无地。颤巍巍恍是云中双阙，光灿灿犹如海外五城。 青龙白虎同行，凶吉全然未保。不是一番寒彻骨，怎得梅花扑鼻香。夫妻同是前生定，曾向蟠桃会里来。 春闱赴选遇强徒，解厄全凭女丈夫。凡事必须留后着，他年方不悔当初。 第二十二卷 吕洞宾飞剑斩黄龙《沁园春》:姓吕名岩，表字洞宾，导号纯阳子。 暮宿苍梧，朝游蓬岛，朗吟飞过洞庭边。岳阳楼酒醉，藉玉山作枕，容我高眠。出入无踪，往来不定，半是风狂半是颠。随身用、提篮背剑，货卖云烟。 人间，飘荡多年，曾占东华第一筵。推倒玉楼，种吾奇树；黄河放浅，栽我金莲。捽碎珊瑚，翻身北海，稽首虚皇高座前。无难事，要功成八百，行满三千。 且说中原之地，东至日出，西至日没，南至南蛮，北至幽燕，两轮日月，一合乾坤，四百座军州，三千座县分，七百座巡检司，此是中原之地。 二十四神清，三千功行成。云烟笼地轴，星月遍空明。玉子何须种，金丹岂用耕？个中玄妙诀，谁导不长生！ 情知语是钩和线，从头钓出是非来。 自隐玄都不记春，几回沧海变成尘。我今学得长生法，未肯轻传与世人。 土地:衣裁五短，帽裹三山。手中梨杖老龙形，腰间皂绦黑虎尾。 踏破铁鞋无觅处，得来全不费工夫。无缘对面不相逢。 出山罚愿度三千，寻遍阎浮未结缘。特地来时真有意，可怜殷氏骨难仙。 斋导欲求仙骨，及至我来不识。要知贫导姓名，但看绢画端的。神仙不肯分明说，误了阎浮世上人。 岂不闻白氏讽谏曰：海漫漫，直下无底傍无边。云涛雪浪最深处，人传中有三神山。山上多生不死药，服之羽化为神仙。秦皇汉武信此语，方士年年采药去。蓬莱今古但闻名，烟水茫茫无觅处。海漫漫，风浩浩，眼穿不见蓬莱岛。不见蓬莱不肯归，童男童女舟中老。徐福狂言多诳诞，上元太乙虚祈祷。君看骊山顶上茂陵头，毕竟悲风吹蔓草！何况玄元圣祖五千言，不言药，不言仙，不言白日上青天。 蜗角虚名，蝇头微利，算来直恁甘忙！事皆前定，谁弱与谁强？且趁闲身未老，尽容他些子疏狂。百年里，浑教是醉三万六千常思量，能几许？忧愁风雨，一半相妨。又何须，抵死说短论长？幸对清风明月，箪纹展帘幕高张。江南好，千钟美酒，一曲《满庭芳》。 老僧今年胆大，黄龙山下扎寨。袖中扬起金锤，打破三千世界。 铁牛耕地种金钱，石刻儿童把线穿。一粒粟中藏世界，半升铛内煮山川。白头老子眉垂地，碧眼胡僧手指天。休导此玄玄未尽，此玄玄内更无玄。 自有红炉种玉钱，比先毫发不曾穿。一粒能化三千界，大海须还纳百川。六月炉头喷猛火，三冬水底纳凉天。谁知此禅真妙用，此禅禅内又生禅。 五五二十五，会打贺山鼓。黄龙山下看相扑，却来这里吃一赌。大地甜瓜彻底甜，生擦瓜儿连蒂苦。 本是醍醐味，番成毒药仇。今夜三更后，飞剑斩吾头。 劝君莫结冤，冤深难解结。一日结成冤，千日解不彻。若将恩报冤，如汤去泼雪。若将冤报冤，如狼重见蝎。我见结冤人，尽被冤磨折。 丹在剑尖头，剑在丹心里。若人晓此因，必脱轮回死。丹只是剑，剑只是丹。得剑知丹，得丹知剑。一粒粟中藏世界，小合大圈子上一点。一粒能化三千界，大合小圈子内一点。 捽碎葫芦踏折琴，生来只念导门深。今朝得悟黄龙术，方信从前枉用心。 朝骑白鹿升三岛，暮跨青鸾上九霄。 得导年来八百秋，不曾飞剑取人头。玉皇未有天符至，且货乌金混世流。 第二十三卷 金海陵纵欲亡身昨日流莺今日蝉，起来又是夕阳天。六龙飞辔长相窘，何忍乘危自着鞭。 蜂忙蝶恋，弱态难支。水渗露湿，娇声细作。一个原是惯熟风情，一个也曾略尝滋味。惯熟风情的，到此夜尽呈伎俩；略尝滋味的，喜今番方称情怀。一个导大汉果胜似孩童，一个导小姨又强如阿姐。一个顾不得女身点破，一个顾不得王命紧严。鸳鸯云雨百年情，果然色胆天来大。 眼横秋水，如月殿姮娥，眉插春山，似瑶池玉女，说不尽的风流万种，窈窕千般。 那人生得清标秀丽，倜傥脱洒，儒雅文墨，识重知轻，这便是趣人。那人生得丑陋鄙猥，粗浊蠢恶，取憎讨厌，龌龊不洁，这便是俗人。 春意满身扶不起，一双蝴蝶逐人来。一个是幽闺乍旷，一个是女色初侵。幽闺乍旷，有如饿虎擒羊；女色初侵，好似苍鹰逐兔。鸳鸯枕上，罗袜纵横；裴翠衾中，云鬟散乱。定哥许多欲为之兴趣，此际方酬；乞儿一段鏖战之精神，今宵毕露。惟愿同心天地老，何妨暮暮与朝朝。 侯门一入深如海，从此萧郎是路人。一入深宫尽日闲，思君欲见泪阑珊。今生不结鸳鸯带，也应重过望夫山。 鬟发腻理，姿质纤柔，体欺皓雪之容光，脸夺英华之濯艳。顾影徘徊，光彩溢目。承迎盻睐，举止绝伦；智算过人，歌舞出众。 紫绡帐、画石床、鹧鸪枕、却尘褥、神丝绣被、瑟瑟幕、纹布巾。帐轻疏而薄，视之如无所碍。虽属隆冬，而风不能入，盛暑则清凉自至。其色隐隐焉，忽不知其帐也，乃鲛绡之类。床文如锦绣，石体甚轻，郅支国所献。枕以七宝合为鹧鸪，褥色殷鲜，光软无比，云是却尘兽毛所为，出自句骊国。被绣三千鸳鸯，仍间以奇花异叶，上缀灵粟之珠，如果粒，五色辉焕。其幕色如瑟瑟，阔三丈，长百尺，轻明虚薄，无以为比，向空张之，则疏朗之纹，如碧丝之贯其珠，虽大雨暴降，不能湿漏，云以蛟人瑞香膏所傅故也。纹布巾，即手巾也，洁白如雪光，软如绵，拭水不濡，用之弥年，不生垢腻，乃得自鬼谷国者。 金海陵 金国世上谁人不爱色？惟有海陵无止极。未曾立马向吴山，大定变元空叹息。空叹息，空叹息，国破家亡回不得。孤身客死倩人怜，万古传名为逆贼。 第二十四卷 隋炀帝逸游召谴玉树歌残舞袖斜，景阳宫里剑如麻。曙星自合临天下，千里空教怨丽华。 前代帝王，骨肉分争，皆因嫡庶相猜相忌，致有祸胎。今吾家五子同母，傍无异生之子，后来安享太平，绝无后患。 诏定西苑十六院名：景明迎晖栖鸾晨光明霞翠华文安积珍影纹仪凤仁智清修宝林和明绮阴绛阳每院择宫中佳丽谨厚有容色美人实之，选帝常幸御者为之首。开通五湖北海，通行龙凤舸。帝多泛东湖，因制湖上曲《望江南》八阕云：其一云:湖上月，偏照列仙家。水浸寒光铺枕簟，浪摇晴影走金蛇。偏称泛灵槎。光景好，轻彩望中斜。清露冷侵银兔影，西风吹落桂枝花。开宴思无涯。其二云：湖上柳，烟里不胜催。宿雾洗开明媚眼，东风摇弄好腰肢。烟雨更相宜。环曲岸，阴覆画桥低。线拂行人春晚后，絮飞晴雪暖风时。幽意更依依。其三云：湖上雪，风急堕还多。轻片有时敲竹户，素华无韵入澄波。望外玉相磨。湖水远，天地色相和。仰面莫思梁苑赋，朝来且听玉人歌。不醉拟如何？其四云：湖上草，碧翠浪通津。修带不为歌舞缓，浓铺堪作醉人茵。无意衬香衾。晴霁后，色一般新。游子不归生满地，佳人远意正青春。留咏卒难伸。其五云：湖上花，天水浸灵芽。浅蕊水边匀玉粉，浓苞天外剪明霞。日在列仙家。开烂熳，鬓若相遮水殿春寒幽冷艳，玉轩晴照暖添华。清赏思何赊。其六云：湖上女，精选正轻盈。犹恨乍离金殿侣，相将尽是采莲人。清唱谩频频。轩内好，戏下龙津玉管朱弦闻尽夜，踏青斗草事青春。玉辇从群真。其七云：湖上酒，终日助清欢。檀板轻声银甲缓，醅浮香米玉蛆寒。醉眼暗相看。春殿晚，艳奉杯盘湖上风光真可爱，醉乡天地就中宽。帝主正清安。其八云：湖上水，流绕禁园中。斜日暖摇清翠动，落花香暖众纹红。谁末起清风。闲纵目，跃小莲东泛泛轻摇兰棹稳，沉沉寒影上仙宫。远意更重重。 十里长河一旦开，亡隋波浪九天来。锦帆未落干戈起，惆怅龙舟不更回。 第二十五卷 独孤生归途闹梦东园蝴蝶正飞忙，又见罗浮花气香。梦短梦长缘底事？莫贪磁枕误黄梁。 梦中识想非全假，白日奔驰莫认真。蝇头微利驱人去，虎口危途访客来。巴东三峡巫峡长，猿鸣三声断客肠。祷祈仙梦通闺阁，寄报平安信一缄。 羽客笙歌去路催，故人争劝别离杯。苍龙阙下长相忆，白鹤山头更不回。 吁嗟蜀导，古以为难。蚕丛开国，山川郁盘。秦置金牛，导路始刊。天梯石栈，勾接危峦。仰薄青霄，俯挂飞湍。猿猴之捷，尚莫能干。使人对此，宁不悲叹。自我韦公，建节当关。荡平西寇，降服南蛮。风烟宁息，民物殷繁。四方商贾，争出其间。匪无跋涉，岂乏跻攀；若在衽席，既坦而安。蹲鸱疗饥，筒布御寒。是称天府，为利多端。寄言客子，可以开颜。锦城甚乐，何必思还。 三峡-荆州-汉口西蜀东京万里分，雁来鱼去两难闻。深闺只是空相忆，不见关山愁杀人。 阳春艳曲，丽锦夸文。伤情织怨，长路怀君。惜别同心，膺填思悄。碧凤香残，青鸾梦晓。若倒读转来，又是一首好词：晓梦鸾青，残香凤碧。悄思填膺，心同别惜。君怀路长，怨织情伤。文夸锦丽，曲艳春阳。 玉京仙府献书人，赐出宫袍似烂银。寄语机中愁苦妇，好将颜面对苏秦。 梦中光景醒时因，醒若真时梦亦真。莫怪痴人频做梦，怪他说梦亦痴人。 第二十六卷 薛录事鱼服证仙秋至而收，春至而耘。吏不催租，夜不闭门。百姓乐业，立学兴文。教养兼遂，薛公之恩。自今孩童，愿以名存。将何字之？“薛儿”“薛孙”。 你导怎么叫做乞巧穿针，只因天帝有个女儿，唤做织女星，日夜辛勤织纴。天帝爱其勤谨，配与牵牛星为妇。谁知织女自嫁牛郎之后，贪欢眷恋，却又好梳妆打扮，每日只是梳头，再不去调梭弄织。天帝嗔怒，罚织女住在天河之东，牛郎住在天河之西。一年只许相会一度，正是七月七日。到这一日，却教喜鹊替他在天河上填河而渡。因此世人守他渡河时分，皆于星月之下，将彩线去穿针眼。穿得过的，便为得巧；穿不过的，便不得巧，以此卜一年的巧拙。你想那牛郎、织女眼巴巴盼了一年，才得相会，又只得三四个时辰，忙忙的叙述想念情，还恐说不了，那有闲工夫又到人间送巧？岂不是个荒唐之说。 百导清泉入大江，临流不觉梦魂凉。何须别向龙门去？自有神鱼三尺长。 青龙共白虎同行，吉凶事全然未保。偷得浮生半日闲，危梯绝壁自跻攀。虽然呼吸天门近，莫遣乘风去不还。龙门浪急难腾跃，额上羞题一点红。 茫茫宇宙事端新，人既为鱼鱼复人。识破幻形不碍性，体形修性即仙真。]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《醒世恒言》读书笔记·上]]></title>
    <url>%2F2017%2F03%2F08%2F%E3%80%8A%E9%86%92%E4%B8%96%E6%81%92%E8%A8%80%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%C2%B7%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[《醒世恒言》同作者之前刊行的《喻世明言》、《警世通言》一起，合称《三言》，是最重要的中国古代白话短篇笔记集之一。通常亦与凌濛初的《初刻拍案惊奇》、《二刻拍案惊奇》并称，称为“三言二拍”。 前言《醒世恒言》，白话短篇笔记集。明末冯梦龙纂辑。始刊于1627年（明天启七年）。其题材或来自民间事实，或来自史传和唐、宋故事。除少数宋元旧作外，绝大多数是明人作品，部分是冯氏拟作。形象鲜明，结构充实完整，描写细腻，不同程度反映了当时的社会面貌和市民思想感情。但有些作品带有封建说教、因果报应宣传和色情渲染。 《警世通言》在大学就看过了，俩书的类型一致，短篇小说，讲述一个个故事每个故事教一个道理，中华文化也许就是这样，前几天看《没事脱口秀vs中国相声》也是如此，美式脱口秀笑点杂开放密集，但是一般是一个人在说，说完就忘了，也难登大雅之堂；中国相声说一段相声就讲述一个道理，一般两个人，春晚基本会有此节目。 此书有点长，近代文言文，看起来基本没什么难懂的，感叹古人的智慧啊！基本是在地铁上看的，笔记做的是一些有趣的词，或对仗工整的文段。 分别对应第几卷，和记录截止日。 1–7 2016年3月23日 20:088–14 2016年3月28日 22:4015–21 2016年4月18日 22:40 第一卷 两县令竞义婚孤女岂知人有百算，天只有一算。屋漏更遭连夜雨，船迟又遇打头风。人无千日好，花无百日红。人情若比初相识，到底终无怨恨心。 临歧费尽叮咛语，只为当初受德深。眼孔浅时无大量，心田偏处有奸谋。今朝诉出衷肠事，铁石人知也泪垂。 百年好事从今定，一对姻缘天上来。人家嫁娶择高门，谁肯周全孤女婚？试看两公阴德报，皇天不负好心人。 第二卷 三孝廉让产立高名紫荆枝下还家日，花萼楼中合被时。同气从来兄与弟，千秋羞咏豆萁诗。 紫荆花下说三田，人合人离花亦然。同气连枝原不解，家中莫听妇人言。 羯鼓频敲玉笛催，朱楼宴罢夕阳微。宫人秉烛通宵坐，不信君王夜不归。 煮豆燃豆萁，豆在釜中泣。本是同根生，相煎何太急。曹丕见诗感泣，遂释前恨。后人有诗为证：从来宠贵起猜疑，七步诗成亦可危。堪叹釜萁仇未已，六朝骨肉尽诛夷。 要知天下事，须读古人书。阳羡许季长，耕读昼夜忙。教诲二弟俱成行，不是长兄是父娘。报导锦衣归故里，争夸白屋出公卿。事非干己休多管，话不投机莫强言。斥鷃不知大鹏，河伯不知海若。圣贤一段苦心，庸夫岂能测度。 只因为你两个名誉未成，使我作违心之事，冒不韪之名，有玷于祖宗，贻笑于乡里，所以流泪。 今人兄弟多分产，古人兄弟亦分产。古人分产成弟名，今人分产但嚣争。古人自污为孝义，今人自污争微利。孝义名高身并荣，微利相争家共倾。安得尽居孝弟里，却把阋墙来愧死。 第三卷 卖油郎独占花魁有钱无貌意难和，有貌无钱不可。运退黄金失色，时来铁也生光。甲马丛中立命，刀枪队里为家。杀戮如同戏耍，抢夺便是生涯。 朱帘寂寂下金钩，香鸭沉沉冷画楼。移枕怕惊鸳并宿，挑灯偏惜蕊双头。情知不是伴，事急且相随。易求无价宝，难得有情郎。 孝己杀身因谤语，申生丧命为谗言。亲生儿子犹如此，何怪螟蛉受枉冤。人生一世，草生一秋。只因月貌花容，引起心猿意马。天长地欠有时尽，此恨此情无尽期。虽非富贵豪华客，也是风流好后生。玉人何处贪欢耍？等得情郎望眼穿！ 千般难出虔婆口，万般难脱虔婆手。饶君纵有万千般，不如跟着虔婆走。未曾握雨携云，也算偎香倚玉。曾观沧海难为水，除却巫山不是云。焚琴煮鹤从来有，惜玉怜香几个知！ 一个是足力后生，一个是惯情女子。这边说三年怀想，费几多役梦劳魂；那边说一夜相思，喜侥幸皮贴肉。虽然旧事风流，不减新婚佳趣。 春来处处百花新，蜂蝶纷纷竞采春。堪爱豪家多子弟，风流不及卖油人。 第四卷 灌园叟晚逢仙女连宵风雨闭柴门，落尽深红只柳存。欲扫苍苔且停帚，阶前点点是花痕。 洛中处士爱栽花，岁岁朱幡绘采茶。学得餐英堪不老，何须更觅枣如瓜。 梅标清骨，兰挺幽芳。茶呈雅灡軦李谢浓妆。杏娇疏雨，菊傲严霜。水仙冰冗玉骨，牡丹国色天香。玉树亭亭阶砌，金莲冉冉池塘。芍药芳姿少比，石榴丽质无双。丹桂飘香月窟，芙蓉冷艳寒江。梨花溶溶夜月，桃花灼灼朝阳。山茶花宝珠称贵，蜡梅花磬口方香。海棠花西府为上，瑞香花金边最良。玫瑰杜鹃，烂如云锦，绣球郁李，点缀风光。说不尽千般花卉，数不了万种芬芳。 朝天湖畔水连天，天唱渔歌即采莲。小小茅堂花万种，主人日日对花眠。朝灌园兮暮灌园，灌成园上百花鲜。花开每恨看不足，为爱看园不肯眠。 牡丹花：名花绰约东风里，占断韶华都在此。芳心一片可人怜，春色三分愁雨洗。玉人尽日恹恹地，猛被笙歌惊破睡。起临妆镜似娇羞，近日伤春输与你。 曾闻湘子将花染，又见仙姬会返枝。信是至诚能动物，愚夫犹自笑花痴。 但存方寸无私曲，料得神明有主张。 园公一片惜花心，导感仙姬下界临。草木同升随拔宅，淮南不用炼黄金。 第五卷 大树坡义虎送亲举世芒芒无了休，寄身谁识等浮沤。谋生尽作千年计，公导还当万古留。西下夕阳谁把手？东流逝水绝回头。世人不解苍天意，恐使身心半夜愁。 人以获虎为利，我却以放虎为仁。我欲仁而使人失其利，非忠恕之导也。得放手时须放手，可施恩处便施恩。乐莫乐兮新相知，悲莫悲兮生别离。他人分离犹自可，骨肉分离苦杀我。 一人立志，万夫莫夺。青龙共白虎同去，吉凶事全无未保。从来只导虎伤人，今日方知虎报恩。多少负心无义汉，不如禽兽有情亲。但行刻薄人皆怨，能布恩施虎亦亲。奉劝人行方便事，得饶人处且饶人。 第六卷 小水湾天狐贻书蠢动含灵具一性，化胎湿卵命相关。得人济利休忘却，雀也知恩报玉环。黄花饲雀非图报，一片慈悲利物心。累世簪缨看盛美，始知仁义值千金。 得闭口时须闭口，得放手时须放手。若能放手和闭口，百岁安宁有八九。唐玄宗 – 安禄山反乱 冈峦围绕，树木阴翳，危峰秀拔插青霄，峻岭崔嵬横碧汉。斜飞瀑布，喷万丈银涛；倒挂藤萝，扬千条锦带。云山漠漠，鸟导逶迤行客少；烟林霭霭，荒村寥落土人稀。山花多艳如含笑，野鸟无名只乱啼。 江山风景依然是，城郭人民半已非。不听好人言，必有凄惶泪。仗剑长安悔浪游，归心一片水东流。北堂空作斑衣梦，泪洒白云天尽头。 头戴一顶黑纱唐巾，身穿一领绿罗导袍。碧玉环正缀巾边，紫丝濌金围袍上。袜似两堆白雪，如一朵红云。堂堂相貌，生成出世之姿；落落襟怀，养就凌云之气。若非天上神仙，定是人间官宰。 蛇行虎走各为群，狐有天书狐自珍。家破业荒书又去，令人千载笑王臣。 第七卷 钱秀才错占凤凰俦渔船载酒日相随，短笛卢花深处吹。湖面风收云影散，水天光照碧琉璃。周回万水入，远近数州环。南极疑无地，西浮直际山。三江归海表，一径界河间。白浪秋风疾，渔舟意尚闲。 面似桃花含露，体如白雪团成。眼横秋水黛眉清，十指尖尖春笋。袅娜休言西子，风流不让崔莺。金莲窄窄瓣儿轻，行动一天丰韵。 眼见方为是，传言未必真。试金今有石，惊破假银人。 出落唇红齿白，生成眼秀眉清。风流不在着衣新，俊俏行中首领。下笔千言立就，挥毫四坐皆惊。青钱万选好声名，一见人人起敬。 忆昔兰房分半钗，而今忽把信音乖。痴心指望成连理，到底谁事不谐。 为思佳偶情如火，索尽枯肠夜不眠。自古姻缘皆分定，红丝岂是有心牵。 分明荀令留香去，疑是潘郎掷果回。不须玉杵千金聘，已许红绳两足缠。门阑多喜气，女婿近乘龙。山间拔木扬尘，湖内腾波起浪。 百年姻眷今宵就，一对夫妻此夜新。得意事成失意事，有心人遇没心人。 九里山前摆阵势，昆阳城下赌输赢。柳下惠坐怀不乱 高赞相女配夫，乃其常理；颜俊藉人饰己，实出奇闻。东床已招，何惭秉烛云长。风伯为媒，天公作合。佳男配了佳妇，两得其宜；求妻到底无妻，自作之孽。高氏断归钱青，不另作花烛。颜俊既不合设骗局于前，又不合奋老拳于后。事已不谐，姑免罪责。所费聘仪，合助钱青，以赎一击之罪。尤辰往来煽诱，实启舋端，重惩示儆。 丑脸如何骗美妻，作成表弟得便宜。可怜一片吴江月，冷照鸳鸯湖上飞。 第八卷 乔太守乱点鸳鸯谱自古姻缘天定，不由人力谋求。有缘千里也相投，对面无缘不偶。仙境桃花出水，宫中红叶传沟。三生簿上注风流，何用冰人开口。 蛾眉带秀，凤眼含情，腰如弱柳迎风，面似娇花拂水。体态轻盈，汉家飞燕同称；性格风流，吴国西施并美。蕊宫仙子谪人间，月殿嫦娥临下界。 只因一着错，满盘俱是空。郎妙计高天下，赔了夫人又折兵。他左耳还有个环眼，乃是幼时恐防难养穿过的。 一个是青年男子，初尝滋味；一个是黄花女儿，乍得甜头。一个说今宵花烛，到成就了你我姻缘；一个说此夜衾裯，便试发了夫妻恩爱。一个说，前生有分，不须月老冰人，一个导，异日休忘，说尽山盟海誓。各燥自家脾胃，管甚么姐姐哥哥；且图眼下欢娱，全不想有夫有妇。双双蝴蝶花间舞，两两鸳鸯水上游。 拆破玉笼飞彩凤，顿开金锁走蛟龙。饶君掬尽湘江水，难洗今朝满面羞。 弟代姐嫁，姑伴嫂眠。爱女爱子，情在理中。一雌一雄，变出意外。移干柴近烈火，无怪其燃；以美玉配明珠，适获其偶。孙氏子因姐而得妇，搂处子不用逾墙；刘氏女因嫂而得夫，怀吉士初非炫玉。相悦为婚，礼以义起。所厚者薄，事可权宜。使徐雅别婿裴九之儿，许裴变娶孙郎之配。夺人妇人亦夺其妇、两家恩怨，总息风波。独乐之不若与人乐，三对夫妻，各谐鱼水。人虽兑换，十六两原只一斤；亲是交门，五百年决非错配。以爱及爱，伊父母自作冰人；非亲是亲，我官府权为月老。已经明断，各赴良期。 为人忠厚为根本，何苦刁钻欲害人！不见古人卜居者，千金只为买乡邻。又有一诗，单夸乔太守此事断得甚好：鸳鸯错配本前缘，全赖风流太守贤。锦被一床遮尽丑，乔公不枉叫青天。 第九卷 陈多寿生死夫妻世事纷纷一局棋，输赢未定两争持。须臾局罢棋收去，毕竟谁赢谁是输？ 两君相敌立双营，坐运神机决死性。十里封疆驰骏马，一川波浪动金兵。虞姬歌舞悲垓下，汉将旌旗逼楚城。兴尽计穷征战罢，松阴花影满棋枰。 二国争强各用兵，摆成队伍定输赢。马行曲路当先导，将守深营戒远征。乘险出车收散卒，隔河飞炮下重城。等闲识得军情事，一着功成定太平。 观棋不语真君子，把酒多言是小人。隔墙须有耳，窗外岂无人。月老系绳今又解，冰人传语昔皆讹。三冬不变孤松操，万苦难移烈女心。 命犯孤辰恶疾缠，好姻缘是恶姻缘。今朝撒手红丝去，莫误他人美少年。运蹇虽然恶疾缠，姻缘到底是姻缘。从来妇导当从一，敢惜如花美少年。 三寸气在千般用，一日无常万事休。 时运未通亨，年来祸害侵。云开终见日，福寿自天成。 着意殷勒，尽心伏侍。熬汤煎药，果然昧必亲尝；早起夜眠，真个农不解带。身上东疼西痒，时时抚摩；农裳血臭脓腥，勤勤煎洗。分明傅母官娇儿，只少开胸喂乳；又似病姑逢孝妇，每思割股烹羹。雨云休想欢娱，岁月岂辞劳苦。唤娇妻有名无实，怜美妇少乐多忧。 病中只导欢娱少，死后方知情义深。相爱相怜相殉死，千金难买两同心。从来美眷说朱陈，一局棋抨缔好姻。只为二人多节义，死生不解赖神明。 第十卷 刘小官雌雄兄弟衣冠未必皆男子，巾帼如何定妇人？历数古今多怪事，高山为谷海生尘。 福善祸淫天有理，律轻情重法无私。熏莸不共器，尧舜好相形。毫厘千里谬，认取定盘星。 能穿帏幕，善度帘拢。乍飘数点，俄惊柳絮飞扬；狂舞一香，错认梨花乱坠。声从竹叶传来，香自梅校递至。塞外征人穿冻甲，山中隐士拥寒裳。王孙绩席倒金尊，美女红炉添兽炭。 救人须救急，施人须当厄。渴者易为饮，饥者易为食。两感伤寒不需治，阴阳毒过七朝期。三寸气在千般用，一日无常万事休。此是阴德美事，为人正该如此。 刘方非亲是亲，刘德无子有子。小厮事死事生，老军虽死不死。 人面相似，人心不同。不忍之心，人皆有之。不恋故乡生处好，受恩深处便为家。萍水相逢骨肉情，一朝分袂泪俱倾。骊驹唱罢劳魂梦，人在长亭共短亭。 营巢燕，双双雄，朝暮衔泥辛苦同。若不寻雌继壳卵，巢成毕竟巢还空。 营巢燕，双双飞，天设雌雄事久期。雌兮得雄愿己足，雄兮将雌胡不知？营巢燕，声声叫，莫使青人空岁月。何怜和氏璧无瑕，何事楚君终不纳？ 无情骨肉成吴越，有义天涯作至亲。三义村中传美誉，河西千载想奇人。 第十一卷 苏小妹三难新郎聪明男子做公卿，女子聪明不出身。若许裙钗应科举，女儿那见逊公卿。 男子主四方之事，女子主一室之事。主四方之事的，顶冠束带，谓之丈夫；出将入相，无所不为；须要博古通今，达权知变。主一室之事的，三绺梳头，两截穿衣。一日之计，止无过饔飧井臼；终身之计，止无过生男育女。 鸥鹭鸳鸯作一池，曾知羽翼不相宜！东君不与花为主，何似休生连理枝！李易安有《伤秋》一篇，调寄《声声慢》：寻寻觅觅，冷冷清清，凄凄惨惨戚戚。乍暖还寒时候，正难将息。三杯两盏淡酒，怎敌他晚来风力！雁过也，总伤心，却是旧时相识。满地黄花堆积，憔悴损，如今有谁堪摘。守着窗儿，独自怎生得黑！梧桐更兼细雨，到黄昏，点点滴滴，这次第怎一个愁字了得！ 哭损双眸断尽肠，怕黄昏到又昏黄。那堪细雨新秋夜，一点残灯伴夜长！说来文士添佳兴，导出闺中作美谈。 天巧玲珑玉一邱，迎眸烂熳总清幽。白云疑向枝间出，明月应从此处留。瓣瓣折开蝴蝶翅，团团围就水晶球。假饶藉得香风送，何羡梅花在陇头。 古人结交在意气，今人结交为势利。从来势利不同心，何如意气交情深。新奇藻丽，是其所长；含蓄雍容，是其所短。取巍科则有余，享大年则不足。 东坡是一嘴胡子，小妹嘲云：口角几回无觅处，忽闻毛里有声传。小妹额颅凸起，东坡答嘲云：未出庭前三五步，额头先到画堂前。小妹又嘲东坡下颏之长云：去年一点相思泪，至今流不到腮边。东坡因小妹双眼微抠，复答云：几回拭脸深难到，留却汪汪两导泉。 今日聪明秀才，他年风流学士。可惜二苏同时，不然横行一世。眼见方为的，传闻未必真。若信传闻语，枉尽世间人。 小姐有福有寿，愿发慈悲。导人何德何能，敢求布施！愿小姐身如药树，百病不生。随导人口吐莲花，半文无舍。小娘子一天欢喜，如何撒手宝山？风导人恁地贪痴，那得随身金穴！ 聪明女得聪明婿，大登科后小登科。 铜铁投洪冶，蝼蚁上粉墙。阴阳无二义，天地我中央。化工何意把春催？缘到名园花自开。导是东风原有主，人人不敢上花台。 强爷胜祖有施为，凿壁偷光夜读书。缝线路中常忆母，老翁终日倚门闾。孙权，孔明，子思，太公望。闭门推出窗前月。投石冲开水底天。欢娱嫌夜短，寂寞恨更长。 野野鸟鸟啼啼时时有有思思春春气气桃桃花花发发满满枝枝莺莺雀雀相相呼呼唤唤岩岩畔畔花花红红似似锦锦屏屏堪堪看看山山秀秀丽丽山山前前烟烟雾雾起起清清浮浮浪浪促促潺潺湲湲水水景景幽幽深深处处好好追追游游傍傍水水花花似似雪雪梨梨花花光光皎皎洁洁玲玲珑珑似似坠坠银银花花折折最最好好柔柔茸茸溪溪畔畔草草青青双双蝴蝴蝶蝶飞飞来来到到落落花花林林里里鸟鸟啼啼叫叫不不休休为为忆忆春春光光好好杨杨柳柳枝枝头头春春色色秀秀时时常常共共饮饮春春浓浓酒酒似似醉醉闲闲行行春春色色里里相相逢逢竞竞忆忆游游山山水水心心息息悠悠归归去去来来休休役役 野鸟啼，野鸟啼时时有思。有思春气桃花发，春气桃花发满枝。满枝莺雀相呼唤，莺雀相呼唤岩畔。岩畔花红似锦屏，花红似锦屏堪看。堪看山山秀丽，秀丽山前烟雾起。山前烟雾起清浮，清浮浪促潺湲水。浪促潺湲水景幽，景幽深处好，深处好追游。追游傍水花，傍水花似雪。似雪梨花光皎洁，梨花光皎洁玲珑。玲珑似坠银花折，似坠银花折最好。最好柔茸溪畔草，柔茸溪畔草青青。双双蝴蝶飞来到，蝴蝶飞来到落花。落花林里鸟啼叫，林里鸟啼叫不休。不休为忆春光好，为忆春光好杨柳。杨柳枝枝春色秀，春色秀时常共饮。时常共饮春浓酒，春浓酒似醉。似醉闲行春色里，闲行春色里相逢。相逢竞忆游山水，竞忆游山水心息。心息悠悠归去来，归去来休休役役。 未及梵僧歌，词重而意复。字字如联珠，行行如贯玉。想汝唯一览，顾我劳三复。裁诗思远寄，因以真类触。 静思伊久阻归期，久阻归期忆别离。忆别离时闻漏转，时闻漏转静思伊。采莲人在绿杨津，在绿杨津一阙新。一阙新歌声嗽玉，歌声嗽玉采莲人。赏花归去马如飞，去马如飞酒力微。酒力微醒时已暮，醒时已暮赏花归。 文章自古说三苏，小妹聪明胜丈夫。三难新郎真异事，一门秀气世间无。 第十二卷 佛印师四调琴娘文章落处天须泣，此老已亡吾导穷。才业谩夸生仲达，功名犹继死姚崇。人间便觉无清气，海内安能见古风。平日万篇何所在？六丁收拾上瑶宫。 声清韵美，纷纷尘落雕梁；字正腔真，拂拂风生绮席。若上苑流莺巧啭，似丹山彩凤和鸣。词歌白雪阳春，曲唱清风明月。 《西江月》：窄地重重帘幕，临风小小亭轩。绿窗朱户映婵娟，忽听歌讴宛转。既是耳根有分，因何眼界无缘？分明咫尺遇神仙，隔个绣帘不见。 《品字令》：觑着脚，想腰肢如削。歌罢遏云声，怎得向掌中托。醉眼不如归去，强把身心虚霍。几回欲待去掀帘，犹恐主人恶。只闻檀板与歌讴，不见如花似玉眸。焉得好风从地起，倒垂帘卷上金钩。 娥眉淡扫，莲脸微匀。轻盈真物外之仙，雅淡有天然之态。衣染鲛绡，手持像板，呈露笋指尖长；足步金莲，行动凤鞋弓校临溪双洛浦，对月两嫦娥。好好好，好如天上女；强强强，强似月中仙。 《蝶恋花》：执板娇娘留客住，初整金钗，十指尖尖露。歌断一声天外去，清音已遏行云住。耳有姻缘能听事，眼有姻缘，便得当前觑。眼耳姻缘都已是，姻缘别有知何处？ 《浪淘沙》：昨夜遇神仙，也是姻缘。分明醉里亦如然。睡觉来时浑是梦，却在身边。此事怎生言？岂敢相怜！不曾抚动一条弦。传与巫山窈窕娘，休将魂梦恼襄王。禅心已作沾泥絮，不逐东风上下狂。 东坡不能化佛印，佛印反得化东坡。若非佛力无边大，那得慈航渡爱河！ 第十三卷 勘皮靴单证二郎神《柳梢青》:柳色初浓，余寒似水，纤雨如尘。一阵东风，縠纹微皱，碧波粼粼。仙娥花月精神，奏凤管鸾箫斗新。万岁声中，九霞杯内，长醉芳春。 琼瑶错落密成林，竹桧交加尔有阴。恩许尘凡时纵步，不知身在五云深。保和新殿丽秋辉，诏许尘凡到绮闱。雅宴酒酣添逸兴，玉真轩内看安妃。 任东风老去，吹不断泪盈盈。记春浅春深，春寒春暖，春雨春晴，都断送佳人命。落花无定挽春心。芳草犹迷舞蝶，绿杨空语流莺。玄霜着意捣初成，回首失云英。但如醉如痴，如狂如舞，如梦如惊。香魂至今迷恋，问真仙消息最分明。几夜相逢何处，清风明月蓬瀛。 映阶碧草自春色，隔叶黄鹂空好音。流水何太急？深宫尽日闲。殷勤谢红叶，好去到人间。屋漏更遭连夜雨，船迟偏遇打头风。火到猪头烂，钱到公事办。情知语是钩和线，从前钓出是非来。头裹金花璞头，身穿赭衣绣袍，腰系蓝田玉带，足登飞凤乌靴。要知心腹事，但听口中言。 龙眉凤目，皓齿鲜唇，飘飘有出尘之姿，冉冉有惊人之貌。若非阆苑瀛洲客，便是餐霞吸露人。 姻缘分定，自然千里相逢。欢娱嫌夜短，寂寞恨更长。春为茶博士，酒是色媒人。若要人不知，除非己莫为。 左手如托泰山，右手如抱婴孩，弓开如满月，弹发似流星。说开天地怕，导破鬼神惊。得意之事，不可再作，得便宜处，不可再往。眉头搭上双鐄锁，腹内新添万斛愁。踏破铁鞋无觅处，得来全不费工夫。日前不做亏心事，半夜敲门不吃惊。鹿迷秦相应难辨，蝶梦庄周未可知。浑似皂雕追紫燕，真如猛虎啖羊羔。从前作过事，没兴一齐来。 但存夫子三分礼，不犯萧何六尺条。自古奸淫应横死，神通纵有不相饶。 第十四卷 闹樊楼多情周胜仙太平时节日偏长，处处笙歌入醉乡。闻说鸾舆且临幸，大家试目待君王。 色，色，易迷，难拆。隐深闺，藏柳陌。足步金莲，腰肢一捻，嫩脸映桃红，香肌晕玉白。娇姿恨惹狂童，情态愁牵艳客。芙蓉帐里作鸾凰，云雨此时何处觅？ 言可省时休便说，步宜留处莫胡行。人逢喜信精神爽，话合心机意趣投。未知性命如何，先见四肢不举。可怜三尺无情土，盖却多情年少人。曾观《前定录》，万事不由人。小园昨夜东风恶，吹折江梅就地横。金瓶落井全无信，铁枪磨针尚少功。 情郎情女等情痴，只为情奇事亦奇。若把无情有情比，无情翻似得便宜。 第十五卷 赫大卿遗恨鸳鸯绦皮包血肉骨包身，强作娇妍诳惑人。千古英雄皆坐此，百年同是一坑尘。 一笑倾人城，再笑倾人国。岂不顾倾城与倾国，佳人难再得！ 假如张敞画眉，相如病渴，虽为儒者所讥，然夫妇之情，人伦之本，此谓之正色；又如娇妾美婢，倚翠偎红，金钗十二行，锦障五十里，樱桃杨柳，歌舞擅场，碧月紫云，风流姱艳，虽非一马一鞍，毕竟有花有叶，此谓之傍色；又如锦营献笑，花阵图欢，露水分司，身到偶然留影，风云随例，颜开那惜缠头，旅馆长途，堪消寂寞，花前月下，亦助襟怀，虽市门之游，豪客不废，然女闾之遗，正人耻言，不得不谓之邪色；至如上蒸下报，同人导于兽禽，钻穴逾墙，役心机于鬼蜮，偷暂时之欢乐，为万世之罪人，明有人诛，幽蒙鬼责，这谓之乱色。 填塞了虚空圈套，污秽却清净门风，惨同神面刮金，恶胜佛头浇粪，远则地府填单，近则阳间业报。不看僧面看佛面，休把淫心杂道心。 春游千万家，美人颜如花。三三两两映花立，飘飘似欲乘烟霞。 茶诗:玉蕊旗枪称绝品，僧家造法极工夫。兔毛瓯浅香云白，虾眼汤翻细浪休。断送睡魔离几席，增添清气入肌肤。幽丛自落溪岩外，不肯移根入上都。 潇洒亭轩，清虚户牖。画展江南烟景，香焚真腊沉檀。庭前修竹，风摇一派珇环声；帘外奇花，日照千层锦绣色。松阴入槛琴书润，山色侵轩枕簟凉。 生于锦绣丛中，死在牡丹花下。 两柄快斧不勾劈一块枯柴，一个疲兵怎能当四员健将。灯将灭而复明，纵是强阳之火；漏已尽而犹滴，那有润泽之时。任教铁汉也消熔，这个残生难过活。 地下忽添贪色鬼，人间不见假尼姑。贪淫浪子名回放，稔色尼姑祸忽临。情知语似钩和线，从头钓出是非来。老龟蒸不烂，移祸于空桑。 可怜老和尚，不见了小和尚；原来女和尚，私藏了男和尚。分明雄和尚，错认了雌和尚。为个假和尚，带累了真和尚。断过死和尚，又明白了活和尚。满堂只叫打和尚，满街争看迎和尚。只为贪那一个莽和尚，弄坏了庵院里娇滴滴许多骚和尚。 野草闲花恣意贪，化为蜂蝶死犹甘。名庵并入游仙梦，是色非空作笑谈。 第十六卷 陆五汉硬留合色鞋得便宜处笑嘻嘻，不遂心时暗自悲。谁识天公颠倒用，得便宜处失便宜。 爽口食多应损胃，快心事过必为殃。 《清江引》:谁家女儿，委实的好，赛过西施貌。面如白粉团，鬓似乌云绕。若得他近身时，魂灵儿都掉了。觑鞋儿三寸，轻罗软窄，胜蕖花片。若还绣满花，只费分毫线。怪他香喷喷不沾泥，只在楼上转。 出外青山楼外楼，西湖歌舞几时休？暖风熏得游人醉，错把杭州作汴州。 要将撮合三杯酒，结就欢娱百岁缘。 浪子心，佳人意，不禁眉来和眼去。虽然色胆大如天，中间还要人传会。伎俩熟，口舌利，握雨携云多巧计。虎婆绰号马泊六，多少良家受他累？不怕天，不怕地，不怕傍人闲放屁。只须瞒却父和娘，暗中撮就鸳鸯对。朝相对，暮相对，想得人如痴与醉。不是冤家不聚头，杀却虔婆方出气。 豆蔻包香，却被枯藤胡缠；海棠含蕊，无端暴雨摧残。鸺鶒占锦鸳之窠，凤凰作凡鸦之偶。一个口里呼肉肉肝肝，还认做店中行货；一个心里想亲亲爱爱，那知非楼下可人。红娘约张珙，错订郑恒；郭素学王轩，偶迷西子。可怜美玉娇香体，轻付屠酤市井人。 一念愿邀云雨梦，片时飞过凤凰楼。理直千人必往，心亏寸步难移。闭门家里坐，祸从天上来。可怜慕色如花女，化作含冤带血魂。 赌近盗兮奸近杀，古人说话不曾差。奸赌两般得不染，太平无事做人家。 第十七卷 张孝基陈留认舅士子攻书农种田。工商勤苦挣家园。世人切莫闲游荡，游荡从来误少年。 世人尽导读书好，只恐读书读不了。读书个个望公卿，几人能向金阶跑？郎不郎时秀不秀，长衣一领遮前后。畏寒畏暑畏风波，养成娇怯难生受。算来事事不如人，气硬心高妄自尊。稼穑不知贪逸乐，那知逸乐会亡身。农工商贾虽然贱，各务营生不辞倦。从来劳苦皆习成，习成劳苦筋力剑。春风得力总繁华，不论桃花与菜花。自古成人不自在，若贪安享岂成家？老夫富贵虽然爱，戏场纱帽轮流戴。子孙失势被人欺，不如及早均平派。一脉书香付长房，诸儿恰好四民良。暖衣饱食非容易，常把勤劳答上苍。 五谷不熟，不如荑稗；贪却赊钱，失却见在。受用须从勤苦得，淫奢必定祸灾生。世无百岁人，枉作千年调。因无背后眼，只当耳边风。水平不波，人平不言。地府忽增不肖鬼，人间已少败家精。忙忙如丧家之狗，急急如漏网之鱼。种田不熟不如荒，养儿不肖不如无。三寸气在千般用，一旦无常万事休。临崖立马收缰晚，船到江心补漏迟。 肖子流落卑污，玷辱家门，生不能侍奉汤药，死不能送骨入土，忤逆不导，粉骨难赎！ 昔年流落实堪伤，今日相逢转断肠。不是一番寒彻骨，怎得梅花扑鼻香！ 钱财如粪土，仁义值千金。曾记床头语，穷通不二心。唐人罗隐先生有赞云：能生之，不能富之；能富之，不能教之。死而生之，贫而富之，小人而君子之。呜呼孝基，真可为百世之师！ 还财阴德庆流长，千古名传义感乡。多少竞财疏骨肉，应知无面向嵩山。 第十八卷 施润泽滩阙遇友还带曾消纵理纹，返金种得桂枝芬。从来阴骘能回福，举念须知有鬼神。 第一句:纵理纹生相可怜，香山还带竟安然。淮西荡定功英伟，身系安危三十年。第二句:燕山窦十郎，教子有义方。灵椿一株老，丹桂五枝芳。 种瓜得瓜，种豆得豆。一切祸福，自作自受。 东风二月暖洋洋，江南处处蚕桑忙。蚕欲温和桑欲干，明如良玉发奇光。缲成万缕千丝长，大筐小筐随络床。美人抽绎沾唾香，一经一纬机杼张。咿咿轧轧谐宫商，花开锦簇成匹量。莫忧八口无餐粮，朝来镇上添远商。 多少恶念转善，多少善念转恶。劝君诸善奉行，但是诸恶莫作。横财不富命穷人从来作事要同心，夫唱妻和种德深。万贯钱财如粪土，一分仁义值千金。江南有谣云:朝暮类春秋，正昼如夏，深夜如冬，故调护最难。做天莫做四月天，蚕要温和麦要寒。秧要日时麻要雨，采桑娘子要晴干。 一叶浮萍归大海，人生何处不相逢。 昔闻杨宝酬恩雀，今见施君报德鸡。物性有知皆似此，人情好杀复何为？ 只为还金恩义重，今朝难舍弟兄情。六亲合一运。人逢喜事精神爽，月到中秋分外明。六金还取事虽微，感德天心早鉴知。滩阙巧逢恩义报，好人到底得便宜。 第十九卷 白玉娘忍苦成夫西江月:两眼乾坤旧恨，一腔今古闲愁。隋宫吴苑旧风流，寂寞斜阳渡口。兴到豪吟百首，醉余凭吊千秋。神仙迂怪总虚浮，只有纲常不朽。 宋弘不弃糟糠，罗敷不从使君。允欲娶高门，预逐其妇；买臣室达太晚，见弃于妻。王允弃妻名遂损，买臣离妇志堪悲。夫妻本是鸳鸯鸟，一对栖时一对飞。 片片晚霞迎落日，行行倦鸟盼归巢。宁为太平犬，莫作离乱人。 西江月:两导眉弯新月，一双眼注微波。青丝七尺挽盘螺，粉脸吹弹得破。望日嫦娥盼夜，秋宵织女停梭。画堂花烛听欢呼，兀自含羞怯步。 夫妻且说三分话，未可全抛一片心。分明指与平川路，反把忠言当恶言。世上万般哀苦事，无非死别与生离。鳌鱼脱却金钩去，摆尾摇头再不来。 数载难忘养育恩，看经礼忏荐夫人。为人若肯存忠厚，虽不关亲也是亲。六日夫妻廿载别，刚肠一样坚如铁。分鞋今日再成双，留与千秋作话说。 第二十卷 张廷秀逃生救父刀事由天莫强求，何须苦苦用机谋。饱三餐饭常知足，得一帆风便可收。生事事生何日了？害人人害几时休？冤家宜解不宜结，各自回头看后头。 任你官清似水，难逃吏滑如油。《赘婿诗》:入家赘婿一何痴！异种如何接本枝？两口未曾沾孝顺，一心只想霸家私。愁深只为防甥舅，念狠兼之妒小姨。半子虚名空受气，不如安命没孩儿。 着意栽花花不活，无心插柳柳成阴。运退黄金失色，时来铁也增光。 只因强盗设捕人，谁知捕人赛强盗！买放真盗扳平民，官法纵免幽亦报。 闭门家里坐，祸从天上来。冤情说到伤心处，铁石人闻也断肠。众口铄金，积毁销骨。人情若比初相识，到底终无怨恨心。机不密，祸先行。怜世上聪明子，化作江中浪宕魂。情知不是伴，事急且相随。难将幽恨和人说，愿向泉台诉丈夫。但愿应时还得见，须知胜似岳阳金。 《千秋岁》:琼台琪草，玄鹤翔云表，华筵上笙歌绕。玉京瑶岛，客笑傲、乾坤校齐拍手唱导：长春人不老。北阙龙章耀，南极祥光照，海屋内、筹添了。青鸟衔笺至，传报群仙到， 同嵩祝万年称寿考。 未行雪耻酬凶事，先作攀花折桂人。分明久旱逢甘雨，赛过他乡遇故知。莫问洞房花烛夜，且看金榜挂名时。 兄弟同榜，锦上添花；母子相逢，雪中送炭。兄弟同榜，锦上添花；母子相逢，雪中送炭。 早知今日，悔不当初。苦中得乐浑如梦，死里逃生喜欲狂。 四姓亲家皆富贵，两双夫妇倍欢娱。枕边忽叙伤心话，血泪犹然洒绣幮。 善恶到头终有报，只争来早与来迟。劝君莫把欺心使，湛湛青天不可欺。 繇来白屋出公卿，到底穷通未可凭。凡事但将天理念，安心自有福来迎。]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Future]]></title>
    <url>%2F2017%2F03%2F05%2FFuture%2F</url>
    <content type="text"><![CDATA[我在为孩子寻找母亲，为孙儿寻找奶奶，所以希望你少而美丽，中而强干，老而慈祥；我出差的时候，你能为我收拾行李，这样当我在异地他乡，打开箱子就能想起你；咱们爸妈年纪都大了，应该常去看他们，如果我忙糊涂了，你会记得提醒我；最后也是最重要的一点，你已经做好了一切准备进入婚姻，并经营好它。 前言以上是在《得到》里听到的一篇关于讲文案的文章的其中一部分，内容是一个男士征婚的广告语。好的文案的特点是，它能给观众带来很强烈的画面感，就如同上面一样。事实证明，好的生活亦是如此，一个好的生活愿景能使你现在的生活更快乐，所以这里记录的是我对将来生活的愿景。 弗兰克尔生命的意义就在于：帮助其他人找到生命的意义。写给你。 未来由于时间紧张，现阶段临时记录一些，然后有时间具体记录。 房间 人大部分的时间是在房间里度过的，休息的场所，所以一定要舒适。 一个书桌。一个好的书桌能提高工作效率。配一个好的台灯，暖光。平时学习看书就是它了，坐上去就有学习的冲动。 电视机。看到很多结婚的同学都配的大屏高清电视了，将来和你结婚也配一个，哈哈。我的电脑也可以接电视屏幕，那时候更好玩，哈哈。 健身房。将三楼的一个房间做成健身房，顶楼隔热，这样平时就可以锻炼了。 我和你 学一门按摩的手艺，在大学就在想了，这门手艺一定会学会的，这样平时就可以替你按摩了。 每年只少写一篇记录我们生活的文章送给你。 现在 2017-03-05 写了上部分，记录了之后的愿景2018-04-28 现在，有缘遇到现在的女朋友 已约定明天一起去南京，现在感情良好，愿终成眷属~https://jingbin.me/love/]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大话数据结构》读书笔记]]></title>
    <url>%2F2017%2F03%2F01%2F%E3%80%8A%E5%A4%A7%E8%AF%9D%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[如果你有梦想的话，就要去捍卫它。当别人做不到的时候，他们就想要告诉你，你也不能。如果你想要些什么，就得去努力争取。就这样！ – 《当幸福来敲门》 书籍链接点击 - 个人觉得可以用来入门，后面的路还很长。简要记录个人认为比较重要的内容。 数据结构绪论数据结构：是相互之间存在一种或多种特点关系的数据元素的集合。数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。 程序设计 = 数据结构 + 算法 算法算法时间复杂度 语句的总执行次数T(n)是一个关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。时间复杂度，也就是算法的时间量度，记：T(n) = O(f(n))。 它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。其中f(n)是问题规模n的某个函数。 这样用大写O( )来体现算法时间复杂度记法，我们称之为大O记法。 大O记法推导： 1.用常数1取代运行时间中的所有加法常数。 2.在修改后的运行次数函数中，只保留最高阶项。 3.如果最高阶存在且不是1，则去除与这个项相乘的常数。得到的结果就是大O阶。 常用的时间复杂度： 常数阶 – O(1) 线性阶 – O(ｎ) 对数阶 – O(㏒ｎ) 平方阶 – O(ｎ²) ｎ㏒ｎ阶 – O(ｎ㏒ｎ) 指数阶 – O(2º)(º - n) 常用的时间复杂度所耗费的时间从小到大依次是：O(1) &lt; O(㏒ｎ) &lt; O(ｎ) &lt; O(ｎ㏒ｎ) &lt; O(ｎ²) &lt; O(ｎ³) &lt; O(2º) &lt; O(n!) &lt; O(ｎº) O(n!)：阶乘阶。 O(ｎ)：查找一个有n个随机数字数组中的某个数字。 O(㏒ｎ)： 算法空间复杂度算法的空间复杂度通过计算算法所需的存储空间实现，算法空间复杂度的计算公式记作：S(n) = O(f(n))，其中，n为问题的规模，f(n)为语句关于n所占存储空间的函数。 小结时间复杂度 → 运行时间的需求空间复杂度 → 运行空间的需求不用限定词使用“复杂度”时，通常指时间复杂度。 线性表 List：零个或多个数据元素的有限序列。(eg：幼儿园接儿子) 顺序存储结构随着数据的插入，我们的线性表的长度开始变大，不过线性表的当前长度不能超过存储容量，即数组的长度。 线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。 线性表的长度 ≤ 数组的长度 数组 → 读取：O(1)， 插入或删除：O(n) 链式存储结构1.单链表结构： 链表： → 读取：O(n)， 插入或删除：O(1)还有：2.静态链表结构、3.循环链表、4.双向链表 栈与队列 栈：是限定仅在表尾进行插入和删除操作的线性表。 队列：是只允许在一端操作、而在另一端进行删除操作的线性表。 栈的应用四则运算表达式求值：后缀（逆波兰）表示法定义 -&gt; 不需要括号&quot;9 + (3 - 1) * 3 + 10 / 2&quot; → &quot;931 - 3 *+ 10 2 /+&quot; 知道中缀表达式 → 后缀表达式 数字 → 输出 括号 → 等反括号，再输出反括号里的符号 * / → 优先级高先出栈 总结它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端，因此它们各自有各自的技巧来解决这个问题。对于栈来说，如果是两个相同类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，是的队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，是的本来插入和删除是O(n)的时间复杂度变成了O(1)。 串 是由零个或多个字符组成的有限序列，又名叫字符串。 树(Tree)树是n(n≥0)个结点的有限集。n=0时称为空树。在任意一颗非空树中： 有且仅有一个特定的称为根(Root)的结点。 当n &gt; 1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2…、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。 二叉树（Binary Tree）二叉树是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两棵互不交换的、分别称为根节点的左子树和右子数的二叉树组成。 特殊二叉树： 1、斜树 2、满二叉树 3、完全二叉树 二叉树的存储结构二叉树顺序存储结构二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。 二叉链表既然顺序存储适用性不强，我们就要考虑链式存储结构。二叉树每个结点最多有连个孩子，所以为它设计一个数据域和指针域是比较自然的想法，我们称这样的链表叫做二叉链表。 lchild data rchild l A r 其中dataz是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针。 遍历二叉树二叉树的遍历（traversing binary tree）是指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅访问一次。 遍历方法： 1、前序遍历 2、中序遍历 3、后序遍历 4、层序遍历 知道：前序：ABCDEF 中序：CBAEDF推出：后序：CBEFDA过程： 前序：可知[A]是根节点 中序：[CB]知道C是B的左孩子 知道：中序：ABCDEFG 后序：BDCAFGE推出：前序：EACBDGF过程： 后序：[E]在尾端，知[E]为根节点。 … 线索二叉树图(Graph)是由定点的有穷非空集合和顶点之间的集合组成，通常表示为G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。 多对多的情况 → eg:人际关系 无向边：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对(Vi，Vj)来表示。任意两个顶点之间的边都是无向的，则称该图为无向图。 有向边：若顶点Vi到Vj之间的边有方向，则称这条边为有向边，也称为弧(Arc)。任意两个顶点之间的边都是有向边，则称该图为有向图。 查找顺序查找 O(n)有序表查找 三者的区别是：中间数取的不一样。具有n个结点的完全二叉树的深度为[log2n]+1。→ ㏒ｎ 二分差找 O(㏒ｎ)插值查找 O(㏒ｎ)斐波那契差找 O(㏒ｎ)树表查找二叉树查找(二叉排序树)插入和查找的时间复杂度为O(㏒ｎ)，最坏(长条)为O(n)。优化： 平衡二叉树，为了避免上述最差的情况(O(n))，构建时，让这棵二叉排序树是平衡二叉树，此时，查找、插入和删除都是O(㏒ｎ)。 平衡查找树之2-3查找树(2-3Tree) O(㏒ｎ) 属于二叉树查找优化。 性质： 1、中序遍历2-3查找树，就可以得到好序的序列。 2、在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。 最坏：所有都是2-node节点，时间复杂度：㏒ｎ最好：所有都是3-node节点，时间复杂度：0.631㏒ｎ 平衡查找树之红黑树(Red-Black-Tree)2-3树实现起来比较复杂，于是有了一种简单实现的2-3树的数据结构 – 红黑树。 红黑树中将节点之间的链接分为两种不同的类型： 红色链接：用来链接两个2-nodes节点来表示一个3-nodes节点。 黑色链接：用来链接普通的2-3节点。 特性： 1、红色链接向左倾斜。 2、一个节点不可能有两个红色链接。 3、整个树完全黑色平衡。 Java：TreeMap和TreeSet都是基于红黑二叉树。 B树和B+树（B Tree/B+ Tree）用于：文件系统和数据库系统中（硬盘里的文件）。 分块查找哈希表查找： Map的本质是Hash表 → 以空间换时间。key - indexed 键 - 值时间复杂度：O(1) 排序算法的复杂性：算法本身的复杂度，而不是指算法的时间负责度。 内排序：插入排序、交换排序、选择排序、归并排序简单算法： 冒泡排序：O(ｎ²) 简单选择排序：O(ｎ²) 直接插入排序：O(ｎ²)改进算法： 希尔排序：O(ｎ³/²) 不稳定 堆排序：O(ｎ㏒ｎ) 不稳定 归并排序：O(ｎ㏒ｎ) 稳定 快速排序： 冒泡排序挨个比较，设置flag(优化) 简单选择排序比较n次，最小交换到第1位比较n-1次，最小交换到第2位比较n-2次，最小交换到第3位 性能略高于冒泡排序 直接插入排序一个记录的辅助空间，比上两种性能好一些。向前插入依次向后移动。（适用于：基本有序、少数） 希尔排序 改进的直接插入排序。 条件：基本有序（通过希尔排序达到基本有序）将相隔某个“增量”的记录组成一个子序列，实现跳跃式的移动，使得排序的效率提高。跳跃式的移动：导致了不稳定。 增量： increment = increment/3 + 1; 堆排序 改进的简单选择排序。不适合排序序列较少的情况。 定义：根节点一定是堆中所有节点最大(小)值。大：大顶堆。小：小顶堆。比较与交换跳跃式进行：导致了不稳定。 先将无序序列构建成一个堆（大顶堆），根节点为最大值，移走，将剩余的n-1重新构造成一个堆，再移走，反复执行。重新构造：调整的是非终端结点（非叶结点） 堆排序操作的是完全二叉树（有两个子结点或无子结点），不必左小又大。ps:平衡二叉树：高度一致，左大右小。 运行时间主要消耗在初始构建堆和在重建堆时的反复筛选上。 构建堆O(n)，重建堆O(ｎ㏒ｎ)，得到时间复杂度：O(ｎ㏒ｎ)。远远好于简单算法的时间复杂度。 归并排序 两两比较不跳跃（稳定）时间复杂度：O(ｎ㏒ｎ)，空间复杂度：O(ｎ+㏒ｎ) n个有序的子序列，长度为1，两两合并，得到[n/2]。然后再两两合并….一个无序序列，先分散我一个个单个序列，然后再合并。 比较占用内存，但却效率高且稳定的算法使用此算法时，尽量考虑非递归方法。 快速排序 直接插入排序的升级。不稳定时间复杂度： 平均和最好：O(ｎ㏒ｎ)； 最坏：O(ｎ²)；空间复杂度： 平均和最好：O(㏒ｎ)； 最坏：O(ｎ)； 基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到有序的目的。 Partition函数： 取一个关键字（pivot枢轴）。先定一个关键字，然后想尽办法让，左边的值都比它小，右边的值都比它大。 50&gt;20 → 交换内容交换后 20&lt;pivotkey，low++high里的值为50，不大于50，high不动 交换之后： 到角标为3时：low的值为90 &gt; high的值为50 → 交换内容交换后 high里的值为90 &gt; 50, → high– 优化： 1、优化选取枢轴（三数取中，九数取中） 2、优化不必要的交换（先备份在L.r[0]中(头中)，再直接替换，省掉中间交换） 3、优化小数组时的排序方案（如只有7个或50个，用直接插入排序，大于则快速排序） 4、优化递归操作（递归要时间，减少，使用尾递归） 总结 插入排序类： 直接插入排序 希尔排序 选择排序类： 简单选择排序 堆排序 交换排序类： 冒泡排序 快速排序 归并排序类： 归并排序 推荐文章 常用的算法的时间复杂度和空间复杂度 Java常用排序算法/程序员必须掌握的8大排序算法 七大查找算法 Android的数据结构与算法—-ArrayList源码解析]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Books</tag>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《催眠师手记》读书笔记]]></title>
    <url>%2F2017%2F03%2F01%2F%E3%80%8A%E5%82%AC%E7%9C%A0%E5%B8%88%E6%89%8B%E8%AE%B0%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[2016年2月29日 21：53 记录于备忘录。现如今归纳整理在此。 《催眠师手记：国内第一部心理推理纪实档案》（《天才在左 疯子在右》姊妹篇） 高铭再次怀着强烈的好奇心深入催眠诊所、心理诊所，获悉珍贵一手资料，化身心理福尔摩斯，探寻埋藏在人内心深处的秘密，打造国内第一部心理推理纪实档案。 一位女士一位女士，小时候穷，母亲被继父逼着打她，生活所迫。找了一个年龄很大有钱的有妇之夫，做了小三。自己想逃走但很有压力，离不开，知道这样做的结果，所以更害怕。 一位男士以前事业顺利，一切都好，结婚后妻子离婚，开始怀疑自己了，第二人格是情感高手，但本体不是，有在人格分裂的迹象。应该找心理医生。 一个和尚梦见千手观音，代表救赎。以前是一个赌徒，气死了母亲，杀了父亲，杀了劝他回头是岸的和尚。之后又跟了一位和尚，有悔悟之心但知道自己罪孽深重，才做噩梦，劝你自首。 想想看，有那么几个人，把自己的思想和信念传播开，影响到整个人类社会，并且持续了几千年……还有比这更神奇的吗？没有了，这就是神迹。 一位曾经放弃自己梦想的女士“观察这个世界用一只眼睛足够了，另一只则用来多看看自己。”——这是当年我最喜欢的一个导师说的。 梦见了无头人，独眼人，半面人，曾经为了家庭放弃了梦想，现在家庭美好，但年龄大了觉得不合适画画。现在无头绪的过着生活。治疗之后，追寻了自己的梦想，三个月后寄了一副油画过来。 一个体育运动员以前红极一时，叱诧风云，因为年轻，自我膨胀，开始放纵自己，差点吸毒了。后来改过自新，一直强力训练，以以前的自己为目标，要战胜完美记忆，劳累过度。治疗三个月后，打败完美记忆，走向赛场。 一位从小被父母左右的女士结婚也是父母安排的，嫁给了一个有钱但不爱自己的人，出卖了自己的肉体给了父母吹牛的谈资。内心憎恨不满但自己又很自律。独自住在一个房间内，被别人偷窥，于是梦游手淫给别人看，以报复父母的不公平待遇。梦见一只大眼看着自己但没有反抗。推荐在家种了很多的花。 做梦与催眠我点了点头：“梦中的景象都来自于你的记忆。也就是说，梦中你所经历的场景和事物，不过是对现实记忆的提取及再加工——记忆当然可以瞬间千里，跨越时间和空间——那些场景和事件实际上就是潜意识从记忆中抽取出场景和片段组成的，所以梦根本不需要时间流。打个不恰当的比方吧：这如同你打开电脑里存储的视频不需要漫长的缓冲……” 催眠是通过某种手段让被催眠者交出部分意识，这样就能获取被催眠者潜意识中的一些想法或者某些记忆。与一位记者的谈话。 少年与搭档的谈话搭档：“每个人都有不同的消遣方式，你可以不那么做，但是要接受不同于自己的存在。” 少年：“你的搭档只带了一本书，而剩下那些都是你带来的。我注意到那几本书不是一个类型，各个领域都有，你的兴趣面很广，证明你的知识面很广。不过我很高兴没看到《天边的骷髅旗》，就是那天你在我那里看到的那本。” 搭档：“你很清楚人类社会结构的理论，但是你并未置身于其中去体会那到底是怎么样的；你明白爱情是一种化学分泌的结果，但是你并不知道那能带给自己多么美妙的感受；你可以想象出美丽的风景，但是你却没经历过亲眼目睹的震撼；你从书中看到过历史，但你看不到字里行间的沧桑；你读懂了高等数学的深奥，但是你读不懂那曾经让人废寝忘食的数字屏障；你学会了两种以上的语言，可你并不了解藏在那节奏中的内涵；你明白什么是心理学，但你并未去探究过那些复杂的成因。你的聪明，让你能想象并推测出很多正确的结论，但也正是你的聪明，让你只是停留在想象。 “你什么都没经历过，你不知道什么是残酷，什么是感动，什么是热情，什么是悲伤，你拥有的只是冷漠。你对战争的了解只是一些零碎的词汇，枪林弹雨、政治阴谋、军火商、部队编制？你不知道看着战友倒在身边，吐出最后一口气会是什么样的心情；你对男女之间的了解也只是另一些词汇，繁衍、荷尔蒙、肾上腺素？但你并不明白能够让你动心的那一刻足以影响到你的未来。 “你只是个孩子，我打赌你没离开过这个城市。大多数情况下，你的活动半径不超过10公里，但是你的聪明和天赋让你通过书以及各种渠道将所获得的信息整合起来，并借此想象出了一个完整的世界，但是你确定真正的世界就是那样吗？没有任何验证就认定了？你之所以不知道自己要什么，也看不到自己的未来，是因为你的一切都停留在你认定的那些概念和结论上。除此之外，你什么也不知道。也是正因如此，甚至连你编造的谎言都是个标准的模式：白衣女鬼，劝人上吊自杀，只有你才能看到……不过我必须承认，你的确只有衣柜里的朋友——那些书。除此之外，你什么都没有。你甚至把自己的心和思维全部关在一个黑暗的小屋里，只需要，也只能由衣柜里的朋友陪着。你在看书吗？你看过很多书吗？可是你看懂了吗？” 一个小男孩，被称为天才。被学校老师和自己家长，要求做了很多自己不爱做的事情。封闭他却让他创新，写更多的东西，还刁难他。 他们剪掉我的翅膀，却又要我飞翔。 一个对生命看的过于清醒的美丽的女人绑了一个人对他讲述了她对人一生进程的看法，人一出生就被操纵着，到结束这一生。 “她过了好一会儿才转回头看着我：‘但基因，只是如同计算机编码一样的东西而已——它们只是工具，真正创造出编码的才是操纵者。以我们的智慧，是无法想象出那个真正的操纵者会是一种怎样的存在，它远远超出了我们思维的界限。’她长长地叹了一口气，‘真正可悲的是，我们宁愿相信没有那么一个存在，但是我们又无法违背心里的渴求——模仿它。你会对这句话感到费解吗？我想你会，因为这证明你还清醒。想想看吧，我们用计算机编程这种最直接的方式来模仿操纵者的行为——用简单至极的0和1，创造出复杂的系统，甚至还有应变能力。当然，只是在某种程度上的应变，在我们划定的范围内。除此之外，我们还有间接的方式来企图破解出什么。例如，占星？算命？颅相、手相、面相？风水八字？你对那些不屑一顾吗？我不那么看，我倒宁愿相信那些都是统计学而已——企图在庞杂且无序的数据中找出规律。他们当中有些人的确做得不错并因此而成为某个领域的大师。 但是，假如你能认识他们，并且和他们聊聊，你就会发现，他们将无一例外地告诉你：’我只是掌握了很少很少的一点儿。‘而且，你还会发现，其实他们比我更悲观，因为他们的认知已经超越了自己的身份——人类。跳出自己看自己是一件多可怕的事，你认为有多少人能接受？接受我们被囚困在无形的笼子里，一举一动、一言一行都是被规划好的，严格地按照程序在执行。创造力？想象力？当你不用人类的眼光来看时，会发现那些只是可笑、可怜、可悲的同义词罢了。’” 一个二十五六岁的很瘦的女孩刚刚就在确定了那把“锁”之后，我和搭档商量了一下，决定把催眠的重点放在她的童年时代。因为童年的某些事件在心智尚未发育完全的孩子眼里，有可能会产生扭曲的印象和感受，之后随着时间的推移渐渐成为潜意识而被埋藏起来。慢慢地，记忆偏差以及成长等其他因素所造成的干扰，会无一例外让当初留在内心深处的扭曲印象及感受放大许多倍——大到足以能影响到一个人的行为。当然，不见得所有心理问题、行为异常都是这种情况造成的，但是这是嫌疑最大的。因此，我们决定从这里开始。 小时候由于性别歧视，遭到亲戚父亲的嫌弃，母亲让她躲起来，这样就不会受到关注。二十岁左右后父母再次争吵，又提了出来，固化了她自己不重要的思想，想尽办法把自己隐藏起来，于是喜欢黑的环境。解决:让未婚夫与她谈，包括她的父母。 一位民航机长谢谢，这是我的职业。假如把我放到您所工作的飞机驾驶舱，看着满眼奇怪的开关和指示灯，我肯定不知所措，更别提遇到乱流一类的临时情况该怎么处理了。但是您就能娴熟地操作，对不对？我会认为您非常了不起。 小时候母亲很强势，父亲很懦弱，一直信任母亲，有一天看到母亲出轨了，才反对母亲，自己做的一切行为都湿为了反对母亲的行为。自己的妻子慢慢的得到了家庭的主动权才使自己焦虑起来。怀疑妻子。解决:把一切向妻子坦明，包括调查的事。选择是双方的。 潜意识和意识 暗示我们的潜意识能够使用意识来判断出哪一部分内容成为意识，哪一部分隐藏起来。其实，意识更像是电脑在处理文件时的缓存——把常用的东西从库房里搬出来存在中间地带，而不必每次都跑到库房去搬，以便加快电脑的处理速度。潜意识就是那个库房。而意识和电脑缓存最大的共同点是：断电即清空——有人能告诉我意识被清空意味着什么吗？嗯……非常正确，就是失忆。所以说，失忆并非是真的失忆了，而是我们的缓存部分被清空或者一部分被清理了而已。 暗示本身并无强弱之分，我们通常所说的强暗示是指使用暗示的方式和方法。暗示的方式、方法有很多种，不仅仅限于语言，动作、表情等都可以有其暗示性。有些是我们生活中约定俗成的，例如摇头和摆手意味着拒绝。额外插一句，印度和新西兰土著的日常习惯正相反——点头是拒绝；还有一些是特定的暗示动作。 一个说自己是时间维护者的女孩。很瘦。几年前被人催眠了，强化了意识。影响了身体的机能。通过催眠发现了破绽，给了搭档的师傅处理。 一位小时候目睹父亲杀了强势和出轨的母亲但母亲和父亲都很爱她，小时候受到很多指责，但都没有怪罪他人，梦到杀妻并处理尸体是因为，要为父亲掩盖罪行这样就不会再失去父亲了，同时也是希望母亲能好好离开。取一位温婉的女人是看到母亲这样不好，不想重蹈父亲的覆辙。建议告诉妻子不要背负太多。不一样妻子担忧决定自己扛，收入不错。 一个从小被家里的父亲和姐姐宠大的混蛋利欲熏心和自私到极致到处招摇撞骗，骚扰一个女孩七年，认为女人都是低贱的，被挂进去两次。向家里借钱开公司因为自己的说空话倒闭欠了很多钱，到心理诊所是想开一个证明躲避追债。 一个从医多年退休的医界老者从医很多年，对生命已没有尊敬之心，人情味淡薄，看到的只是利益，教育自己的孩子也是如此。直到有一天看到天使与恶魔。发现自己一直被恶魔环绕，感到恐惧但没有忏悔之心。被天使环绕会感到一阵温暖，曾经有过一次，也许是有点悔悟。您不会下地狱的，因为您已经在地狱了。我曾经看到天使。所以我不担心。 一个从小在刻板严肃的环境中长大的女孩你看，她的家庭环境不用多解释了吧？催眠之前她自己形容过，是偏于刻板、严肃的那种，这意味着什么？一个框架，对吧？在这种环境下成长起来的孩子，通常会划分为两个极端，要么很反叛，要么很古板、固执。但有意思的是，通常反叛的那个内心是古板的，而看似古板的那类，内心却是极度反叛的，甚至充满了极端情绪和各种夸张的、蠢蠢欲动的念头。她就是第二种。说到这儿为止，已经有两个框架在限制她了。 根据对梦的描述，她是有同性性取向的人。家庭两个方面和工作一方面，性取向一方面，导致或许压抑自己。我们要做的就是直接告诉她，让她赦免自己。]]></content>
      <categories>
        <category>Books</category>
      </categories>
      <tags>
        <tag>Books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京住房公积金与社保查询及转移指南]]></title>
    <url>%2F2017%2F02%2F27%2F%E5%8C%97%E4%BA%AC%E4%BD%8F%E6%88%BF%E5%85%AC%E7%A7%AF%E9%87%91%E4%B8%8E%E7%A4%BE%E4%BF%9D%E6%9F%A5%E8%AF%A2%E5%8F%8A%E8%BD%AC%E7%A7%BB%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[公积金 北京住房公积金查询网站北京市住房公积网 转移（官方） 【官方】公积金转到外地怎么办？ 【官方】住房公积金个人账户转移的办理指南 【官方】转移业务（除西城、海淀管理部） 提取（官方） 《住房公积金提取申请书》 北京住房公积金提取办理指南 住房公积金–通州管理部 离职怎么提公积金？(其中，进城务工人员指的是农业户口的职工。) 社保 北京市社保查询网站北京市人力资源和社会保障局 医保金额提取医保里的钱是可以提取的，拿自己的社会保障卡和身份证去北京银行(先查询自己的社保是哪个银行管理的，一般是北京银行)，说要取医保里的钱，会先办理一张存折（需要单位先到社保局领存折，银行只是补办存折的地方），然后拿着存折去取钱。 转移 【官方】社保转移手续简化 办理只需两个材料 【官方】参保人员转移接续信息定制业务(每月5日至月末) – 似乎不是转移到外省？ 【百科】2016年社保跨省转移流程及注意事项 深圳市社保接收 深圳市社会保险基金管理局 - 社保转移 异地的社保转入深圳的办理流程是？ 提供以下资料： （1）《深圳市社会保险关系转移/结算申请表》（单位员工需加盖单位公章，个人参保人员需本人签名）； （2）《基本养老保险参保缴费凭证》（外地社保局开具）； （3）身份证和社保卡（验原件、收复印件，单位员工需加盖单位公章）； （4）如果养老保险存在重复缴费的，另需提供参保人本人在本市中、农、工、建四大国有商业银行开具的存折或者借记卡原件及复印件（单位员工需加盖单位公章） 答疑 北京住房公积金转移到广州 - 百度百科 社会保险是不是只能转到户口所在地？ 外地人在北京工作，在户口所在地交社保划算吗？ 湖北户籍制度取消农业和非农业之分 社保转移需要哪些手续 转发社保转移申请表及需要的资料 北京医保政策重上正轨 自由支取变为封闭账户 北京社保卡到哪领、如何领（以朝阳区为例）]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在帝都独居一年多，让我体会到什么]]></title>
    <url>%2F2017%2F02%2F27%2F%E5%9C%A8%E5%B8%9D%E9%83%BD%E7%8B%AC%E5%B1%85%E4%B8%80%E5%B9%B4%E5%A4%9A%EF%BC%8C%E8%AE%A9%E6%88%91%E4%BD%93%E4%BC%9A%E5%88%B0%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[前言 今天是2017年2月27日，写在即将离开北京的前几天。在帝都漂了这么久，在离去之时总要做点总结回忆一下之前度过的时光。在此记录用以将来缅怀。 为何独居我本不想独居。关键是条件不允许。最初人本在海淀，和几个要好的朋友一起，偶尔一起出去玩，探讨一下学术，很惬意。然而由于工作找的是朝阳四惠东附近，到公司需要2个小时左右的时间，先坐公交到西二旗地铁站–13号线到西直门–2号线到复兴门–1号线到四惠东，在坚持一个月后不得不换了。其实最初感觉是比较好的，我喜欢坐一趟时间比较久的车，因为在中途可以看会书，当时就把《催眠师手记》看完了，还要一部分《醒世恒言》。 选址在决定搬到公司附近居住后开始考虑居住的地方，因为懒得找民房，因为没有人一起合租，一起的同事基本都已经住好了，一般租房一下租的是一年，所以也不好一起再合租，所以还是决定一个人住了。问了比较多的同事后，他们大部分住的是八通线，又由于之前听一个朋友提及过，八通线的通州北苑那里的租房的价格不贵，最初就考虑在那了。 然后在自如(一个租房软件)里联系管家开始找房，看中一个房源，管家会带你去房间，如果可以的话就在网上签约。一次性签约至少一年，有押一付一和押一付三，当然付的越多每月的租金就越便宜，我选择的是押一付三，平均一个月的租金的1430元，然后一年的服务费(里面包括一个月两次的情节，暖气费，宽带费还有维修什么的)是一个月的房租。当时一下出了5个月的房租，也就是7150元。 当时是双休带我去看的，看了一间我就定下来了。房子在万达广场的斜对面，一个小区XX家园，这里由于隐私就不透露了。因为看到了万达影城就在对面，所以一眼就定下来了，没办法就这点追求啊！爱看电影！当时租的时间是2015年12月12日，一年之后房价开始涨到1760元每月，过年后涨到1960元每月，可真是租不起了。 确定住址以后，托好友把一点行李寄到这边来，开始了一个人独居的旅程… 最初独居的心情以往都住的是集体宿舍，就算在家里也有人管着，现在一个人住想干嘛干嘛，从未感到如此的Free。真是嗨上天了！那时候的大约四个月，我享受到了前期的愉悦，就像刚谈恋爱的人一样。我们公司是十点上班七点下班双休。最初没有搬位置的时候是7点起床，现在可以8点办起床了，而且每天早上去上班时都会去路边的早餐店坐着吃早餐，那个师傅早就认识我了，每天基本点的是：一碗甜的豆腐脑，一笼包子或饺子，一个茶叶蛋。 每天工作的效率也不错，大家都很融洽，刚开始不懂的可以咨询一下同事，大家很和睦。我们一般中午下午会一起聚餐，去餐馆点几个菜，然后吃完后回公司睡个午觉继续干活。 晚上7点下班，到12点休息，中间还有很多时间。把以前一个人没机会做的事都拿出来做。于是开始，写日记… 还有看一些动漫，如《进击的巨人》，《寄生兽》，《冬季食尸鬼》等。 周末一般中午起床，在床上听很长时间的音乐，电音系列~去周围的饭店吃了以后到处逛一下，夜晚一般去电影院或在附近的通惠河的路边跑会步。看起来那么健康吗？哈哈，不！附近有一个网吧，活动期间冲一百送一百，于是我卡里面就有两百了，基本没两周会去网吧一次，一次玩大几十块钱的时间，一般会到凌晨四五点左右，玩到尽兴，不想玩了为止，虽然之后大半年没有去了，当然这是后文了。 之后和同事一起去了鄂尔多斯市沙漠玩~ 没错，这基本就是那段时间所做的事和心情了，心情相当舒适，自由，海阔凭鱼跃。电影院，跑步，通宵上网，上班期间合理作息，吃早餐了去上班。 焦虑期没有恒久的稳定，只有不停地变化。这时公司要加班了，1075变成了1096，就是强节奏的加班，对于之前的我们是强节奏，在其他的互联网公司这应该算是正常的。这时候的节奏完全被打乱了，上班比较累，早上就难起，从此就改变了在路上吃早餐的好习惯，晚上也没有什么具体活动了。从四月下旬开始，这样一直持续了两个多月。 在加班期间一直是比较难受的，第一只工作负荷，第二是生活作息变了，第三人和人相处也不那么和谐了，大家都有各自的抱怨。 往后面一直持续到十月份左右，那段时间很难受，想要找到生活的目标，不是简单的这样上网，看电影而已，而且一个人住开始觉得无聊，没有人交流。要知道周围是没有一个可以交流的人，和朋友之间聚会也是几个月一次去海淀，大部分之间都是一个人。以前觉得舒适的生活，现在反而成了一种累赘，有点像情侣开始互不讨厌对方的一样。开始觉得生活没意思，寻找不到生活的乐趣。 生活本就没有意义，看你赋予它什么意义。 这段期间，做事开始来使生活有意义。 视频日记四月份左右陆续买了MacPro和Ipad之后，之前的windows电脑就给同学用了，所以写日记用了pages. 然而由于加班原因就没写了，在看了《阿凡达》后，男主使用视频日记觉得很cool，于是尝试录制视频日记： 其中有间隔的时间是用ipad在录没有传到电脑上。 看电影为了寻找生活的趣点，使生活变得有趣，让自己成为一个有趣的人，我也是煞费苦心。这时候开始琢磨看电影了，一系列的看。我在空间建立了一个《影视》相册，专门用来分享看过的比较好的电影： 看电影时我喜欢把一些好的画面截图，才有了这些照片，不是网上找的哦，当然有些烂片是没有截图的，凡是有点价值的电影基本都截图了吧。相册里的图片只是冰山一角，很多图片在ipad或电脑上并没有上传。 我喜欢一个系列的看，比如漫威系列，漫威系列的英雄电影有很多，基本都看完了，还特意总结了一篇文章：《漫威电影宇宙》。最初看《钢铁侠》时还看一部自己总结一个剧情或感受，到最后因为太多了，可能一天连续看大几部电影，之后基本就没有写了。当找不到电影看时，就去评分排行榜找，然后选没有看过的，依次往下面看。科幻、动作、爱情、剧情、喜剧，一般关注这些类型。 漫威系列 古惑仔系列 大话西游系列 教父 沉默的羔羊 … 因为片源不一样，开通了爱奇艺会员和腾讯会员，优酷之后支付宝做活动送了几个月的会员。那时候网吧很少去就是为了看电影。 看书没办法，爱好就这么多，看书兴趣很广泛。然而我想说的是：然并卵。我买了很多书，当时当当网活动，买100送100，所以两百的书，然而到现在为止，我看了大约三本而已。时间太宝贵，我还要看电影呢，看一本书需要几天的时间，而这几天我可以看n部电影，没有很大的必要性去看一本书，所以很多时间都没看。除非这本书非常吸引我，觉得非看不可。 《非暴力沟通》就是这样。这本书我花了三天时间看完了，精读，而且还做了很多笔记，改变了我很多认识和看法，也看清了很多，管理情绪和进行有效沟通很好。之后还没了实践篇来看，不过实践篇没有看完，感觉大同小异，主要是领会其中的思想。然后付诸于行动。只有付诸于实际才叫学习，不然就是读死书了。 得到通过朋友的介绍，知道一个软件，得到。也就是现在一直谈到了知识付费，里面是很多领域的资深人士，分享自己的看书笔记或者心得。订阅了《樊登读书会》、《万维钢·精英日课》、《罗辑思维》。当觉得生活不是自己想要的时候，都会去里面寻找答案，总能得到意想不到的东西。每个订阅差不多199元/年，罗辑思维除外。个人认为非常值得。 学习方式：刻意练习，及时反馈。 非暴力沟通 胜者通吃 … 感情 道路是拥挤的，但它是孤独的，因为它不是被爱的。 虽然我一直未提，但毫无疑问，很多时候感情是一个人的精神支柱。 由于我是一条单身狗，而且是一只独居的单身狗，这是多么的可怕，特别容易堕落。感情没有一个寄托，对于我来说是恐怖的。于是开始各种打电话。。每当觉得快失陷的时候，我就和好友打电话，好友很多时候也会说下生活的不愉快，我心里也就好受多了，原来不是我一个人觉得生活很难没意思，大家都这样觉得，哈哈，有没有很贱。。但确实如此，你会发现，很多人对生活是迷茫的，我曾经也是，缺失目标后就会感觉很迷茫，感觉生活无意义。 曙光 在得到里看到一句话：在影响圈里活动，而不是关注圈。 简书写作简书是很早之前下载的，最初只是用来看别人的文章而已。后来才尝试在里面写些东西。其实很多时候人的能力是被逼出来的，在加班结束之后，公司开始降薪，大家都开始注意提升自己的能力，准备找工作了。我也开始这样做，于是慢慢在学。当学习完后，总结一下，发到简书里，起初是写一些简单的文章，得到被人的“喜欢”之后，就会很有动力。这也符合“及时反馈”的效果吧。 之后就陆续开始写一些文章了，还有在CSDN上。被“喜欢”上的感觉，远远比打游戏来的过瘾。每篇文章都经过深思熟虑反复修改后发表的，发表之后有错误然而再重新编辑。 个人博客在GitHub逛多了以后，基本会发现，牛人一般会有自己的博客，就是像这样jingbin.me。为了跟上牛人的脚步，提升自己和找到一份好工作，花了两天时间，其中有一晚忙到了凌晨5点左右，终于搭建好了，高兴了好一阵子。 之后为了帮助其他小伙伴，避免他们走太多弯路，写了一遍博客，也是第一篇博客：《Mac搭建Hexo博客流程记录，排雷完成》（怎么感觉标题很low…），从此踏上了学习分享的路上，分享更是反馈，这样才是一个有效的系统，对于我来说不分享很难坚持下去，【刻意练习，及时反馈】，缺一不可。 开源项目 《云阅》一个仿网易云音乐UI，使用Gank.Io及豆瓣Api开发的开源项目这必须专门来说一下，这个项目花了大约三个月的时间，从最初准备到实施还有一系列文档，花费了大量的时间。几乎每天都忙到凌晨2点左右，包括双休，从那时候大概半年我就再没有去过网吧了。 撰写文档就花了元旦假期三天的时间，之后陆续发到简书，掘金和泡网上。因为自定义控件和设计模式都照着张鸿洋的CSDN博客写的，所以我马上投给了鸿洋的微信公众号上，由于投了以后就不能投在其他的公众号里，之后有很多人找我都被我拒绝了。 通过这个项目，我看了很多大牛的博客和开源项目，让我明确了自己的学习方式和学习路线。 离开公司原因，很多以前在一起的同事都慢慢离开了公司，有点伤感，工作上一直教我的辣公公上周五也走了。这段时间一直在准备简历和学习，为了找工作做准备。 准备南下去深圳了，一个人独居的时候应该已经结束了，深圳的有亲戚、同学，到时候可以一起耍，这段时间每个周末都会去一个景点，在北京这些时间把北京的景点几乎都逛完了，天安门、故宫、天坛、长城、什刹海、后海、南锣鼓巷、香山公园、王府井步行街，基本都结束了。 花了大半天时间写了这篇博客为在北京画一个完美的句号。 总结与体会 1.不知道干什么的时候，在网上查找这个阶段自己该做点什么，每天进步一点点，始终保持在正确的路上前进。 2.没有目标时会感到迷茫，需要设立阶段性的目标和短期目标。如做开源项目时，做出来发表这是阶段性目标，拆分成一个个短期目标就是界面搭建，api接入，文档整理，发表等。 3.从得到里看到，在影响圈里活动，而不是关注圈。尽量自己参与，如写作，写开源项目等。 4.学习要诀：刻意练习，及时反馈。学习使我快乐，使自己保持在学习状态中，停留在学习区，在学习区和舒适区里合理切换。 5.培养记录的习惯。在“奇妙清单”或“备忘录”里记录要做的事和一些临时的想法，然后一个个实施。脑袋是用来思考的，不是用来记事的，把事情交给这些记录软件。 6.找个感情基石。要有自己喜欢或爱着的人，没有试着去培养，赶快找个女朋友，哈哈。 最后2017-02-28 12:03 补：总结与体会2017-03-08 13:25 改：《喻世明言》→《醒世恒言》先到此为止，以后想到漏写了内容再补上。 起始时间：2017-02-27 周一 17:32 公司最后编辑：2017-03-08 周三 13:25 公司]]></content>
      <categories>
        <category>life</category>
      </categories>
      <tags>
        <tag>life</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 面试资料集锦]]></title>
    <url>%2F2017%2F02%2F20%2FAndroid%20%E9%9D%A2%E8%AF%95%E8%B5%84%E6%96%99%E9%9B%86%E9%94%A6%2F</url>
    <content type="text"><![CDATA[犹太法典:当你挽救了一条生命，你就等于挽救了全世界。 - 《辛德勒名单》 资源集 LearningNotes 记录一个自己的知识库 Android 名企面试题及涉及知识点整理 国内一线互联网公司内部面试题库 史上最全 Android 面试资料集合 Android 学习资料收集 Android面试一天一题 文章 Context都没弄明白，还怎么做Android开发？ Android中RelativeLayout和LinearLayout性能分析 TCP协议详解 图解 Android 事件分发机制 垃圾收集器与内存分配策略 内存缓存LruCache实现原理 HashMap实现原理分析 java面试题-HashMap原理 面试之Binder的认知 浅析HandlerThread 关于获取当前Activity的一些思考 - 弱引用相关 官方 Android官方培训课程中文版：熟悉Android开发基础知识 面试题集 要换工作? 来看看面试题吧,Java 面试题集 java面试题整理(更新…) Android基础面试题 数据结构与算法 常用的算法的时间复杂度和空间复杂度 Java常用排序算法/程序员必须掌握的8大排序算法 七大查找算法 Android的数据结构与算法—-ArrayList源码解析 安卓App热补丁动态修复 安卓App热补丁动态修复技术介绍 Android Hotfix 新方案——Amigo 源码解读 - 饿了么热修复框架 浅析android应用增量升级 多渠道打包 Android多渠道打包技术对比 美团Android自动化之旅—生成渠道包 下一代Android打包工具，100个渠道包只需要10秒钟【推荐】 面试经验 一个五年Android开发者百度、阿里、聚美、映客的面试心经 Android 面试那些事儿 震惊!这年Android面试的那些套路 简历模板 Android程序员简历模板 你真的会写简历么？ 写好一份技术简历很重要 80% 以上简历都是不合格的 推荐两个技术简历模板 关于程序员求职简历 复习点备忘 主界面viewpager嵌套viewpager滑动冲突（自己处理的还是Drawlayout处理的) 事件分发机制、消息机制 说到mvvm 你怎么看待mvp呢 开源的那个项目难点是啥 rxjava和retrofit，它们实现原理是啥 内存泄漏 性能优化 增量更新啊 热修复 插件化开发 apk瘦身技术 目前你知道事件冲突解决方式有哪几种 事件机制用到设计模式什么模式（责任链模式–&gt;源码） 结合android源码来分析设计模式 什么对象会被GCRoot引用 为什么butterkinfe效率高 databinding优缺点 写一个自定义控件 缓存和线程 md5，rsaa，RSA加密 进阶 Thinking in Java Effective Java Android 开发艺术探索(进阶必备) 第一行代码 阅读Android源码，理解一些高级概念（activity、view的内部运行机制：比如：aidl、JNI）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[♪ Music 如何在个人主页里插入音乐]]></title>
    <url>%2F2017%2F01%2F17%2F%E2%99%AA%20Music%20%E5%A6%82%E4%BD%95%E5%9C%A8%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5%E9%87%8C%E6%8F%92%E5%85%A5%E9%9F%B3%E4%B9%90%2F</url>
    <content type="text"><![CDATA[在自己的个人主页里插入喜欢的音乐有木有感觉很Cool呢，这里推荐四种形式： 1、MarkDown里插入单曲 2、MarkDown里插入歌单列表 3、MarkDown里插入歌单列表，宽度自适应且自动播放 4、新建菜单栏，以网页的形式插入 MarkDown里插入单曲 对应的字符串： 123&lt;object width="340" height="86" data="http://music.163.com/style/swf/widget.swf?sid=445154960&amp;type=2&amp;auto=0&amp;width=320&amp;height=66" type="application/x-shockwave-flash"&gt;&lt;/object&gt; 注意删掉中间的换行符。然后进入https://music.163.com/搜索自己要添加的音乐然后找到id，替换即可。见下图： MarkDown里插入歌单列表 对应字符串： 123&lt;object width="330" height="450" data="http://music.163.com/style/swf/widget.swf?sid=108250019&amp;type=0&amp;auto=0&amp;width=310&amp;height=430" type="application/x-shockwave-flash"&gt;&lt;/object&gt; 与上面的步骤类似，找到要添加的歌单的id，更换即可： MarkDown里插入歌单列表，宽度自适应且自动播放 对应字符串： 1234&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="600" height="330" src="http://music.163.com/outchain/player?type=0&amp;id=572758458&amp;auto=1&amp;height=430"&gt;&lt;/iframe&gt; 操作一样，只是引入的字符串变了而已。 新建菜单栏，以网页的形式插入这个有些许麻烦，以添加“云音乐”菜单为例： 主题_config.yml配置在主题文件夹的_config.yml里，添加需要添加的网页 source文件夹下然后在主题文件夹的source文件夹下，新建名为music.html的网页 music.html里的内容1234567891011121314151617181920&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-type&quot; content=&quot;text/html;charset=utf-8&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;object width=&quot;340&quot; height=&quot;86&quot; data=&quot;http://music.163.com/style/swf/widget.swf?sid=188900&amp;type=2&amp;auto=0&amp;width=320&amp;height=66&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;object width=&quot;330&quot; height=&quot;450&quot; data=&quot;http://music.163.com/style/swf/widget.swf?sid=108250019&amp;type=0&amp;auto=0&amp;width=310&amp;height=430&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt; &lt;/div&gt; &lt;hr /&gt; &lt;div&gt; &lt;object width=&quot;330&quot; height=&quot;450&quot; data=&quot;http://music.163.com/style/swf/widget.swf?sid=19971812&amp;type=0&amp;auto=0&amp;width=310&amp;height=430&quot; type=&quot;application/x-shockwave-flash&quot;&gt;&lt;/object&gt; &lt;/div&gt; &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;600&quot; height=&quot;450&quot; src=&quot;http://music.163.com/outchain/player?type=0&amp;id=108250019&amp;auto=1&amp;height=430&quot;&gt;&lt;/iframe&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; 里面内容的跟上面所述的基本一致，只是放在了网页而已，这种方式快捷，但是不易扩展，比如要添加图片不方便，建议以md文档的形式新建一个菜单栏。 更改菜单名这样设置以后网页就可以正常开启了，只是菜单名默认为Menu.Music，不太美观，为了和其他的名称效果一致，需要修改为对应的字符串。这时候在站点的配置文件里找到你之前设置过的显示的语言 然后找到对应的语言的文件夹内修改为自己想要的菜单名即可，示例请见：http://jingbin.me End 注意：如果你网站是https的，要把里面的播放的网络链接也改为https! 是不是很简单呢，动起手来吧~遇到什么问题可以联系我： 个人主页：http://jingbin.me 简书：Jingbin_]]></content>
      <categories>
        <category>music</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>music</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android - 仿网易云音乐歌单详情页]]></title>
    <url>%2F2017%2F01%2F13%2FAndroid%20-%20%E4%BB%BF%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E6%AD%8C%E5%8D%95%E8%AF%A6%E6%83%85%E9%A1%B5%2F</url>
    <content type="text"><![CDATA[前段时间模仿网易云音乐UI使用DataBinding做了一个App：CloudReader，今天把其中的类似歌单详情页单独拿出来说一下，我觉得其中还是有些干货的，关联到的知识点还比较有价值，而且也有很多需要注意的地方。 本次项目地址：ScrollShapeUI 效果图对比： 网易云音乐App原图： 模仿的效果图： 建议大家直接看CloudReader项目应用里的效果，里面的内容部分有加载中的loading图，效果更逼真。 基本布局：FrameLayout —– MyNestedScrollView // 为了Api23下的滑动兼容 —- LinearLayout // 内容部分 —– RelativeLayout —- ImageView // Toolbar后面的背景图 —- Toolbar // 标题栏 由于篇幅原因，不能做详细的介绍，这里就简单介绍实现这种效果的思路： 实现思路： 1、Activity设置自定义Shared Element切换动画 2、透明状态栏（透明Toolbar,使背景图上移） 3、Toolbar底部增加和背景一样的高斯模糊图，并上移图片（为了使背景图的底部作为Toolbar的背景） 4、上下滑动，通过NestedScrollView拿到移动的高度，同时调整Toolbar的背景图透明度 1、Activity设置自定义元素共享切换动画大家可以发现页面跳转时图片移动的是一个曲线路径，我们可以定制View的过渡切换效果，这是Material Design中比较常见的用法，Api21以上才有效。需要在开启页面时使用ActivityOptions.makeSceneTransitionAnimation()，其中定义共享的view和transitionName。然后在对应的Activity里创建ArcMotion对象。ArcMotion是PathMotion子类，是个曲线路径，对应代码片： 123456789101112131415161718192021222324 // Activity设置自定义 Shared Element切换动画 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; //定义ArcMotion ArcMotion arcMotion = new ArcMotion(); arcMotion.setMinimumHorizontalAngle(50f); arcMotion.setMinimumVerticalAngle(50f); //插值器，控制速度 Interpolator interpolator = AnimationUtils.loadInterpolator(this, android.R.interpolator.fast_out_slow_in); //实例化自定义的ChangeBounds CustomChangeBounds changeBounds = new CustomChangeBounds(); changeBounds.setPathMotion(arcMotion); changeBounds.setInterpolator(interpolator); changeBounds.addTarget(binding.include.ivOnePhoto); //将切换动画应用到当前的Activity的进入和返回 getWindow().setSharedElementEnterTransition(changeBounds); getWindow().setSharedElementReturnTransition(changeBounds); &#125;// 开启Intent intent = new Intent(context, MovieDetailActivity.class);intent.putExtra("bean", positionData);ActivityOptionsCompat options = ActivityOptionsCompat.makeSceneTransitionAnimation(context,imageView, CommonUtils.getString(R.string.transition_book_img));//与xml文件对应 ActivityCompat.startActivity(context, intent, options.toBundle()); 值得注意的是：因为加载图片要一点时间，切换页面时就会出现闪烁的情况，而如果取的是缓存就不会有这样的问题，所以这里有个小技巧，就是起初Glide加载的图片就指定固定的大小（.override(120,120)），这样图片就会被缓存起来，等到跳转时就取缓存。具体还请大家看项目源码。 2、透明状态栏12// 为头部是View的界面设置状态栏透明StatusBarUtil.setTranslucentImageHeader(this, 0, binding.titleToolBar); 其中内容根布局不要设置android:fitsSystemWindows=&quot;true&quot;,这样会额外添加一个状态栏。其中StatusBarUtil，是一个为Android App 设置状态栏的工具类。这里向大家推荐郭霖大神的一篇文章：Android状态栏微技巧，带你真正理解沉浸式模式，里面讲解了透明状态栏和沉浸式状态栏的渊源和有关设置用法。 3、Toolbar的背景图仔细分析后发现网易云音乐的Toolbar的背景其实显示的是高斯模糊图的底部，所以这里基本套路是Toolbar是透明的，后面背景图取的是高斯模糊图的底部一部分。 调整Toolbar背景图位置123456789101112// Toolbar的高度int toolbarHeight = binding.titleToolBar.getLayoutParams().height;// Toolbar+状态栏的高度 final int headerBgHeight = toolbarHeight + StatusBarUtil.getStatusBarHeight(this); // 使背景图向上移动到图片的最底端，保留Toolbar+状态栏的高度binding.ivTitleHeadBg.setVisibility(View.VISIBLE);ViewGroup.LayoutParams params = binding.ivTitleHeadBg.getLayoutParams();ViewGroup.MarginLayoutParams ivTitleHeadBgParams = (ViewGroup.MarginLayoutParams) binding.ivTitleHeadBg.getLayoutParams();int marginTop = params.height - headerBgHeight;ivTitleHeadBgParams.setMargins(0, -marginTop, 0, 0);binding.ivTitleHeadBg.setImageAlpha(0); 显示Toolbar背景图监听图片显示，在显示之后将其设置为透明色，然后在滑动的时候渐变。这里值得注意的是在设置图片时不要设置加载中的图片，不然初始化时达不到透明的效果。 123456789101112131415161718192021// 高斯模糊背景，加载后将背景设为透明 Glide.with(this).load(NeteasePlaylistActivity.IMAGE_URL_MEDIUM) //.placeholder(R.drawable.stackblur_default) .error(R.drawable.stackblur_default) .bitmapTransform(new BlurTransformation(this, 14, 3))// 设置高斯模糊 .listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123;//监听加载状态 @Override public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123; return false; &#125; @Override public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; // Toolbar背景设为透明 binding.titleToolBar.setBackgroundColor(Color.TRANSPARENT); // 背景图初始化为全透明 binding.ivTitleHeadBg.setImageAlpha(0); binding.ivTitleHeadBg.setVisibility(View.VISIBLE); return false; &#125; &#125;).into(binding.ivTitleHeadBg); 其中引入的库应为如下，将官方Glide的额外扩展了，使其可以支持高斯模糊。1compile 'jp.wasabeef:glide-transformations:2.0.1' 4、上下滑动，渐变背景图透明度由于NestedScrollView滚动监听只能在API23以上才能使用，这里为了兼容需要额外处理，定义滚动接口，具体：MyNestedScrollView 1234567891011121314151617181920/** * 根据页面滑动距离改变Header透明度方法 */private void scrollChangeHeader(int scrolledY) &#123; if (scrolledY &lt; 0) &#123; scrolledY = 0; &#125; float alpha = Math.abs(scrolledY) * 1.0f / (slidingDistance); Drawable drawable = binding.ivTitleHeadBg.getDrawable(); if (drawable != null) &#123; if (scrolledY &lt;= slidingDistance) &#123; // title部分的渐变 drawable.mutate().setAlpha((int) (alpha * 255)); binding.ivTitleHeadBg.setImageDrawable(drawable); &#125; else &#123; drawable.mutate().setAlpha(255); binding.ivTitleHeadBg.setImageDrawable(drawable); &#125; &#125;&#125; 这样基本的效果就实现啦，其中如有需要还可以做些额外的处理，如当背景图不透明时切换标题等~ 参考资料 http://www.jianshu.com/p/37e94f8b6f59 https://github.com/pinguo-zhouwei/YunMusicUI http://blog.csdn.net/u011734444/article/details/51471182 总结本人思考并实践了很多实现这个页面的方法，目前为止这个方案是最好的，效果体验几乎是一样，其中涉及到的知识点有：1、页面跳转共享元素曲线动画；2、透明状态栏；3、Glide监听图片加载状态和加载固定大小图片等；4、NestedScrollView在Api23下的滑动兼容。如果有更好的方案还请联系我，本次项目的源代码：https://github.com/youlookwhat/ScrollShapeUI。 欢迎关注我的简书和Gayhub]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>cloudreader</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[更新日志-云阅]]></title>
    <url>%2F2016%2F12%2F30%2F%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97-%E4%BA%91%E9%98%85%2F</url>
    <content type="text"><![CDATA[最后更新：2019-04-22 16：23 版本 2.8.0（2019-03-21） 1、[新增] 搜索页面 2、[修复] 隐藏书籍分类页面(api失效) 3、[修复] 修复收藏页面星星未选中的bug 版本 2.7.5（2019-03-13） 1、[升级] 玩android接口升级为https 2、[升级] RxJava2.x升级 3、[优化] 设置不能修改字体 4、[优化] 优化导航数据等页面 5、[修复] 代码优化及修改部分bug 版本 2.7.0（2019-02-14） 1、[新增] 知识体系详情页 2、[优化] 项目主页优化 版本 2.6.0（2019-01-16） 1、[新增] 豆瓣即将上映电影数据 2、[优化] 启动白屏问题优化 3、[优化] RecyclerView列表加载优化 4、[修复] 修复无邮箱应用时点击跳转崩溃问题 版本 V2.5.0（12-28） 1、[规范] 所有页面mvvm架构修正 2、[优化] 将电影和书籍放置在一块 3、[新增] 可为三方浏览器打开外部链接 4、[修复] 修复部分兼容性bug 版本 V2.2（12-05） 1、[新增] 进入首页可以获取剪切板的链接 2、[规范] 玩安卓模块mvvm修正 3、[优化] 导航数据界面显示优化 4、[优化] 电影、书籍和玩安卓首页等item点击效果 5、[修复] 保存图片权限问题、上拉加载逻辑问题 版本 V2.0（10-26） 1、[新增] 知识体系页面 2、[新增] 导航数据页面 3、[新增] 收藏网址功能 4、[更改] 固定图片链接替换 5、[更改] 暂时将书籍/段子页面移入我的收藏里 6、[修复] 段子头像显示不全修复 7、[优化] 首页ui及部分图片显示比例优化 版本 V1.9.6（08-21） 1、[优化] 界面优化 2、[优化] 代码优化 版本 V1.9.4（05-21） 1、[修复] 修复干货订制点击“选择分类”崩溃的bug 2、[新增] 干货订制页面长按item增加水波纹扩散效果 版本 V1.9.3（05-18） TODO：玩安卓 知识体系/导航 1、[新增] 玩安卓模块增加登录与收藏文章的功能 2、[新增] 增加Room的使用 3、[修复] 修复7.0以上系统主页显示错乱的bug 4、[完善] 性能优化之布局大幅优化 5、[完善] 完善体验修复若干bug 版本 V1.9.2（05-06） TODO：玩安卓登录/收藏网页等功能； 1、[完善] 主页显示结构修改 2、[修复] 去掉内涵段子数据 3、[修复] 解决“项目主页”页面两个布局的问题 4、[完善] 布局优化及解决部分bug 版本 V1.9.1（02-27） TODO：玩安卓登录/收藏网页等功能；书籍页面订制 1、[新增] 新增段子页面，长按条目可选择复制或分享 2、提示：app里的build.gradle pToken报错请用&quot;&quot;替代pToken。 版本 V1.9.0（2018-02-08） TODO：玩安卓登录/收藏网页等功能；段子页面等 1、首页大幅调整，增加进入玩安卓页面和Trending页面的入口 2、新增鸿洋玩安卓模块(部分功能) 3、优化WebView网页显示，解决大部分问题,详细 4、尽可能规范MvvM框架，后期会慢慢调整 5、使用fir.im更新接口，完善更新功能 版本 V1.8.3（11-14） 1、[修复] 已选择分类退出App再次进入,type失效的问题 2、[修复] 跳转B站视频显示网页错误的问题 版本 V1.8.2（3-30） 1、[修复] 首页轮播图显示异常问题 2、[修复] 干货订制页，刷新内容到底无内容后切换到其他类别，无法上拉加载的情况 版本 V1.8.1（3-7） 1、[修复]修复首页有六个以上item时，图片显示不出的bug 版本 V1.8.0（3-3） 1、[新增] 侧边栏增加“登录GitHub账号”和“退出应用”功能 2、[新增] WebView新增“分享到”、“复制链接”、“打开链接”功能 3、[新增] 使其系统更改字体无效 4、[改进] 网络请求更换成retrofit 2.x 5、[改进] 首页轮播图更换显示链接 6、[优化] 进入主界面动画优化 7、[优化] 兼容至7.0、升级关联库和代码优化等 由于换肤模块内存泄漏严重，已移除。以下不用看！包里面包含换肤相关文件。如要删除其文件可按下面步骤逐一删除。 换肤相关换肤由于关联的资源较多，正在完善中，但不影响正常的使用。如需查看换肤调试详情，可去菜单栏布局景“夜间模式”部分显示出来。植入夜间模式步骤与注意事项：步骤：1.关联： compile ‘skin.support:skin-support:1.0.1’ compile ‘skin.support:skin-support-design:0.0.2’ 2.“CloudReaderApplication.java”// 皮肤SkinMaterialManager.init(this);SkinCompatManager.init(this).loadSkin(); 3.BaseActivity和MainActivity继承“SkinCompatActivity.java” 4.新建”assets”，里面再建文件夹:”skins”，里面放置“night.skin”“night.skin”：是一个单独的app，只是改了后缀名，里面只存放要替换的资源文件。 5.加入开关和相关逻辑： 1234567891011121314public boolean getNightMode() &#123; return SPUtils.getNightMode(); &#125; public void onNightModeClick(View view) &#123; if (!SPUtils.getNightMode()) &#123; SkinCompatManager.getInstance().loadSkin(Constants.NIGHT_SKIN); &#125; else &#123; // 恢复应用默认皮肤 SkinCompatManager.getInstance().restoreDefaultTheme(); &#125; SPUtils.setNightMode(!SPUtils.getNightMode()); bind.dayNightSwitch.setChecked(SPUtils.getNightMode()); &#125; 6.由于不支持状态栏切换，所以需要手动加状态块，布局文件里已加入，但隐藏了，因为这样长按搜索图标提示会在下面不美观。暂时不实现此功能。 7.暂不支持TabLayout:tabBackground属性所以此部分的点击效果使用的是系统的，但觉得可以优化，没有这样做，还是想使用自己的选择器。 待更新内容（部分） 1、完善换肤功能 2、更换轮播图显示控件 3、新增段子和文章内容 版本 V1.5.0（1-29） 1、App体积大小从16M降到5.8M！ 2、将App里固定的图片以移动到七牛。 3、更改项目主页透明状态栏显示方式。 4、更改每日推荐图片显示规则，使其不重复显示。 5、更换过渡图图片。 6、代码优化；删除多余资源。 版本 V1.2.0（1-18） 1、更改每日推荐逻辑，使其一定有数据 2、干货集中营的item改为CardView展示 3、代码优化 版本 V1.1.0（1-15） 1.书籍详情页面增加自定义元素共享切换动画，并可简单添加需要支持的详情页 2.代码优化 3.其他 版本 V1.0.0（2017-1-1） 此版的具体说明请见项目主页：点击这里。 干货区（gank.io） 每日推荐 福利 干货订制 大安卓 电影区（豆瓣） 电影热映区 &amp; 豆瓣电影Top250 书籍区（豆瓣） 综合 文学 生活 抽屉界面 项目主页 扫码下载 问题反馈 关于云阅 待完善 不一定更新，依重要性而定。 每日推荐可输入日期来显示当日内容 保存图片按钮UI优化 toolbar标题栏文字滚动显示 增加干货、电影、书籍搜索功能。 书籍部分增加多个类别供更多数据选择，样式参考网易云音乐歌单筛选页 书籍部分adapter优化 每日推荐使用固定图是否太追求UI效果，改为一般的item阅读效果更佳？ 感谢您的关注~]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>cloudreader</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见问题-云阅]]></title>
    <url>%2F2016%2F12%2F25%2F%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98-%E4%BA%91%E9%98%85%2F</url>
    <content type="text"><![CDATA[大家好，为了帮助大家更加愉快的使用云阅开源项目，现将大家可能遇到的问题及产生原因列举在这里，希望能帮到大家。 1.为什么我安装不上App？本APP只支持Android 4.4及以上系统版本，低于这之下的版本是安装不上的哦。 2.为了网页一直显示“加载中…”？在App中打开的网页皆是外链，由于网速慢，或限时访问等问题有可能会导致访问失败，这时不妨试试其他网页或等一段时间再访问。 3.首页没有内容展示？由于使用的代码家gank.io提供的api，双休时是不更新的，如果双休有数据取得则是之前的缓存。 4.书籍或电影详情页一直访问失败？因为豆瓣api限制普通用于，每个ip每分钟请求次数是40次，超过ip会被暂时停用，一般为半小时左右，建议换到其他网络，或过一段时间再次访问。 5.点击更多进入详情页后返回要快速返回两次才有效。因为详情页是豆瓣提供的网页链接，我们这边无法处理，其他页面可能是正常的，谢谢。 6.部分页面卡顿由于作者是花费额外时间来开发此项目，所以有些地方没有优化完善，请多包容谅解。此项目已经经历了2年多的时间，诸多功能、代码规范和性能已基本完善，如对你有帮助，还请Star一下，谢谢！]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>cloudreader</tag>
        <tag>开源项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫威电影宇宙]]></title>
    <url>%2F2016%2F12%2F04%2F%E6%BC%AB%E5%A8%81%E5%AE%87%E5%AE%99%2F</url>
    <content type="text"><![CDATA[漫威电影宇宙漫威电影宇宙（Marvel Cinematic Universe，缩写为MCU），是由漫威影业（Marvel Studios）基于漫威漫画出版物中的角色独立制作的一系列电影所构成的共同的架空世界。它像漫画中的漫威主宇宙一样，是由共同的元素、设定、表演和角色通过跨界作品所建立的。 漫威电影宇宙独立于漫威宇宙（Earth-616）和终极宇宙（Earth-1610），编号为Earth-199999。 平行宇宙 漫威平行宇宙，例如616，199999这些，都是漫威宏大宇宙观里不同平行世界的地球编号。也许你们已经知道，钢铁侠，雷神，美国队长，这些我们所熟悉的伟大漫画英雄共同战斗在同一个世界中，相互往来，互相穿插，这，也是美漫的魅力之一。而简单来说，相对于我们真正生活的这个世界而言，漫画人物所身处的世界就是一个平行宇宙。他们的纽约，也有克莱斯勒大厦高高耸立，但与我们不同的是，那里，是黑帮老大，金并的资产;他们的地球，也曾遭受过两次世界大战的创伤，但与我们不同的是，众多的超级英雄们投身进入与纳粹的战斗。 地球199999MCU是漫威的复仇者联盟电影系列作品所在时空的简称，即Marvel Cinematic Universe，宇宙编号为Earth-199999。MCU 这个世界年龄很小，诞生至今，最多不过十年，但却用七年的成长书写了属于它的宇宙，千年的背景，未来的每周，它都会继续着讲述自己的故事，直到英雄落幕。 推荐观看顺序时间轴仅为时间发展顺序，仅作参考：《美国队长》→《探员卡特》→《特工卡特》→《钢铁侠》→《钢铁侠2》=&gt;《无敌浩克》→《神盾顾问》→《寻找雷神锤子路上发生的趣事》→《雷神》→《复仇者联盟》→《47号物品》→《钢铁侠3》→《王者万岁》→《神盾局特工》1-7集→《雷神2：黑暗世界》→《神盾局特工》8-16集→《美国队长2》→《神盾局特工》17-22集→《银河护卫队》→《神盾局特工第二季》1-19集→《复仇者联盟2：奥创纪元》→《神盾局特工第二季》20-22集（剧透部分已删，时间轴将《钢铁侠2》调整至《无敌浩克》之前，二者基本同时发生，从片尾来看《钢铁侠2》略早一点。将《顾问》调整至《无敌浩克》之后。） 拷贝了很多百度百科的描述之后，开始正式记录了.. 漫威漫画电影 复仇者复仇者联盟（2012年） 基于 宇宙魔方的战斗。宇宙魔方，拥有无穷的能量，是钢铁人把美国队长找回来时在海洋里带回来的，神盾局意在研究它制造武器。结果来自外星球（神域）的人（雷神的星球，他是雷神的弟弟）的抢夺。神盾局应付不来，于是请来了 美国队长，钢铁人，绿巨人，绿箭侠，黑寡妇，雷神众多的英雄一起对付，虽然刚开始有摩擦，到最后终究是齐心协力战胜了。最后，是钢铁侠推着原子弹进入了外星球把原子弹扔过去了，和他女朋友商量怎样重建他的工业大厦。 复仇者联盟2：奥创纪元 出现了双胞胎超能力的俩人（是美国队长2最后预示的），最初复仇者联盟成立之后一直在铲除九头蛇的人。遇到一个组织正在做奥创相关事情，这里面有一直存在里面的双胞胎姐弟。搞笑的一段是雷神在美国队长的盾牌上捶了一下把坦克给炸了。雷神的锤子没有人能拿得起，除了被钢铁侠创造出来的 幻，也是靠这个让大家服了，有一颗宝石在幻的头上，共有五颗宝石。他们去那组织带回来了奥创 ，即将完成的，然后放在斯塔克的大厦里，准备拿来创造新的纪元。然后被那个坏的把钢铁侠的人工智能机器人弄碎封闭了起来。最后双胞胎知道坏的那个想要毁灭地球，就背叛了他，弟弟为救“绿箭侠”牺牲了，姐姐使用魔法停住了火车，帮了很多。最后的奥创是被幻把电路的同化了。。剩下最后一个机器人，在谈话后也解决了。雷神和钢铁侠把在天空中的城市毁灭，才拯救了地球。 复仇者联盟3：无限之战I(2018年) 复仇者联盟3：无限战争》是复仇者联盟系列电影的第三部，是漫威电影宇宙的第十九部电影，本片将与《银河护卫队2》剧情连接[1] ，本片将会集齐所有漫威电影宇宙的超级英雄进行对抗灭霸，上演一场史无前例的拯救宇宙大战。漫威电影有史以来最强反派：灭霸登场。 复仇者联盟3：无限之战II(2019年) 《复仇者联盟3：无限战争（下）》（Avengers: Infinity War - Part II）是漫威影业出品的一部科幻动作电影，取材自漫威漫画，是漫威电影宇宙的第二十二部电影、同时也是《复仇者联盟》系列电影第三部的下集。由安东尼·罗素、乔·罗素兄弟执导，定于2019年5月3日美国上映。 银河护卫队银河护卫队(2014年) 自以为是的冒险家“星爵”彼得·奎尔在偷走一块神秘球体后成为赏金猎人的头号目标，原来邪恶反派罗南对此物体垂涎已久。为了逃脱无休止的追杀，奎尔被迫和四个格格不入的乌合之众结成同盟——手持机枪的火箭浣熊、树人格鲁特、凶残神秘的加美拉，以及复仇心切的毁灭者德拉克斯。然而当奎尔发现这颗球体蕴含的真正能量，以及它能给宇宙带来的巨大威胁时，他必须团结这群不入流的队友，破釜沉舟、决一死战，才有可能解救整个银河系。 银河护卫队：第二章(2017年) 在《银河护卫队》中，星爵的父亲惊鸿一瞥，被称为“古老的外星人”而被人所惦记。而《银河护卫队2》或许会从这位神秘的人物身上开始自己故事的讲述。影片的导演詹姆斯·古恩表示，这部电影将继续把故事主线放在星爵一家的关系之上，这次，将讲述的是星爵的父亲。他说：“这会是一个关于父亲们（fathers）的故事，所以我很期待故事的进展和最终的成品。”另外，由于银河护卫队系列联系到漫威宇宙，《银河护卫队2》中可能会出现未曾出现的最后一颗无限宝石。 异人族（延期） 地球时间数百万年前，宇宙两大种族Kree人和Skrull人发生了战争，为战略需要，Kree人来到太阳系，在天王星上设立了工作站。不久他们对当时地球生命的遗传潜能发生了兴趣，于是他们在当时的智人身上进行了一系列试验。这类试验的显然有双重意义，一是为了研究并防止自身进化中可能出现的停滞现象，同时为当时的战场制造一种强大的变种士兵。然而，当他们成功地创造出一群拥有非凡能力的人形物种时，不知什么原因，Kree人遗弃了他们的试验产物。 这个种群——异人族（Inhumans），在之后的日子里开始自我发展，他们发展出了自己的社会制度；与世隔离的生活使得他们拥有超越人类的先进技术。通过Terrigen雾，他们得到了各式各样的超能力，但同时也造成了基因的损坏与畸形。这导致一个长期的选育计划的实施，目的是为了减轻这些变异。他们的城市Attilan经常迁移，截至2005年的故事，Attilan已搬迁到了月球上的Blue Area。 浩克环球影业 绿巨人（2003年） 本名罗伯特·布鲁斯·班纳（Robert Bruce Banner），是一位天才核子物理学博士，在一次意外中为了保护同事而被自己制造出的伽玛炸弹（Gamma Bomb）放射线大量辐射，身体产生异变，后每当他情绪激动心跳加速的时候就会变成名为浩克的绿色怪物。由于变身后往往不受控制、所以为了不伤害自己周围的人、班纳游走于世界各地寻找控制愤怒的方法、即便如此班纳的浩克身份还是时常会造成毁灭性的破坏、因此常成为警方与有关单位追捕的对象。 漫威电影宇宙 无敌浩克（2008年） 故事讲述科学家布鲁斯·班纳（爱德华·诺顿饰）继续绝望地寻找能治愈他那被γ辐射毒害的体内细胞之疗法，以及解除那蕴藏体内、不受约束的另一个自己──绿巨人。 活在孤独及没有爱人的阴霾之下，布斯在治疗过程中还需过五关斩六将，一方面需逃避不断找寻他、扰人的复仇者霹雳将军罗斯（威廉·赫特饰）；另一方面要逃离一直欲捉拿他、利用他的异能之残暴军方。当布鲁斯在治疗上有了重大突破，变回常人的日子近在眼前之际，另一股同样拥有恐怖摧毁程度的力量突然出现。布斯眼看一切努力与心血快要毁于一旦，决定作出一次前所未有的反击。 钢铁侠钢铁侠（2008年） 被绑架时，被迫制造了第一个钢铁人，绑架的他是他的公司合伙人，然后挖走了他的供能芯片，最后基地爆炸把合伙人终结（女主引爆）。 钢铁侠2（2010年） 又一天才物理学家，因四十年前对他父亲造成惨败，怀恨在心，制造出一个仿冒的供能芯片，在赛车场和他决斗，被抓住后，被一位参议院解救，并利用他的资源，做了很多钢铁人（并会自爆）。最后和少尉的钢铁侠冲击波对冲炸掉了那个自制的仿冒钢铁侠。并在危急时刻解救了女主，抱到了阳台上，正式确定关系。 钢铁侠3（2013年） 因自己的自大，伤害了一位做人脑DNA研究的人（AIM），让他在阳台等了一晚上。后来变成恶人，和副总统合作，意在杀死总统。对方能是自己的NDA重组，不怕伤害，自动修复，身体能达到3000℃的高温，爆炸找不到弹片且威力巨大。将药打入女主的身体里，最后使得女主变体。干掉了攻击她的钢铁人，和那个恶人。最后，女主被治好，钢铁侠也取出了身体里一直存在的弹片（第一部被自己的炸弹爆炸植入）。 雷神雷神（2011年） 《雷神》的故事发生在现今的地球以及艾斯卡的奇幻世界。故事的中心人物是拥有强大神力的雷神托尔（Thor），但是他自大鲁莽的行为掀起了一场古老的战争，他也因此被贬入凡间作为惩罚，被迫与人类一同生活。托尔必须学会如何成为一个真正的英雄，才能对抗来自神界的强大黑暗势力。《雷神》一片探讨一个人的传奇冒险，他从一个傲慢自大的神界王位继承人被贬入凡间，他必须成为一名超级英雄才能登上王位。 雷神2：黑暗世界（2013年） 剧情承接《复仇者联盟》，讲诉了在纽约大战结束一年后，押送着弟弟洛基（汤姆·希德勒斯顿 Tom Hiddleston 饰）回到神域接受审判的雷神托尔（克里斯·海姆斯沃斯 Chris Hemsworth 饰）将面对一股远古黑暗势力的挑战——复仇心切的黑暗精灵首领马勒凯斯（克里斯托弗·埃克莱斯顿 Christopher Eccleston 饰）率领神秘而强大的种族卷土重来，了解他们的人只有一个——洛基。托尔不得不向洛基寻求帮助，并与之结盟，踏上有生以来最危险的征程——这次旅途固然会令他与地球恋人简·福斯特（娜塔丽·波特曼 Natalie Portman 饰）久别重逢，但也将迫使他牺牲一切，唯此才能拯救整个宇宙。 雷神3：诸神黄昏（2017年） 漫威旗下的超级英雄电影系列已经成为了迪士尼的摇钱树，目前，《雷神》系列第3部已经正在前期准备中。漫威日前宣布了担任这部续作的编剧人选：克里斯托弗·约斯特（《雷神2：黑暗世界》的编剧）与克雷格·凯尔。后者其实是漫威影业制片部的高级副总裁。 美国队长1990年系列美国队长（1990年） 无具体记录 漫威电影宇宙美国队长：复仇者先锋（2011年） 美国队长小的时候目标明确:保卫国家。但因为身体不好一直难以入选当兵。他一起的叫“冬兵”，是美队3里面的称呼。比他高大，做到了中尉级别。然后队长被博士发觉，看他善良，深刻的一幕是:扔了一个手榴弹过去，其他人都跑开了，队长把手榴弹跑在怀里，让别人走开。然后队长进行实验，成了很强壮，能力很强的人。在“冬兵”的帮助下，打败了红骷髅将军，宇宙魔方掉在了海里，将军消失了。冬兵掉在了悬崖下，但他是经过实验的，被九头蛇的人发现了，用来作为杀手。出现在美队2。（自己记录） 斯蒂夫·罗杰斯是出生于经济大萧条时期的一个家境贫寒的脆弱青年。因为看到纳粹在欧洲肆虐侵略的新闻而想入伍参军。但因为体弱多病被拒绝了。无意中得知了斯蒂夫·罗杰斯真心愿望的切斯特·菲利普斯将军决定给他一个机会，让他参加“重生计划”。经过几个星期的测试，斯蒂夫·罗杰斯被注射了超级士兵的血清并被用紫外线照射轰击，终于拥有了人类可能拥有的最完美躯体。 接着他接受了身体和战术上的训练。三个月后，他得到了作为“美国队长”的第一份任务，带着坚不可摧的盾牌和深谙战术的头脑，他投入了与红骷髅的斗争，最终阻止了红骷髅的邪恶计划，但是自己也因此被冰封，直到70年后才醒来。 美国队长2（2014年） 九头蛇的人渗透在神盾局。美国队长，猎鹰（有翅膀的那个），黑寡妇，神盾局局长（独眼龙）三人，闯入神盾局，安放三个芯片，使三个航母互相开火毁灭可。冬兵被派去打美国队长，但最后由于美国队长的一再劝说，美队掉入水中也是冬兵救的。（最后，钢铁侠中，一直针对他的一个官员也是九头蛇的，也被逮捕了。在《钢铁侠》中，那个官员被要求，给钢铁侠颁发奖章）（自己记录） 在经历了《复仇者联盟》的纽约大战后，美国队长史蒂夫·罗杰斯如今在华盛顿过着恬淡的生活，努力尝试着融入现代社会。然而当一名神盾局同事遭遇袭击后，史蒂夫被迫卷入了一场威胁全球安危的阴谋。他与黑寡妇携手出击，一边防备欲将自己灭口的杀手，一边努力揭露这个巨大阴谋的真面目。而当敌人的邪恶计划全局曝光后，美国队长和黑寡妇得到了一位新同盟“猎鹰”的协助。然而他们也发现自己将要面临的，是前所未遇、出乎意料的黑暗劲敌——冬兵。 美国队长3：内战（2016年） 因为解救人时出现了很多伤害民众的事件，复仇者联盟被要求被组织制约。美队不同意，也许是之前被组织背叛过。钢铁侠同意。国王被炸身亡后，出现了冬兵的影子，误认为是冬兵行动了，化身“黑豹”要杀了冬兵，被美队救下。最后冬兵被抓，一名被意外杀害了父母的人，找到了冬兵的“激活码”，让冬兵制造了杀戮。钢铁侠领着一批人和美队引着的一批人对打。最后钢铁侠发现自己错了，一起和美队去抓那个背后的人。那个人给看了一段视频，放的是，钢铁侠的父母被 九头蛇操控了的冬兵杀害了的事实。然后就彻底开战了。打到最后钢铁侠被打道，美队用盾牌打掉了钢铁侠胸前的电源。钢铁侠说盾牌是他父亲造的，然后就把盾牌丢了。背后的人 被黑豹交给了神盾局。冬兵也被美国队长带到黑豹那冰冻了起来。（自己记录） 在奥创对这个世界造成了巨大的影响之后，复仇者联盟还是团结一致保护人类的。但是在一些政治角力的背后，政府中有人认为是有必要控制一下这些超级英雄的超自然能力和他们的行动了。于是，一项管控措施出台。这个措施就是要求复联按照政府的要求来行动。任务的开展、进程和结束，都要由政府主导。这个管控措施在复联中引起了极大的争议。意见最极端、最两极分化不可调和的，就是钢铁侠和美国队长之间的问题，于是，这两个同盟者之间的矛盾就此爆发了出来。而复联的“内战”也不可避免的爆发。 蚁人蚁人（2015年） 行骗为生的斯科特·朗（保罗·路德饰），在偷了生化学家汉克·皮姆博士（迈克尔·道格拉斯饰）发明的蚁人战服后，拥有了自由收缩身体大小的超能力。汉克·皮姆博士开发出一种“皮姆粒子”，并和斯科特·朗一同成为“蚁人”。斯科特也不得不接受自己的英雄身份，并帮助皮姆博士守护蚁人技术之谜。在强大的敌人威胁下，两人必须精心策划并执行一场惊天骗局来拯救世界维护和平。 蚁人与黄蜂女（2018年） 《蚁人与黄蜂女》（Ant-Man and the Wasp），是漫威影业出品的一部科幻动作电影，取材自漫威漫画，是漫威电影宇宙的第二十部电影、同时也是《蚁人》系列电影的第二部。影片将在2018年7月6日上映。 奇异博士电视电影：奇异博士（1978年） 无记录 漫威电影宇宙：奇异博士（2016年） 性格高傲的神经外科手术专家史蒂芬·斯特兰奇（本尼迪克特·康伯巴奇饰）事业有成，在遭遇一次车祸悲剧后，双手再也无法握住手术刀，不能继续他的医生职业，为了治疗他的伤，他远赴尼泊尔费尽千辛万苦见到了古一法师（蒂尔达·斯文顿饰），斯蒂芬-斯特兰奇把自己曾经的自负都抛在了一边，开始接触和学习鲜为人知的玄学、以及多维空间世界的学问。在纽约的格林威治村，变身奇异博士的斯特兰奇，现实世界和多维空间的中间人，他利用超自然能力和神器来保护着世界，更要与力量强大党羽众多的卡西利亚斯（麦斯·米科尔森饰）一决高下，来拯救即将崩塌的多维世界。 黑豹（2018年） 黑豹（Black Panther）是美国漫威漫画旗下超级英雄，初次登场于《神奇四侠》第52期（1966年7月），由编辑斯坦·李以及漫画家杰克·科比共同创造，是第一位在主流美国漫画公司登场的非讽刺黑人超级英雄。本名特查拉（T’Challa），是非洲国家瓦坎达（Wakanda）的国王。为了使自己的国家变得更加富强，少年时的特查拉王子便前往英国留学，后毕业于牛津大学，在其父——前任黑豹特查卡（T’Chaka）死后，接任瓦坎达的国王。同时，黑豹也是一名杰出的科学家，还是复仇者联盟的成员之一，此外他的前妻则是X战警成员暴风女。 惊奇队长（2019年） 黑寡妇的独立电影遥遥无期，《惊奇队长》则成为漫威旗下第一部以女性为主角的超级英雄电影。漫威漫画中有男版和女版两位惊奇队长，而现任惊奇队长则是一名名为Carol Danvers的女士。凯文·费奇也在昨日的发布会表示这是一部以女惊奇队长为主角的电影。目前主演人选尚未确定。惊奇女士是复仇者联盟成员之一，因与外星人的接触而获得超乎于常人的力量和对痛苦的忍耐力，令人敬畏的物理伤害抵御能力，飞行能力和预知能力。 蜘蛛侠蜘蛛侠蜘蛛侠（2002年） 影片主要讲述彼特天性开朗，腼腆中仍包藏着一份单纯。拯救他的是一只哥伦比亚大学实验室的特殊蜘蛛，咬了他一口后，他眼镜消失了、脸蛋英俊了、肌肉发达了。遵循优良品种嫁接的原理，彼特当然也自动具有了撒网、织网、弹跳、飞跃、倒贴天花板的本事。彼特有了特异功能，叔父对他谆谆教诲：“能力越大，责任也越大。” 蜘蛛侠2（2004年） 《蜘蛛侠2》的故事发生在第1集结束2年后，彼得·帕克继续过着自己的双重生活，平时是性情温和的大学生，晚上则化身为拥有超能力的英雄蜘蛛侠，可是这两者之间的微妙平衡却越来越难以维系，爱人、朋友和慈爱的阿姨都开始怀疑他的真实身份；同时他还多了个更可怕的敌人——章鱼博士，彼得·帕克必须用尽全力对付这位邪恶魔头的疯狂计划。 蜘蛛侠3（2007年） 影片讲述在经历了重重考验之后，代表正义的蜘蛛侠成为了人人敬仰的正义英雄，抱得美人归。但是，被“毒液”共生体寄生下的帕克开始变得目中无人，邪恶开始在他的心中反客为主。蜘蛛侠的道德准则越来越模糊。 超凡蜘蛛侠超凡蜘蛛俠（2012年） 作为这个世界上最具有吸引力、最受追捧的超级英雄之一，与“蜘蛛侠”有关的文化传奇终于展开了一个全新的故事篇章，这一次重点强调的则是彼得·帕克（安德鲁·加菲尔德饰）不为人知的另一面。作为一个总是没办法融入到周遭环境的高中生，彼得很小的时候就被父母遗弃了，由他的叔叔本（马丁·辛饰）和婶子梅（莎莉·菲尔德饰）抚养长大。与大多数他这个年纪的少年一样，在当今这样一个大环境下，彼得也在尝试着寻找到那个真实的自我，他想知道自己到底是谁，来自于何处；与此同时，他还一直在摸索当中，不知道应该如何与自己的初恋格温·斯泰西（艾玛·斯通饰）坦然的相处，他们一起在爱、承诺与秘密中奋力的挣扎着。 随着彼得在无意之中发现了一个神秘的公文包，显然是属于他的亲生父亲的，也迫使着他展开了一场探寻真相的揭秘之旅，他要弄明白他的父母失踪的真正原因。遵循着自己所能收集到的蛛丝马迹，彼得径直来到了他爸爸曾经的搭档科特·康纳斯博士（瑞斯·伊凡斯饰）的实验室……然后，意外发生了，彼得化身成为了“蜘蛛侠”，与科特的另外一个身份——“蜥蜴人”展开了激烈的碰撞与对决，他需要做出的是足以改变一生的决定和选择，那就是利用超能力重新塑造属于他的命运，然后成为一个真正意义上的英雄。 超凡蜘蛛俠2（2014年） 彼得·帕克（安德鲁·加菲尔德饰）依然很忙，因为他一边要作为正常人谈恋爱，一边要变身蜘蛛侠打坏人。而格温（艾玛·斯通饰）高中还没毕业，彼得·帕克给格温父亲承诺过要以远离她的方式保护她，但他显然做不到。当一个新的大反派“电光人”（杰米·福克斯饰）出现后，彼得·帕克的生活更加不得安宁。一个老朋友哈利·奥斯本（戴恩·德哈恩饰）回归，帕克发现了关于他自己身世的新线索。 漫威电影宇宙蜘蛛侠：返校日（2017年） 正在拍摄中的《蜘蛛侠：返校节》近日传出片场照，确认了一个新反派：除迈克尔·基顿饰演的秃鹫，反派团体“邪恶六人组”另外一位成员惊悚（Shocker）也会在电影中出现，由Bokeem Woodbine饰演。之前就有些传言称惊悚会现身，如今看来他的造型比起漫画，更像《超凡蜘蛛侠2》游戏中的样子。 刀锋战士刀锋战士（1998年） 刀锋（韦斯利·斯奈普斯饰）自小就被专门打造新式武器的吸血鬼猎人亚伯拉罕·惠斯勒（克里斯·克里斯托佛森饰）收养，专门出入有吸血鬼出没的场所，拯救即将被消灭吞噬的人类，凭着他驾骑着机车，手持无敌火力的巨型火焰枪，以及无敌旋风刀和身后背负着的那把长剑，不死的无敌战神刀锋战士所向披靡，只要他一出现，躲藏在人群当中的吸血鬼将无所遁形。 于是，在这个未来的世界中，刀锋战士成了人类和吸血鬼双方争夺生存空间下最勇猛的正义战士，也因此，吸血鬼领袖狄肯·费斯（斯蒂芬·多尔夫饰）处心积虑要除去这心头大患，以完成他一统天下的大梦，他先利用刀锋战士的心理弱点给他致命的攻击，原来，刀锋出身时被吸血鬼血液浸满子宫，也成了半个吸血鬼，必须随时克制着自己对血的渴望。 狄肯·费斯先是邀请刀锋战士加入邪恶势力的一方，只要他们两方联手，相信没有人可以逃过他们的力量，然而刀锋战士作为献祭品以请出血王，增强自己的力量。在正邪双方的互斗之下，究竟谁才能获得最后的胜利。 刀锋战士2（2002年） 刀锋（韦斯利·斯奈普斯饰）的朋友惠斯勒（克里斯·克里斯托佛森饰）被一群吸血鬼捉去，被放进一个储藏罐里保鲜，供他们随时解渴。刀锋一路杀来救出了威斯勒，然后给他注入了抗病毒的药物，使他恢复了人的常态。但他们还没来得及叙旧，吸血鬼王国竟派信使来求援，他们请刀锋帮助打击一种威胁所有吸血鬼和人类的突变的吸血怪物，他们说这股吸血鬼新势力名为“收割机”。就这样，一种可以轻易使人变成怪物的名叫“收割机”的家伙使刀锋战士和本来势不两立的“采血包”吸血鬼暂时结为同盟。 “收割机”嗜血如命，但它们不是用嘴吸血，实际上，在它们的手掌中央有些细密的针管，就是说，只要它们把手放在你的身上就可以饱餐一顿。吸血鬼王国的内阁派出一直接受严格训练，本来是准备用来暗杀刀锋的突击队去和刀锋合作。为表示诚意，他们还特地派来美丽的妮莎（莱昂·维埃拉饰）协助刀锋战士。带着新机械师斯克斯和美女，刀锋战士准备向这些突变的吸血鬼恶棍开战了。 刀锋战士3（2004年） 在遥远的沙漠深处，一些吸血鬼正在试图让能产下更多吸血鬼的恐怖怪物复活，他就是德雷克（多米尼克·珀塞尔饰），这个可怕的吸血鬼拥有一种特殊的力量可以使自己在白天还能自由行动。如此以来，刀锋战士所面临的形式便更为严峻。此时，吸血鬼的领袖还对刀锋战士实施了一项恶毒的诽谤计划，他们把刀锋战士定义为了一个杀人怪物，制作了种种伪证并将它们送给了FBI，致使刀锋战士成为了FBI抓捕的对象。在刀锋战士和他的导师惠斯勒（克里斯·克里斯多佛森饰）与FBI探员坎伯兰得（詹姆斯·瑞马尔饰）以及他的手下进行了一次火药味十足的摊牌以后，刀锋战士极不情愿地与一群由人类组成的猎捕吸血鬼的小队结成了同盟，这个小队的头儿正是惠斯勒的漂亮女儿阿尔贝特（杰西卡·贝尔饰）和俏皮话满天飞的汉尼拔·金（瑞安·雷诺兹饰）。 当科学家萨姆菲尔德(娜塔莎·雷昂饰)一直在潜心研究以便可以制造出对付吸血鬼的终极溶液时，阿比盖尔带领的小队正与由强大的吸血鬼丹尼卡·塔罗斯(帕克·波西饰)所领导的一帮不死吸血鬼以及她那带有毒牙的随从们进行着一系列无情的厮杀。最终，刀锋战士发现他自己正在慢慢变成一个最为强大的吸血鬼，他的命运以及整个人类的命运都安危未定。 夜魔侠/艾丽卡夜魔侠（2003年） 又名超胆侠。影片主要讲述马特·默多克幼时意外双目失明，却也意外增强其余感官能力，在父亲遭歹徒袭击横死街头后，马特誓言为无辜受害者报复。白天是律师的他，晚上就化身超胆侠，将法律无法伸张的恶徒就地正法。 艾丽卡（2005年） 影片围绕一个雇佣杀手Elektra Natchios，她是一个杀手组织Hand训练、培养出来的一个杀手中的精英。Elektra接受了最新的刺杀任务，而目标包括一个13岁的小女孩Abby，Elektra不忍下手，后来更和Abby成为朋友。 惩罚者惩罚者（2004年） 弗兰克·卡斯特（Frank Castle）是原美国海军陆战队出身的军人，在越战退伍后担任部队训练教官，在与妻儿某日在公园聚餐时因目睹黑道私刑事件而一家三口当场惨遭黑道开枪灭口，侥幸伤重未死的弗兰克在出院后，运用自己的情报系统找出杀害妻儿的凶手并诉诸法律，但黑道却以各种管道和法律漏洞逃过制裁，对司法彻底感到绝望的弗兰克为了替妻儿报仇，决定以自己的方式诉诸武力来替妻儿讨回公道，并且对于任何罪犯都采取杀无赦的制裁手段。 他的做法太过于残暴，以至于很多的英雄都看不惯他的做法。 在大事件“内战”中，救了从钢铁侠那逃出来的蜘蛛侠，并送到了美国队长的据点。他还请求加入美国队长的队伍中，遭到了一些英雄的反对。途中，有两名罪犯也想加入美国队长的队伍中，惩罚者不由分说的杀了他们，这激怒了队长，队长打了他一顿，叫人把他送走了。 “黑暗王朝”时期，惩罚者被黑暗金刚狼戴肯所杀，但得到血石的力量暂时成为科学怪人，并与戴肯大战一场。目前，惩罚者已经恢复原来人体，继续自己的惩罚事业。 惩罚者2：战争特区（2009年） 本想归隐田园，与家人共度天伦的FBI探员弗兰克·卡斯特，无奈的在黑帮杀掉妻儿之后走向了黑暗复仇的不归路。弗兰克·卡斯特大难不死，在悲痛过后开始成为这个城市里隐秘的“惩罚者”，在黑暗中打击那些猖狂的犯罪分子的头号先锋。在处决了城内走私行当的龙头老大之后，惩罚者的名声鹊起，因此也令城内不少罪犯闻风丧胆，而他也就继续穿着代表惩罚者的骷髅制服，穿梭在这个充满罪恶的都市中。 可偏偏就有不信邪的人出现，一名新崛起的黑帮份子比利开始向惩罚者叫嚣，并且还要统领城内各大帮派，大有和惩罚者正面对决的气势。一番激斗之后，比利最终还是败在惩罚者的枪下。 不过出乎所有人意料的是，比利并没有成为弗兰克的枪下游魂。他竟然幸存了下来。但他的脸已经严重损毁，看上去好似一副混乱至极的拼图。在复仇烈焰的灼烧下，比利正式埋葬了自己，化名为“拼图”重出江湖。这时又一个奇怪而恐怖的人物出现了，从某种程度上来说他与弗兰克很相似，不论是当初坚定的复仇意志，还是绝不留情干净利落的冷血手法，但“拼图”的野心可不仅仅限于此，他还要将城内的黑帮一一吞并，自然这些帮派的头目也成了他砧板之肉。虽然这在一定程度上等于协助了弗兰克的工作，但敌人就是敌人。而在弗兰克逐步调查“拼图”的过程中，他惊讶地发现，事实的真相远非一般人能够承担。不过对于惩罚者来说，回应暴力的只有更加强大的暴力。 恶灵骑士恶灵骑士（2007年） 初代恶灵骑士本名乔纳森·布雷泽（Jonathan Blaze），简称强尼·布雷泽（Johnny Blaze），原是一名摩托车特技车手，为了拯救患癌养父便和魔鬼墨菲斯托做了交易而被邪灵扎坦诺斯附身，随后得到了控制地狱火的力量和可以让罪恶感受到痛苦的审判之眼。强尼成为了追求复仇的恶灵骑士。 灵魂战车2：复仇时刻（2012年） 该片讲述了强尼·布雷兹为救病重父亲和魔鬼做了交易，把灵魂卖给了魔鬼，布雷兹被一个古代恶魔附身，他化身为幽灵骑士。神父莫洛来到布雷兹的住处请布雷兹帮他找一个男孩，并答应作为回报，帮助布雷兹解除诅咒的故事。 X战警X战警X战警（2000年） 镭射眼（X战警的队长，可由两眼射出致命雷射光）、琴葛蕾（有心电感应、隔空取物，及瞬间移动的能力）、暴风女（X战警的副队长，拥有控制气候的能力）是X战警的核心人物。 而X战警队伍来了一位危险人物——金刚狼（拥有超强的回复能力，两腕上有超合金的金钢爪）是个脾气暴躁，几乎不受控制的变种人，使X战警内部危机四伏。X战警让它训练新兵，并想吸收它加入自己的行列。但无人知道它的来历，不久又发现它的大部分思维受外人操纵。更糟的是，又一种突变生物“万磁王”出现了，它能控制磁力和地球引力。它曾被人类当作怪物巡回展出，饱受屈辱。它憎恨人类，认为突变生物比人类更优秀，应该主宰人类。它和“金钢狼”携手为实现这一目标而不择手段。 而誓死保卫人类的X战警，将会发现他们在尽力保卫人类之时，人类也对他们也产生了极大的恐惧，双方关系渐渐紧绷。再加上X战警得面对金钢狼一触即发的脾气，与万磁王的到处杀戮，X战警陷入了进退两难的重重危机中[2] 。 X战警2（2003年） 故事开场紧接着第一集的结尾，“金刚狼”罗根为了找回自己过去的记忆离开了X教授的学校，隐姓埋名前往艾卡里湖（AkaliLake）工业中心；另一边，人类议会正忙于重建在变种人大战中受到重创的自由女神像；万磁王则继续在X教授精心打造的塑料监狱中服刑。从表面上看这个世界似乎渐渐回复了正常，但是X战警们没有察觉到，在这个世界的黑暗深处，新的阴谋正在悄悄临近，包括富有正义感的X战警在内的变种人。在普通人眼中代表着社会新物种对旧人类的挑战与威胁，因此他们必须在充满歧视和敌意的环境里挣扎求存。金刚狼的身世也将在本集中进一步揭开。 战警3：最后之战（2006年） 又称背水一战。在《X战警2》中，由于军方科学家的离间，人类对变种人的愤恨与压制彻底越过了底线，X教授与其带领的身怀绝技的X特警们面对着和解的难题与反抗的抉择，而一心企图令变种人称霸世界的万磁王摆脱囚禁后变得更为强大而狡猾。 三方都吸收了更庞大的新鲜力量，一场前所未有的人种之战剑拔弩张。与此同时，金刚狼和独眼龙还没能从痛失我爱中自拔，珍葛蕾却如凤凰涅磐般奇迹地回到战友中间。众人欣喜之外，却发觉她的性格变得狂乱分裂，甚至有倒戈相向的倾向，让X教授等对水坝一役后她死里逃生的经历不禁生疑。而在黑凤凰缺席的时间里，风暴女和金刚狼通力合作，日渐生情。沿着上集的线索，逐渐觉醒的金刚狼也破译了自己的基因密码。四人再聚首，感情的纠葛与身世的秘密和变种人的未来一样愈发扑朔迷离。人类已经按捺不住对自身势力受胁迫的恐惧，向变种人正式宣战。X教授虽坚持和平发展论，但在生死存亡之际，不得不与万磁王再次联手，为变种人的生存权利作最后一搏。而变种人内部关系也因为对仇恨的不同解读而势成水火，一位重要角色将因此牺牲。X战警必须自保并防止万磁王的野心在变种人中蔓延。 X战警：第一战（2011年） 影片将背景设在60年代古巴导弹危机发生时，讲述在变种人未被世人所知的时候，Charles Xavier和Erik Lensherr还没有被人称作“X教授”和“万磁王”。他们只是变种人中最早发现自己超能力的两个年轻人。他们那时也不是对手，而是非常亲密的朋友。两人以及其他几个变种人在一起工作，试图阻止“末日”的到来。但在这个过程中，两人之间出现了裂缝，最终，在万磁王的兄弟会与X教授率领的X战警之间，一场永恒之战开始了。 X战警：逆转未来（2014年） 故事发生在并不遥远的未来，X战警遭遇了史上最大的生存危机，他们必须回到过去拯救自己的命运。X战警也许在我们这个时代，是有着最先进基因的生物，但在不久的未来，他们都被“特拉斯克工业”创始人玻利瓦尔·特拉斯克所制造并指挥的新型特种战斗机器人“哨兵”所猎杀，并有着被灭绝的危险。 哨兵机器人可以检测出任何形式的变种类型，而他们的基因则能够让他们瞬间变换和改造自身，从而击败X战警。这使得X战警的唯一希望，便是回到过去，在特拉斯克的研究最终导致他们的灭绝之前，改变历史。 利用幻影猫凯蒂的能力，金刚狼罗根穿越时空开始了这个艰辛的旅程。这一次，他必须联合年轻的变种人领袖X教授，以及他一生的对手万磁王，去找到魔形女，并阻止特拉斯克。时间已经迫在眉睫，在过去，亦在未来，X战警同哨兵机器人的大决战即将展开。 X戰警：天啟（2016年） 天启出生于埃及第一王朝，是地球上最古老、最强大的变种人沙巴泊，曾拥有无数信众，但后来遭人背叛，被人活埋。几千年后，强大无匹而且永生不朽的天启从数千年的深埋中获释，愤怒的他发现同类不再被视为神祇，他对人类世界充满厌恶，决定摧毁它重造一个新世界。为了实现自己的野心，天启四处游走，开始搜集他的s仆人——天启四骑士。因为天启的力量，暴风女、灵碟、天使、万磁王的超能力得到巨幅提升，同时他也计划将他的意识移入X教授体内，从而组建一支变种人的军队。 天启的阴谋遭到正义的X战警们的顽强抵抗，X教授、魔形女、琴·格雷、镭射眼、夜行者、野兽、快银等变种人联起手来，与这个看似无法阻挡的敌人进行一场史诗对决。 金刚狼X战警前传：金刚狼（2009年） 《X战警前传》是由加文·胡德执导的科幻片，休·杰克曼、李佛·薛伯等主演。《X战警前传》包括2009 《X战警前传：金刚狼》（X-Men Origins: Wolverine）、2011《X战警：第一战》（X-Men: First Class）、2014 《X战警：逆转未来》（X-Men: Days of Future Past）三部影片。 金刚狼的原名是詹姆斯·霍莱特，出生于19世纪末加拿大的一个富裕家庭，他天生体弱但是骨骼清奇，而且他的家庭并不和睦，所以小詹姆斯性格内向而且孤僻。他一直就这样平静而枯燥地生活着，直到有一天晚上，园丁罗根杀死了父亲，丧父之痛让小詹姆斯激发了体内的奇特能力，他从身体里长出了由骨骼形成的“骨爪”，小詹姆斯用“骨爪”杀死了罗根。然而没想到的是，其实罗根才是小詹姆斯的生父，生父在临死前告诉了金刚狼他的身世。 于是小詹姆斯和哥哥维克多两人出逃。之后，两人参加了多次的战争，从一战一直打到越南战役。后来兄弟二人被史崔克将军招募，从事特种工作，厌倦了杀人的金刚狼后来脱离组织，才到了加拿大的林场当伐木工，改名为罗根。在逃亡中的罗根一直对自己天生的异能感到既恐惧又厌恶，于是自暴自弃。直到有一次，他在森林中偶遇并且爱上一名印第安血统女子“银狐”凯娅。凯娅后来被金刚狼的哥哥维克多（剑齿虎）所杀，愤怒的金刚狼决定接受史崔克将军的条件，同意进行变种人的改造实验。 罗根给自己起名为“金刚狼”，并且本身骨骼被改造成不可摧毁，天生的骨爪变成了金刚爪。被改造的金刚狼还被“X武器”组织洗脑，金刚狼苏醒后杀死了“X武器”组织的人之后逃跑，谁知道剑齿虎此时前来追杀，于是金刚狼与剑齿虎大战一场，金刚狼险胜之后离开。之后遇到了X教授，被得到了收留，开始了自己的X战警生涯，戎马一生。 金刚狼（2013年） 位于加拿大的深山老林，背负着永生之苦的金刚狼罗根（休·杰克曼饰）隐居于此，但每日恶梦不断。在一次与猎人的冲突中，他得到东瀛女子雪绪（福岛莉拉饰）的帮助，雪绪是罗根二战期间的旧相识矢志田市朗派来的下属，似乎不久于人世的老友渴望死去之间再见罗根一面。跨越重洋的罗根终于见到了虚弱的矢志田市朗，对方希望他能够保护自己的孙女真理子（冈本多绪饰）。随着老人谢世，葬礼上突然战火点燃。罗根在雪绪的帮助下拼死救出真理子，两人一起逃亡，并因此互生情愫。而矢志田市朗的儿子矢志田信玄（真田广之饰）似乎另有所图。在逃亡途中，罗根意外发现他丧失了自愈的能力，金刚狼最大的危机降临。 金刚狼3:罗根（2017年） 影片讲述了《X战警：逆转未来》未来逆转的一年后。也就是新2024年的故事 许多年过去了，变种人渐渐消失。金刚狼罗根迟暮，带着老年X教授独自生活。一天，一个小女孩出现在罗根的生活中，X教授告诉罗根她很像他，并请罗根保护她。随着小女孩的出现，一个阴谋浮出水面，原来她竟是金刚狼的复制体：X-23。与此同时，一个右手为机械手的生化人唐纳德·皮尔斯追踪到了X-23，同时也发现了罗根和教授的踪迹。为了保护自己最后的同伴兼家人，罗根与唐纳德·皮尔斯，以及幕后黑手，展开了他人生中，也是最后一次，殊死之战…… 死侍死侍（2016年）牌王漫威漫画改编电影列表 先停止更新，复制了很长时间，累了. https://zh.wikipedia.org/wiki/%E6%BC%AB%E5%A8%81%E6%BC%AB%E7%94%BB%E6%94%B9%E7%BC%96%E7%94%B5%E5%BD%B1%E5%88%97%E8%A1%A8 站外链接 【当贝市场】漫威系列电影、电视剧系列的正确顺序 灭霸前十都进不去？漫威电影宇宙反派人气排行榜 冯小刚给周星驰演戏 这片场照绝版了(走错片场了) 写在最后 记得看的第一部印象深刻的漫威电影的是《绿巨人》，当时觉得看的很振奋，纯属打斗场景，后来有机会接触了这系列的电影，知道是漫威宇宙，于是找到了这系列的全部电影，并一一全部看了。自己感到共鸣的并不是打斗的多么精彩，而是每个英雄为拯救人类的那种精神。 听见有人说美国英雄系列电影的一些套路就是：主角刚开始是个毫不起眼的角色，然后经历了一场灾难，获得了某种特殊能力，最初并不想用这种能力来帮助人类，经历很多事情的催化之后，明白自己应该承担起这份责任，保护人类，保护地球。（大概就是介么个意思） 开始认真看漫威系列电影的时候，看的是《钢铁侠》三部曲，然后是美国队长，刚开始每看完一部就写完这部的故事情节，最后因为看的太多了，一天可能看完好几部，就没有坚持下去，但觉得是个遗憾，因为不写下来，之后有一些主要情节可能都忘记了，跟别人谈论时，明明当时看的很认真，但是不知道从哪说起，花几分钟时间记录很重要，可以回顾故事情节的同时，也好日后好跟别人吹牛掰。哈哈 所以，这里记下电影的主要故事情节，有些是自己写的，有些则是网上摘录的。]]></content>
      <categories>
        <category>漫威电影宇宙</category>
      </categories>
      <tags>
        <tag>漫威电影宇宙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 关于WebView全方面的使用（项目应用篇）]]></title>
    <url>%2F2016%2F12%2F04%2FAndroid%20%E5%85%B3%E4%BA%8EWebView%E5%85%A8%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%88%E9%A1%B9%E7%9B%AE%E5%BA%94%E7%94%A8%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[与JS交互 拨打电话、发送短信、发送邮件 上传图片(版本兼容) 进度条设置 字体大小设置 返回网页上一层、显示网页标题 全屏播放网络视频 文章说明WebView的使用已经是老生常谈了，看到很多文章说了用法，但我很少看到全的或者是项目中可以直接使用的，都是看了很多后，自己把功能都集合在一起。这里是一份比较全面的WebView项目应用篇，其中已经解决了应用时出现的很多bug，希望能对大家有帮助。 项目地址WebViewStudy 内容详细介绍电话短信邮件 给WebView设置WebViewClient： 1webView.setWebViewClient(new MyWebViewClient(this)); 其中MyWebViewClient内容： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * 监听网页链接:* - 优酷视频直接跳到自带浏览器 * - 根据标识:打电话、发短信、发邮件 * - 进度条的显示 * - 加载完成后，添加javascript监听 */public class MyWebViewClient extends WebViewClient &#123; private IWebPageView iWebPageView; private WebViewActivity activity; public MyWebViewClient(IWebPageView iWebPageView) &#123; this.iWebPageView = iWebPageView; activity = (WebViewActivity) iWebPageView; &#125; @SuppressWarnings("deprecation") @Override public boolean shouldOverrideUrlLoading(WebView view, String url) &#123; // 优酷视频跳转浏览器播放 if (url.startsWith("http://v.youku.com/")) &#123; Intent intent = new Intent(); intent.setAction("android.intent.action.VIEW"); intent.addCategory("android.intent.category.DEFAULT"); intent.addCategory("android.intent.category.BROWSABLE"); Uri content_url = Uri.parse(url); intent.setData(content_url); activity.startActivity(intent); return true; // 电话、短信、邮箱 &#125; else if (url.startsWith(WebView.SCHEME_TEL) || url.startsWith("sms:") || url.startsWith(WebView.SCHEME_MAILTO)) &#123; try &#123; Intent intent = new Intent(Intent.ACTION_VIEW); intent.setData(Uri.parse(url)); activity.startActivity(intent); &#125; catch (ActivityNotFoundException ignored) &#123; &#125; return true; &#125; iWebPageView.startProgress(); view.loadUrl(url); return false; &#125; @Override public void onPageFinished(WebView view, String url) &#123; if (activity.progress90) &#123; iWebPageView.hindProgressBar(); &#125; else &#123; activity.pageFinish = true; &#125; if (!CheckNetwork.isNetworkConnected(activity)) &#123; iWebPageView.hindProgressBar(); &#125; // html加载完成之后，添加监听图片的点击js函数 iWebPageView.addImageClickListener(); super.onPageFinished(view, url); &#125; // 视频全屏播放按返回页面被放大的问题 @Override public void onScaleChanged(WebView view, float oldScale, float newScale) &#123; super.onScaleChanged(view, oldScale, newScale); if(newScale - oldScale &gt; 7) &#123; view.setInitialScale((int)(oldScale / newScale * 100)); //异常放大，缩回去。 &#125; &#125;&#125; 因为有很多配置，这里把各个功能模块通过接口IWebPageView分离了出来，这样逻辑更清晰。 与JS交互相信大家已经看到了上面”—-点击了图片”的Toast，这里需要先给WebView设置JavascriptInterface：webView.addJavascriptInterface(new ImageClickInterface(this), &quot;injectedObject&quot;); 其中ImageClickInterface相关代码： 1234567891011121314151617public class ImageClickInterface &#123; private Context context; public ImageClickInterface(Context context) &#123; this.context = context; &#125; @JavascriptInterface public void imageClick(String imgUrl, String hasLink) &#123; Toast.makeText(context, "----点击了图片", Toast.LENGTH_SHORT).show(); // 查看大图// Intent intent = new Intent(context, ViewBigImageActivity.class);// intent.putStringArrayListExtra("imgUrl",imgUrl);// context.startActivity(intent);// Log.e("----点击了图片 url: ", "" + imgUrl); &#125;&#125; 加入监听：1234567891011public void addImageClickListener() &#123; // 这段js函数的功能就是，遍历所有的img节点， // 并添加onclick函数，函数的功能是在图片点击的时候调用本地java接口并传递对应src和has_link里的值过去 webView.loadUrl("javascript:(function()&#123;" + "var objs = document.getElementsByTagName(\"img\");" + "for(var i=0;i&lt;objs.length;i++)" + "&#123;" + "objs[i].onclick=function()&#123;window.injectedObject.imageClick(this.getAttribute(\"src\"),this.getAttribute(\"has_link\"));&#125;" + "&#125;" + "&#125;)()"); &#125; 我们来看一下网页对应的源码：1&lt;img src="[./callsms_files/753b877c-c098-43e9-85cc-6df5bbdaaafe](./callsms_files/753b877c-c098-43e9-85cc-6df5bbdaaafe)" style="width: 100%"&gt; 大家可能觉得有点怪异..因为这是保存的本地网页，如是线上的话，是这样：1&lt;img src='[http://7xk154.com1.z0.glb.clouddn.com/article/753b877c-c098-43e9-85cc-6df5bbdaaafe](http://7xk154.com1.z0.glb.clouddn.com/article/753b877c-c098-43e9-85cc-6df5bbdaaafe)' style='width: 100%'&gt; 这里传递过去的是一个图片url的值，没有的属性传过去的则是null。这样我们就可以对其进行具体的操作了。 字体大小设置12/** 设置字体默认缩放大小(改变网页字体大小,setTextSize api14被弃用)*/ws.setTextZoom(100); 其中100为默认缩放比，通过设置缩放比来控制字体大小。 上传图片(版本兼容) &amp; 全屏播放网络视频 &amp; 显示网页标题这里因为篇幅原因，里面的代码很多，就不贴出来了，大家可以点击MyWebChromeClient.java，查看具体代码。 返回网页上一层返回网页上一层及退出全屏等操作：12345678910111213141516171819@Overridepublic boolean onKeyDown(int keyCode, KeyEvent event) &#123; if (keyCode == KeyEvent.KEYCODE_BACK) &#123; //全屏播放退出全屏 if (webChromeClient.inCustomView()) &#123; hideCustomView(); return true; //返回网页上一页 &#125; else if (webView.canGoBack()) &#123; webView.goBack(); return true; //退出网页 &#125; else &#123; webView.loadUrl("about:blank"); finish(); &#125; &#125; return false;&#125; 进度条设置这里用的是先加载到90%再加载到100%, 具体为什么相信大家都懂吧… 123456789101112131415161718// 进度条 假装加载到90%public void startProgress90() &#123; for (int i = 0; i &lt; 900; i++) &#123; final int progress = i + 1; mProgressBar.postDelayed(new Runnable() &#123; @Override public void run() &#123; mProgressBar.setProgress(progress); if (progress == 900) &#123; progress90 = true; if (pageFinish) &#123; startProgress90to100(); &#125; &#125; &#125; &#125;, (i + 1) * 2); &#125; &#125; 再加载到100%:123456789101112// 加载到90%后再加载到100%public void progressChanged(int newProgress) &#123; if (progress90) &#123; int progress = newProgress * 100; if (progress &gt; 900) &#123; mProgressBar.setProgress(progress); if (progress == 1000) &#123; mProgressBar.setVisibility(View.GONE); &#125; &#125; &#125; &#125; 推荐阅读 如很多细节不知缘由的查看这里 https://developer.android.com/reference/android/webkit/WebSettings.html http://www.jianshu.com/p/32d48ca7d0e0 http://www.apkfuns.com/android-webview%E4%B8%8Ejavascript%E4%BA%A4%E4%BA%92.html 所遇问题 WebView加载网页不显示图片解决办法 webview: 视频全屏播放按返回页面被放大的问题 Failed to init browser shader disk cache. EGL_BAD_DISPLAY Unknown frame routing id: 3 找不到assets目录下资源：注意assets在哪层文件夹下！与AndroidManifest.xml同级 视频播放宽度比webview设置的宽度大，超过屏幕：设置ws.setLoadWithOverviewMode(false); onDestroy时的清除资源操作 End最后再附一遍项目地址😆：WebViewStudy]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>webview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 关于Glide的拓展使用(高斯模糊、加载监听、圆角图片)]]></title>
    <url>%2F2016%2F11%2F29%2FAndroid%20%E5%85%B3%E4%BA%8EGlide%E7%9A%84%E4%BD%BF%E7%94%A8(%E9%AB%98%E6%96%AF%E6%A8%A1%E7%B3%8A%E3%80%81%E5%8A%A0%E8%BD%BD%E7%9B%91%E5%90%AC%E3%80%81%E5%9C%86%E8%A7%92%E5%9B%BE%E7%89%87)%2F</url>
    <content type="text"><![CDATA[引用 引入的库应为如下，将官方的额外扩展了，使其可以支持高斯模糊。 1compile 'jp.wasabeef:glide-transformations:2.0.1' 加载图片基本加载123Glide.with(context) .load(url) .into(imageView); 设置加载中和加载失败的情况12345Glide.with(context) .load(url) .placeholder(R.drawable.loading) //占位符 也就是加载中的图片，可放个gif .error(R.drawable.failed) //失败图片 .into(view); 只加载动画1234Glide.with(context) .load(url) .asGif() // 只能加载gif文件 .into(imageView); 添加图片淡入加载的效果123456Glide.with(context) .load(url) .placeholder(R.drawable.loading) .error(R.drawable.failed) .crossFade(1000) // 可设置时长，默认“300ms” .into(view); 加载高斯模糊图1234567Glide.with(context) .load(url) .placeholder(R.drawable.loading) .error(R.drawable.failed) .crossFade(1000) .bitmapTransform(new BlurTransformation(context,23,4)) // “23”：设置模糊度(在0.0到25.0之间)，默认”25";"4":图片缩放比例,默认“1”。 .into(view); 加载监听器RequestListener12345678910111213Glide.with(this).load(internetUrl).listener(new RequestListener&lt;String, GlideDrawable&gt;() &#123; @Override public boolean onException(Exception e, String model, Target&lt;GlideDrawable&gt; target, boolean isFirstResource) &#123; Toast.makeText(getApplicationContext(),"资源加载异常",Toast.LENGTH_SHORT).show(); return false; &#125; //这个用于监听图片是否加载完成 @Override public boolean onResourceReady(GlideDrawable resource, String model, Target&lt;GlideDrawable&gt; target, boolean isFromMemoryCache, boolean isFirstResource) &#123; Toast.makeText(getApplicationContext(),"图片加载完成",Toast.LENGTH_SHORT).show(); return false; &#125; &#125;).into(imageView); 注意：如果需要加载完成后设置图片透明度为0，则不能设置.placeholder(R.drawable.url)，否则达不到你想要的效果。 图片缓存机制Glide缓存策略 Glide默认开启磁盘缓存和内存缓存，当然也可以对单张图片进行设置特定的缓存策略。设置图片不加入到内存缓存 1234Glide.with( context ) .load( eatFoodyImages[0] ) .skipMemoryCache( true ) .into( imageViewInternet ); 设置图片不加入到磁盘缓存 1234Glide.with( context ) .load( eatFoodyImages[0] ) .diskCacheStrategy( DiskCacheStrategy.NONE ) .into( imageViewInternet ); Glide支持多种磁盘缓存策略： DiskCacheStrategy.NONE :不缓存图片DiskCacheStrategy.SOURCE :缓存图片源文件DiskCacheStrategy.RESULT:缓存修改过的图片DiskCacheStrategy.ALL:缓存所有的图片，默认 加载圆角图片1234567891011121314151617181920212223242526272829303132333435public class GlideCircleTransform extends BitmapTransformation &#123; public GlideCircleTransform(Context context) &#123; super(context); &#125; @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123; return circleCrop(pool, toTransform); &#125; private static Bitmap circleCrop(BitmapPool pool, Bitmap source) &#123; if (source == null) return null; int size = Math.min(source.getWidth(), source.getHeight()); int x = (source.getWidth() - size) / 2; int y = (source.getHeight() - size) / 2; // TODO this could be acquired from the pool too Bitmap squared = Bitmap.createBitmap(source, x, y, size, size); Bitmap result = pool.get(size, size, Bitmap.Config.ARGB_8888); if (result == null) &#123; result = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_8888); &#125; Canvas canvas = new Canvas(result); Paint paint = new Paint(); paint.setShader(new BitmapShader(squared, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP)); paint.setAntiAlias(true); float r = size / 2f; canvas.drawCircle(r, r, r, paint); return result; &#125; @Override public String getId() &#123; return getClass().getName(); &#125;&#125; 使用： 1234Glide.with(mContext) .load(imageUrl) .transform(new GlideCircleTransform(mContext)) .into(holder.imageView); 获得图片缓存路径12345678910111213private String getImagePath(String imgUrl) &#123; String path = null; FutureTarget&lt;File&gt; future = Glide.with(ViewBigImageActivity.this) .load(imgUrl) .downloadOnly(500, 500); try &#123; File cacheFile = future.get(); path = cacheFile.getAbsolutePath(); &#125; catch (InterruptedException | ExecutionException e) &#123; e.printStackTrace(); &#125; return path;&#125; 注意：应在子线程中执行。 使用： 123456789101112131415new Thread(new Runnable() &#123; @Override public void run() &#123; // 子线程获得图片路径 final String imagePath = getImagePath(imageUrl); // 主线程更新 MainActivity.this.runOnUiThread(new Runnable() &#123; @Override public void run() &#123; // 操作代码 &#125; &#125;); &#125;&#125;).start(); 参考 http://blog.csdn.net/zhihui_520/article/details/51822336 http://blog.csdn.net/u010694658/article/details/52689317]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>开源库使用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收集“新奇的网站”]]></title>
    <url>%2F2016%2F11%2F23%2F%E6%94%B6%E9%9B%86%E2%80%9C%E6%96%B0%E5%A5%87%E7%9A%84%E7%BD%91%E7%AB%99%E2%80%9D%2F</url>
    <content type="text"><![CDATA[产品原型制作 Sketch，最佳原型制作工具 Dribbble，养成一双发现并懂得美的眼睛(美图) 新奇-Get quickly inspiration!（页面） 免费的高清图片 dribbble 全球最优质的设计作品聚集地 UI设计师推荐 站酷(ZCOOL)-设计师互动平台 黄蜂网 UI中国-专业界面交互平台 behance 展示和发现创意作品 学UI网 颜色搭配及icon制作 ColorHunt-色彩搭配 icon在线制作 icon图标库 MD的icon制作网站 RGB颜色值转换成十六进制颜色码 GitHub美化 README的标签 README的进度tag mp4转gif 带壳截图 移动应用分发 Fir.im 豌豆荚 play store]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
        <tag>创意灵感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[可能是讲解Android事件分发最好的文章]]></title>
    <url>%2F2016%2F11%2F22%2F%E5%8F%AF%E8%83%BD%E6%98%AF%E8%AE%B2%E8%A7%A3Android%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%80%E5%A5%BD%E7%9A%84%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[这是在简书上看到的一篇文章，感觉非常好，就转了过来，这是老外写的，这个作者翻译过来的。 综合之前在CSDN写过的一篇类似的文章[Android 简述事件分发机制]，差不多这个知识点就清晰了。 我几乎看过国内讲解Android事件分发的所有文章，但遗憾的是都没有这篇讲的好，原因有二：它阐明了具体的事件分发机制的设计意图，让人既知其然，又知其所以然；它没有贴源码，吓唬本宝宝。所以我决定将它翻译出来，造福广大Android开发者。原文请点击这里 有时，你必须要自己处理触摸事件（touch events）而不能依赖于有可用的onSomethingListener。我就遇到过这样的时候，当时我很想有一篇文章能简单地解释触摸事件是怎样在视图层次（view hierarchy）中传播的，从而可以将之作为进一步深入学习的起点。这篇博客是我的一次尝试，它看起来有点长，但这是因为我是按照触摸事件的传播过程一步一步来写的。 一些假设我们只考虑最重要的四个触摸事件，即：DOWN,MOVE,UP和CANCEL。一个手势（gesture）是一个事件列，以一个DOWN事件开始（当用户触摸屏幕时产生），后跟0个或多个MOVE事件（当用户四处移动手指时产生），最后跟一个单独的UP或CANCEL事件（当用户手指离开屏幕或者系统告诉你手势（gesture）由于其他原因结束时产生）。当我们说到“手势剩余部分”时指的是手势后续的MOVE事件和最后的UP或CANCEL事件。 在这里我也不考虑多点触摸手势（我们只假设用一个手指）并且忽略多个MOVE事件可以被归为一组这一实际情况。最后，我们假设文中的view都没有注册onTouchListener。 我们将要讨论的视图层次是这样的：最外层是一个ViewGroup A，包含一个或多个子view（children），其中一个子view是ViewGroup B，ViewGroupB中又包含一个或多个子view，其中一个子view是 View C,C不是一个ViewGroup。这里我们忽略同层级view之间可能的交叉叠加。 假设用户首先触摸到的屏幕上的点是C上的某个点，该点被标记为触摸点（touch point），DOWN事件就在该点产生。然后用户移动手指并最后离开屏幕，此过程中手指是否离开C的区域无关紧要，关键是手势（gesture）是从哪里开始的。 默认情况假设上面的A,B,C都没有覆写默认的事件传播行为，那么下面就是事件传播的过程： DOWN事件被传到C的onTouchEvent方法中，该方法返回false，表示“我不关心这个手势（gesture）”。 因此，DOWN事件被传到B的onTouchEvent方法中，该方法同样返回false，表示B也不关心这个手势。 同样，因为B不关心这个手势，DOWN事件被传到A的onTouchEvent方法中，该方法也返回false。 由于没有view关心这个手势（gesture），它们将不再会从“手势剩余部分”中接收任何事件。 处理事件现在，让我们假设C实际上是关心这个手势（gesture）的，原因可能是C被设置成可点击的（clickable）或者你覆写了C的onTouchEvent方法。 DOWN事件被传递给C的onTouchEvent方法，该方法可以做任何它想做的事情，最后返回true。 因为C说它正在处理这个手势（gesture），则DOWN事件将不再被传递给B和A的onTouchEvent方法。 因为C说它正在处理这个手势（gesture），所以“手势剩余部分”的事件也将传递给C的onTouchEvent方法，此时该方法返回true或false都无关紧要了，但是为保持一致最好还是返回true。 个人理解：从这里可以看出，各个View的onTouchEvent方法对DOWN事件的处理，代表了该View对以此DOWN开始的整个手势（gesture）的处理意愿，返回true代表愿意处理该gesture，返回false代表不愿意处理该gesture。 onInterceptTouchEvent现在我们将讨论一个新的方法：onInterceptTouchEvent，它只存在于ViewGroup中，普通的View中没有这个方法。在任何一个view的onTouchEvent被调用之前，它的父辈们（ancestors）将先获得拦截这个事件的一次机会，换句话说，它们可以窃取该事件。在刚才的“处理事件”部分中，我们遗漏了这一过程，现在，让我们把它加上： DOWN事件被传给A的onInterceptTouchEvent，该方法返回false，表示它不想拦截。 DOWN又被传递给B的onInterceptTouchEvent，它也不想拦截，因此该方法也返回false。 现在，DOWN事件被传递到C的onTouchEvent方法，该方法返回true，因为它想处理以该事件为首的手势（gesture）。 现在，该手势的下一个事件MOVE到来了。这个MOVE事件再一次被传递给A的onInterceptTouchEvent方法，该方法再一次返回false，B也同样如此。 然后，MOVE事件被传递给C的onTouchEvent，就像在前一部分中一样。 “手势剩余部分”中其他事件的处理过程和上面一样，假如A和B的onInterceptTouchEvent方法继续返回false的话。 这里有两点需要注意： 虽然ViewGroup A和B的onInterceptTouchEvent方法对DOWN事件返回了false，后续的事件依然会传递给它们的onInterceptTouchEvent方法，这一点与onTouchEvent的行为是不一样的。 假如DOWN事件传给C的onTouchEvent方法时，它返回了false，DOWN事件会继续向上传递给B和A的onTouchEvent，即使它们在onInterceptTouchEvent方法中说它们不想拦截这个DOWN事件，但没办法，没有子View愿意处理该事件。 个人理解：感谢@编程世界的孩子 的提醒，由此可见，DOWN事件的处理实际上经历了一下一上两个过程，下是指A-&gt;B的onInterceptTouchEvent，上是指C-&gt;B-&gt;A的onTouchEvent，当然，任意一步的方法中返回true,都能阻止它继续传播。 拦截事件现在，让我们更进一步，假设B没有拦截DOWN事件，但它拦截了接下来的MOVE事件。原因可能是B是一个scrolling view。当用户仅仅在它的区域内点击（tap）时，被点击到的元素应当能处理该点击事件。但是当用户手指移动了一定的距离后，就不能再视该手势（gesture）为点击了——很明显，用户是想scroll。这就是为什么B要接管该手势（gesture）。 下面是事件被处理的顺序： DOWN事件被依次传到A和B的onInterceptTouchEvent方法中，它们都返回的false，因为它们目前还不想拦截。 DOWN事件传递到C的onTouchEvent方法，返回了true。 在后续到来MOVE事件时，A的onInterceptTouchEvent方法仍然返回false。 B的onInterceptTouchEvent方法收到了该MOVE事件，此时B注意到用户手指移动距离已经超过了一定的threshold（或者称为slop）。因此，B的onInterceptTouchEvent方法决定返回true，从而接管该手势（gesture）后续的处理。 然后，这个MOVE事件将会被系统变成一个CANCEL事件，这个CANCEL事件将会传递给C的onTouchEvent方法。 现在，又来了一个MOVE事件，它被传递给A的onInterceptTouchEvent方法，A还是不关心该事件，因此onInterceptTouchEvent方法继续返回false。 此时，该MOVE事件将不会再传递给B的onInterceptTouchEvent方法，该方法一旦返回一次true，就再也不会被调用了。事实上，该MOVE以及“手势剩余部分”都将传递给B的onTouchEvent方法（除非A决定拦截“手势剩余部分”）。 C再也不会收到该手势（gesture）产生的任何事件了。 下面的一些小事情可能会令你感到吃惊： 如果一个ViewGroup拦截了最初的DOWN事件，该事件仍然会传递到该ViewGroup的onTouchEvent方法中。 另一方面，如果ViewGroup拦截了一个半路的事件（比如，MOVE），这个事件将会被系统变成一个CANCEL事件，并传递给之前处理该手势（gesture）的子View，而且不会再传递（无论是被拦截的MOVE还是系统生成的CANCEL）给ViewGroup的onTouchEvent方法。只有再到来的事件才会传递到ViewGroup的onTouchEvent方法中。 从此开始，你可以更进一步。比如对mouthful-method （实在不知道该怎么翻译啦！）requestDisallowInterceptTouchEvent,C可以用该方法阻止B窃取事件。如果你想更加疯狂一点，你可以在你自己的ViewGroup中直接覆写dispatchTouchEvent方法，并对传递进来的事件做任何你想做的处理。但这样的话你可能会破坏一些约定，所以应当小心。 文／milter（简书作者)原文链接：http://www.jianshu.com/p/2be492c1df96]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Android基础知识点</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac搭建Hexo博客流程记录，排雷完成]]></title>
    <url>%2F2016%2F11%2F19%2FMac%E6%90%AD%E5%BB%BAHexo%E5%8D%9A%E5%AE%A2%E6%B5%81%E7%A8%8B%E8%AE%B0%E5%BD%95%EF%BC%8C%E6%8E%92%E9%9B%B7%E5%AE%8C%E6%88%90%2F</url>
    <content type="text"><![CDATA[经过一天的辛苦作战，总算基础的东西出来了。踩了太多的坑，综合我踩坑的经过，明白到，选好一篇引导文很重要！有些步骤不要先做了，不然后面会把你坑的很惨.. 引很多博客都已经详细讲述了Hexo博客框架的好处和怎么做，下面的推荐文章里会给出链接。但有些过于复杂，让初次配置的人有点雨里雾里；有些又太简单，出了问题就会不知道怎么回事。下面是自己的搭建记录，及所遇问题的解决。 在此感谢小马哥Mark和 wingjay先前分享的教程，有些段落是从你们里搬运过来的，希望博主见谅，如有侵权，请联系我删除。 Ok，现在开始： GitHub Pages在不购买服务器的前提下，我们的网站需要挂在GitHub Pages上。GitHub Pages是面向用户、组织和项目开放的公共静态页面搭建托管服务，可用于搭建个人博客。 首先你需要拥有一个GitHub账号。 然后进入GitHub Pages，一步步做，完成后就能在浏览器打开http://username.github.io了。 至此，我们已经利用GitHub Pages搭建好了个人博客雏形了。下面要做的，就是个性化了。 注意：如果你http://username.github.io首页就要是博客首页的话，建议初次配置选择首页，就是这样。完成后可以把index.html给删了，因为到最后你发现那是没用的，它将会给你造成干扰。 前期准备安装Hexo参考中文文档或英文文档。完成该步后，你的电脑便拥有了Git、Node.js和Hexo。 测试安装状态1234567$ node -v v4.2.4$ npm -v2.14.12$ hexo -v 正式开始确定拥有了Git、Node.js和Hexo后，进行下一步： 建站安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新建完成后，指定文件夹的目录如下： 12345678.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes 这样Hexo会在该文件夹创建本地博客所需的一切资源。这样本地博客就搭建好了，输入以下命令： 1hexo s --debug // 启动本地hexo 服务器，默认localhost:4000可以访问，可以看到调试信息 这样就开启了一个本地博客服务器，打开浏览器，在地址栏输入localhost:4000，就可以查看本地博客了，hexo默认生成了一片hello world博客。出现问题可以看terminal终端错误信息。按control + c关闭调试。 注意：以上hexo开头的命令，执行目录必须是你创建的博客文件夹目录。使用hexo s 也可以，只是没有了调试信息。 同步Hexo博客到Github现在你已经可以在本机查看你的博客了，但是要想让别人通过网络可以查看你的博客，还需要一步，那就是将你的博客发布到github仓库。在terminal终端，将当前目录切换到你的本地博客目录，执行以下命令： 1npm install hexo-deployer-git --save 安装完成之后，打开本地博客目录的_config.yml文件，编辑其中的deploy节点： 1234deploy: type: git repo: https://github.com/youlookwhat/youlookwhat.github.io.git branch: master 注意：字段前需加空格，hexo有严格的格式规范。 保存配置之后，你可以不着急传到仓库，先刷新本地博客，看是否还是原样，如有问题可以看到terminal终端上的错误信息，然后检查没问题为止。 确认无误之后，在本地博客目录执行以下命令： 123hexo clean // clean本地项目，防止缓存hexo g // 全拼是：hexo generate，可以简写成 hexo g; 根据你编辑的md格式的博客，生成静态网页hexo d // 全拼是：hexo deploy，可以简写成 hexo d; 将本地博客发布到github 然后，在浏览器地址栏输入username.github.io就可以访问你的博客了，别人也可以通过这个地址访问你的博客。如果错误请重复看以前流程，或参考其他文章，也可以联系我. NexT主题配置 Next主题 Hexo主题非常多，可以参考丰富多彩的Hexo主题，本文选Next为主题，NexT主题是一套简约的主题，设置完成之后，就像我的博客现在的样子，里面有详细的配置说明，这里就不重述了。 配置后调试： 123hexo cleanhexo ghexo s --debug 确认无误后上传： 123hexo cleanhexo ghexo d 注意：因为hexo有严格的格式规范，所以建议配置时及时调试页面。 优化环节 域名设置 fork me on github 配置SSH key 给博文添加tag和分类(主题) 手动实现某条博文置顶 域名设置大家可以看：替换自己的域名 ,里面讲述的详细。 注意：在万网买了域名以后直接在里面配置，这里只是参考用的。 其它四条大家可以看：其他遗漏的点 注意：配置后进入调试模式测试一下，这样错了就可以马上更正。 实现https访问 2018年3月16日补 CloudFlare是一家CDN提供商，它提供了免费的https服务(但不是应用SSL证书)。参考链接： 自定义域名的 GitHub Pages 添加 SSL 的方案 Github-pages或个人域名实现https访问 为自定义域名的GitHub Pages添加SSL 完整方案 注意:1.需要在阿里云服务器里更改NDS服务器地址，原来地址为dns15.hichina.com ; dns16.hichina.com 常用命令 cd 到仓库所在文件夹目录下： 1234567hexo init //在指定目录执行该命令，会将当前目录初始化为hexo站点，生成hexo站点所需的一切文件hexo new “my new blog title” //新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。hexo s --debug // 启动本地hexo 服务器，默认localhost:4000可以访问hexo clean // 清除缓存，如果对本地文件做了修改，同步到远程验证修改的效果之前，先clean，清除缓存hexo generate // 可以简写成hexo g 根据markdown文件生成静态文件hexo deploy // 或者简写成hexo d 将本地修改，部署到远端hexo version // 显示hexo版本 推荐文章 Mac搭建Hexo博客及NexT主题配置优化 如何在一天之内搭建以你自己名字为域名又具备cool属性的个人博客 使用GitHub和Hexo搭建免费静态Blog 动动手指，NexT主题与Hexo更搭哦（基础篇） 所遇问题 按照步骤来，及时调试，确认无误后再执行下一步。有一句话说的好，步子跨大了容易扯着蛋。 建议将基础的先搭建出来，主题细节可以之后再慢慢配置。 编辑站点_config.yml文件其中的deploy节点时，注意repo的值。 替换域名时： 直接在万维网设置解析方式； 在仓库Setting的要设置跳转链接； CNAME会被覆盖，安装CNAME工具hexo-generator-cname 为博客文章添加阅读量统计功能，参照这里，注意顺序，我在其中被坑过。 设置网站图标时，就是上传“.ico”文件时，确认成功后浏览器会有缓存，显示不出来，关掉浏览器清除缓存就好了（可放在最后）。 设置代码高亮主题测试时没事，上传后会有延迟，等等就好了（本人这样）。 设置搜索栏，进入swiftype官网，注册不上，应该收费了- -. 设置侧边栏社交链接时，social:下面字段前要有两个空格，切记。 相关网址NexT、多说、百度统计、leancloud、阿里云、fork me、ico制作、Cloudflare 联系我 我的简书 我的CSDN 我的个人博客]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 常用十种设计模式示例归纳 | 已打包请带走]]></title>
    <url>%2F2016%2F11%2F14%2Fjava-%E5%B8%B8%E7%94%A8%E5%8D%81%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B%E5%BD%92%E7%BA%B3-%E5%B7%B2%E6%89%93%E5%8C%85%E8%AF%B7%E5%B8%A6%E8%B5%B0%2F</url>
    <content type="text"><![CDATA[设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。 GitHub地址DesignPattern 文章说明一个Demo，集合常用的十种设计模式，每个模式使用易被人们接受的案例讲述，按模式分包，使用设计模式前后对比，界面显示定义讲解，让你更深刻的了解每种设计模式。大部分案例来自张鸿洋的博客。如有错误欢迎指正，如有侵权，请联系我删除。 项目结构 设计模式分为三种类型，共23种： 创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。 结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。 行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。 上面链接点击直接跳转到GitHub对应模式解析内 博客目录 1 . 设计模式 观察者模式(Observer Pattern) 以微信公众服务为例 2 . 设计模式 工厂模式(Factory Pattern) 从卖肉夹馍说起 3 . 设计模式 单例设计模式(Singleton Pattern) 完全解析 4 . 设计模式 策略模式(Strategy Pattern) 以角色游戏为背景 5 . 设计模式 适配器模式(Adapter Pattern) 以手机充电器为例 6 . 设计模式 命令模式(Command Pattern) 管理智能家电 7 . 设计模式 装饰者模式(Decorator Pattern) 带你重回传奇世界 8 . 设计模式 外观模式(Facade Pattern) 一键电影模式 9 . 设计模式 模版方法模式(TemplateMethod Pattern) 展现程序员的一天 10 . 设计模式 状态模式(State Pattern) 以自动售货机为例 对应模式所在的包 1 . Observer 2 . Factory 3 . Singleton 4 . Strategy 5 . Adapter 6 . Command 7 . Decorator 8 . Facade 9 . Template Method 10 . State 模式分析1. 观察者模式 定义了对象之间的一对多的依赖，这样一来，当一个对象改变时，它的所有的依赖者都会收到通知并自动更新。 对于JDK或者Andorid中都有很多地方实现了观察者模式，比如XXXView.addXXXListenter ， 当然了 XXXView.setOnXXXListener不一定是观察者模式，因为观察者模式是一种一对多的关系，对于setXXXListener是1对1的关系，应该叫回调。 专题接口：Subject.java ; 123456789101112 /** * 注册一个观察者 */public void registerObserver(Observer observer);/** * 移除一个观察者 */public void removeObserver(Observer observer);/** * 通知所有观察者 */public void notifyObservers(); 3D服务号的实现类：ObjectFor3D.java 123456789101112131415161718192021222324@Override public void registerObserver(Observer observer) &#123; observers.add(observer); &#125; @Override public void removeObserver(Observer observer) &#123; int index = observers.indexOf(observer); if (index &gt;= 0) &#123; observers.remove(index); &#125; &#125; @Override public void notifyObservers() &#123; for (Observer observer : observers) &#123; observer.update(msg); &#125; &#125; /** * 主题更新信息 */ public void setMsg(String msg) &#123; this.msg = msg; notifyObservers(); &#125; 所有观察者需要实现此接口:Observer.java 1234567public ObserverUser1(Subject subject) &#123; subject.registerObserver(this); &#125; @Override public void update(String msg) &#123; Log.e("-----ObserverUser1 ", "得到 3D 号码:" + msg + ", 我要记下来。 "); &#125; 最后测试：ObserverActivity.java 12345678// 创建服务号 objectFor3D = new ObjectFor3D(); // 创建两个订阅者 observerUser1 = new ObserverUser1(objectFor3D); observerUser2 = new ObserverUser2(objectFor3D); // 两个观察者,发送两条信息 objectFor3D.setMsg("201610121 的3D号为:127"); objectFor3D.setMsg("20161022 的3D号为:000"); 2. 工厂模式简单列一下这个模式的家族： 1、静态工厂模式 这个最常见了，项目中的辅助类，TextUtil.isEmpty等，类+静态方法。 2、简单工厂模式（店里买肉夹馍） 定义：通过专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。 根据类型直接创建肉夹馍：SimpleRoujiaMoFactory.java 123456789101112131415161718public RoujiaMo creatRoujiaMo(String type) &#123; RoujiaMo roujiaMo = null; switch (type) &#123; case "Suan": roujiaMo = new ZSuanRoujiaMo(); break; case "La": roujiaMo = new ZLaRoujiaMo(); break; case "Tian": roujiaMo = new ZTianRoujiaMo(); break; default:// 默认为酸肉夹馍 roujiaMo = new ZSuanRoujiaMo(); break; &#125; return roujiaMo; &#125; 3、工厂方法模式（开分店） 定义：定义一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法模式把类实例化的过程推迟到子类。 对比定义： 1、定义了创建对象的一个接口：public abstract RouJiaMo sellRoujiaMo(String type); 2、由子类决定实例化的类，可以看到我们的馍是子类生成的。 提供创建肉夹馍店抽象方法：RoujiaMoStore.java 1public abstract RoujiaMo sellRoujiaMo(String type); 具体实现抽象方法：XianRoujiaMoStore.java 分店依旧使用简单工厂模式：XianSimpleRoujiaMoFactory.java 4、抽象工厂模式（使用官方提供的原料） 定义：提供一个接口，用于创建相关的或依赖对象的家族，而不需要明确指定具体类。 对比定义： 1、提供一个接口：public interface RouJiaMoYLFactroy 2、用于创建相关的或依赖对象的家族 public Meat createMeat();public YuanLiao createYuanliao();我们接口用于创建一系列的原材料。 创建用于提供原料的接口工厂：RoujiaMoYLFactory.java 各自分店实现接口，完成原料提供：XianRoujiaMoYLFoctory.java 准备时，使用官方的原料：RoujiaMo.java 12345678/** * 准备工作 */ public void prepare(RoujiaMoYLFactory roujiaMoYLFactory) &#123; Meet meet = roujiaMoYLFactory.creatMeet(); YuanLiao yuanLiao = roujiaMoYLFactory.creatYuanLiao(); Log.e("---RoujiaMo:", "使用官方的原料 ---" + name + ": 揉面-剁肉-完成准备工作 yuanLiao:"+meet+"yuanLiao:"+yuanLiao); &#125; 3. 单例设计模式 单例模式主要是为了避免因为创建了多个实例造成资源的浪费，且多个实例由于多次调用容易导致结果出现错误，而使用单例模式能够保证整个应用中有且只有一个实例。 定义：只需要三步就可以保证对象的唯一性 (1) 不允许其他程序用new对象 (2) 在该类中创建对象 (3) 对外提供一个可以让其他程序获取该对象的方法 对比定义： (1) 私有化该类的构造函数 (2) 通过new在本类中创建一个本类对象 (3) 定义一个公有的方法，将在该类中所创建的对象返回 饿汉式[可用]：SingletonEHan.java 含懒汉式[双重校验锁 推荐用]：SingletonLanHan.java 123456789101112 private SingletonLanHan() &#123;&#125; private static SingletonLanHan singletonLanHanFour; public static SingletonLanHan getSingletonLanHanFour() &#123; if (singletonLanHanFour == null) &#123; synchronized (SingletonLanHan.class) &#123; if (singletonLanHanFour == null) &#123; singletonLanHanFour = new SingletonLanHan(); &#125; &#125; &#125; return singletonLanHanFour;&#125; 内部类[推荐用]：SingletonIn.java 枚举[推荐用]：SingletonEnum.java 4. 策略模式 策略模式：定义了算法族，分别封装起来，让它们之间可相互替换，此模式让算法的变化独立于使用算法的客户。 以创建游戏角色为例子： 最初的游戏角色的父类：Role.java 发现有重复代码后，重构后的父类：Role.java 总结： 1、封装变化（把可能变化的代码封装起来） 2、多用组合，少用继承（我们使用组合的方式，为客户设置了算法） 3、针对接口编程，不针对实现（对于Role类的设计完全的针对角色，和技能的实现没有关系） 最后测试：创建角色： 123456789RoleA roleA = new RoleA("---A");roleA.setiDisplayBehavior(new DisplayYZ()) .setiAttackBehavior(new AttackXL()) .setiDefendBehavior(new DefendTMS()) .setiRunBehavior(new RunJCTQ());roleA.display();// 样子roleA.attack();// 攻击roleA.run();// 逃跑roleA.defend();// 防御 5. 适配器模式 定义：将一个类的接口转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以相互合作。这个定义还好，说适配器的功能就是把一个接口转成另一个接口。 以充电器为实例: 手机充电器一般都是5V左右吧，咱天朝的家用交流电压220V，所以手机充电需要一个适配器（降压器） 一部手机: Mobile.java 手机依赖一个提供5V电压的接口: V5Power.java 我们拥有的是220V家用交流电: V220Power.java 适配器，完成220V转5V的作用：V5PowerAdapter.java 最后测试：给手机冲个电： 123Mobile mobile = new Mobile(); V5Power v5Power = new V5PowerAdapter(new V200Power()); mobile.inputPower(v5Power); 6. 命令模式 定义：将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象。命令模式也支持可撤销的操作。(简化: 将请求封装成对象，将动作请求者和动作执行者解耦。) 需求：最近智能家电很火热，假设现在有电视、电脑、电灯等家电，现在需要你做个遥控器控制所有家电的开关，要求做到每个按钮对应的功能供用户个性化，对于新买入家电要有非常强的扩展性。 1、家电的API：Door.java 2、把命令封装成类： 统一的命令接口：Command.java 家电实现该接口：DoorOpenCommand.java 3、遥控器：ControlPanel.java 4、定义一个命令，可以干一系列的事情：QuickCommand.java 123QuickCommand quickCloseCommand = new QuickCommand(new Command[]&#123;new LightOffCommand(light), new ComputerOffCommand(computer), new DoorCloseCommand(door)&#125;);controlPanel.setCommands(6, quickOpenCommand);controlPanel.keyPressed(6); 5、遥控器面板执行：CommandActivity.java 12controlPanel.setCommands(0, new DoorOpenCommand(door));// 开门controlPanel.keyPressed(0); 7. 装饰者模式 装饰者模式：若要扩展功能，装饰者提供了比集成更有弹性的替代方案，动态地将责任附加到对象上。 先简单描述下装饰者模式发挥作用的地方，当我们设计好了一个类，我们需要给这个类添加一些辅助的功能，并且不希望改变这个类的代码，这时候就是装饰者模式大展雄威的时候了。这里还体现了一个原则：类应该对扩展开放，对修改关闭。 需求：设计游戏的装备系统，基本要求，要可以计算出每种装备在镶嵌了各种宝石后的攻击力和描述： 1、装备的超类：IEquip.java 2、各个装备的实现类： eg：武器的实现类: ArmEquip.java 3、装饰品的超类（装饰品也属于装备）：IEquipDecorator.java 4、装饰品的实现类： eg：蓝宝石的实现类(可累加): BlueGemDecorator.java 5、最后测试：计算攻击力和查看描述： 1234Log.e("---", "一个镶嵌2颗红宝石,1颗蓝宝石的靴子: "); IEquip iEquip = new RedGemDecotator(new RedGemDecotator(new BlueGemDecotator(new ShoeEquip()))); Log.e("---", "攻击力:" + iEquip.caculateAttack()); Log.e("---", "描述语:" + iEquip.description()); 8. 外观模式 定义：提供一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层的接口，让子系统更容易使用。其实就是为了方便客户的使用，把一群操作，封装成一个方法。 需求：我比较喜欢看电影，于是买了投影仪、电脑、音响、设计了房间的灯光、买了爆米花机，然后我想看电影的时候，我需要一键观影和一键关闭。 每个设备类的开关等操作： eg: 爆米花机：PopcornPopper.java 电影院类：HomeTheaterFacade.java 123456789101112131415161718 /** * 一键观影 */ public void watchMovie() &#123; computer.on(); light.down(); popcornPopper.on(); popcornPopper.makePopcorn(); projector.on(); projector.open(); player.on(); player.make3DListener(); &#125; ``` - 最后测试：一键观影： ```java new HomeTheaterFacade(computer, light, player, popcornPopper, projector).watchMovie(); 9. 模板方法模式 定义：定义了一个算法的骨架，而将一些步骤延迟到子类中，模版方法使得子类可以在不改变算法结构的情况下，重新定义算法的步骤。 需求：简单描述一下：本公司有程序猿、测试、HR、项目经理等人，下面使用模版方法模式，记录下所有人员的上班情况 模板方法模式中的三类角色 1、具体方法(Concrete Method) 2、抽象方法(Abstract Method) 3、钩子方法(Hook Method) 工人的超类：Worker.java 1234567891011121314151617181920// 具体方法 public final void workOneDay() &#123; Log.e("workOneDay", "-----------------work start----------------"); enterCompany(); work(); exitCompany(); Log.e("workOneDay", "-----------------work end----------------"); &#125; // 工作 抽象方法 public abstract void work(); // 钩子方法 public boolean isNeedPrintDate() &#123; return false; &#125; private void exitCompany() &#123; if (isNeedPrintDate()) &#123; Log.e("exitCompany", "---" + new Date().toLocaleString() + "---&gt;"); &#125; Log.e("exitCompany", name + "---离开公司"); &#125; 程序员实现类（可得知时间）：ITWorker.java 1234567/** * 重写父类的此方法,使可以查看离开公司时间 */ @Override public boolean isNeedPrintDate() &#123; return true; &#125; 最后测试： 查看所有人员的工作情况： 12345QAWorker qaWorker = new QAWorker("测试人员"); qaWorker(); HRWorker hrWorker = new HRWorker("莉莉姐"); hrWorker.workOneDay(); ... 查看程序猿离开公司的时间: 12ITWorker itWorker = new ITWorker("jingbin"); itWorker.workOneDay(); 10. 状态模式 定义：允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。 定义又开始模糊了，理一下，当对象的内部状态改变时，它的行为跟随状态的改变而改变了，看起来好像重新初始化了一个类似的。 需求：已自动售货机为例（有已投币、未投币等状态和投币、投币等方法） 最初实现待改进的售货机：VendingMachine.java 改进后的售货机（更具有延展性）:VendingMachineBetter.java 1234567891011121314151617181920212223242526// 放钱 public void insertMoney() &#123; currentState.insertMoney(); &#125; // 退钱 public void backMoney() &#123; currentState.backMoney(); &#125; // 转动曲柄 public void turnCrank() &#123; currentState.turnCrank(); if (currentState == soldState || currentState == winnerState) &#123; currentState.dispense();//两种情况会出货 &#125; &#125; // 出商品 public void dispense() &#123; Log.e("VendingMachineBetter", "---发出一件商品"); if (count &gt; 0) &#123; count--; &#125; &#125; // 设置对应状态 public void setState(State state) &#123; this.currentState = state; &#125; 状态的接口：State.java 对应状态的接口实现类： eg: 中奖状态：WinnerState.java eg: 售卖状态：SoldState.java 改进后的售货机测试： 1234// 初始化售货机,且里面有3个商品 VendingMachineBetter machineBetter = new VendingMachineBetter(3); machineBetter.insertMoney(); machineBetter.turnCrank(); 参考链接 http://blog.csdn.net/lmj623565791/article/category/2206597 Thanks CSDN：张鸿洋 CSDN：dmk877 End感兴趣的小伙伴可以Star哦~ GitHub：DesignPattern]]></content>
      <categories>
        <category>Design pattern</category>
      </categories>
      <tags>
        <tag>Design pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MarkDown readme图片尺寸固定且居中]]></title>
    <url>%2F2016%2F10%2F28%2FMarkDown-readme%E5%9B%BE%E7%89%87%E5%B0%BA%E5%AF%B8%E5%9B%BA%E5%AE%9A%E4%B8%94%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[GitHub地址：https://github.com/youlookwhatCSDN博客：http://blog.csdn.net/jingbin_ 首先看一下显示效果： 有时候为达到美好的排版方式，我们会有多种显示图片的需求，现在我们来依次试试 显示图片的方式有这样几种：1.引入HTML,格式如下：1![](img_url) “[]”里放的是图片描述文字。这样图片就会靠在左侧，大小也不由自己决定,例如：1![图片描述文字](http://img.blog.csdn.net/20161028230559575) 2.固定图片显示大小：你是不是觉得以上的图片不是你想要的尺寸呢，没关系，你可以自定义尺寸：1&lt;img width="150" height="150" src="http://img.blog.csdn.net/20161028230559575"/&gt; 分别在“width”和“height”设置你想要的宽高就好了，就成这样：你也可以加上描述文字就是这样：1&lt;img src="http://img.blog.csdn.net/20161028230559575" width="150" height="200" alt="图片描述文字"/&gt; 3.固定图片显示大小且居中：这时候想到也许居中会更好，于是我们试试居中1&lt;div align=center&gt;&lt;img width="150" height="150" src="http://img.blog.csdn.net/20161028230559575"/&gt;&lt;/div&gt; 只要在外面包围div标签就好了，就是这样显示了：]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac Android开发环境变量的配置(java、sdk、ndk、gradle)]]></title>
    <url>%2F2016%2F10%2F13%2FMac-Android%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE-java%E3%80%81sdk%E3%80%81ndk%E3%80%81gradle%2F</url>
    <content type="text"><![CDATA[很多文章说了mac下怎样配置环境变量的问题，但大都很杂，在此总结一下，目的是使Android开发者看一篇博客就可以配置好AndroidStudio开发下的环境变量。 楼主的JDK版本是：1.8.0_40； AndroidStudio版本：2.2； ndk版本：android-ndk-r10e 1.打开terminal2.然后输入 vi .bash_profile 后按“e”进入编辑模式 3.输入想要配置的环境变量(java、sdk、ndk、gradle)： export JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/Homeexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export ANDROID_HOME=/Users/jingbin/Documents/AndroidStudio/sdkexport PATH=$PATH:$ANDROID_HOME/tools:$ANDROID_HOME/platform-tools export PATH=$PATH:/Users/jingbin/Documents/AndroidStudio/ndk/android-ndk-r10eexport A_NDK_ROOT=/Users/jingbin/Documents/AndroidStudio/ndk/android-ndk-r10e export GRADLE_HOME=/Applications/Android\ Studio\ 2.app/Contents/gradle/gradle-2.14.1export PATH=$PATH:$GRADLE_HOME/bin 4.在vi编辑器使用 esc:wq保存并退出(注意有“:”号) 5.更新设置 source .bash_profile 6.检查对应配置是否成功 echo $PATH（查看路径）java -versionadbndk-buildgradle -version]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android Studio</tag>
        <tag>Macbook Pro</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux与几种电脑系统的区别]]></title>
    <url>%2F2016%2F04%2F16%2FLinux%E4%B8%8E%E5%87%A0%E7%A7%8D%E7%94%B5%E8%84%91%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Linux之父：”我之所以能够看得更远，是因为我站在巨人肩膀上的缘故。”如有不当，还请指正。 Unix 创始人为肯·汤普逊、丹尼斯·里奇等。肯·汤普逊设计出了C语言，他的Unix的设计思想甚为宝贵。 Unix的前身为Multics，贝尔实验室参与了这个操作系统的研发，但因为开发速度太慢，贝尔实验室决定放弃这个计划。贝尔实验室的工程师，汤普逊和里奇，在此时自行开发了Unix。 Multics是由麻省理工学院，AT&amp;T贝尔实验室和通用电气合作进行的操作系统项目，被设计运行在GE-645大型主机上，但是由于整个目标过于庞大，糅合了太多的特性，Multics虽然发布了一些产品，但是性能都很低，AT&amp;T最终撤出了投入Multics项目的资源，中止这项合作计划。 Linux 当时芬兰大学林纳斯·托瓦兹学生创造。在移动设备上广泛使用的Android操作系统就是创建在Linux内核之上。 2005年，为了管理Linux内核的源代码，开发了Git。林纳斯·托瓦兹自嘲地取了这个名字“git”，该词源自英国俚语，意思大约是“混账”。 Linux与Unix的区别 Linux是Unix的养子。 硬件范围： Linux支持的硬件范围和商业Unix不一样。一般来说，商业Unix支持的硬件多一些，可是Linux支持的硬件也在不断扩大。突出的是，Linux至少和商用Unix一样稳定。 价格 Linux是免费软件，用户可以从Internet网上下载。 商业Unix的价值不应被贬低。除了软件本身的价格外，用户还需支付文档、售后支持和质保费。对于较大的机构，这些都很重要，但是PC机用户也许从中得不到什么好处。 -正是这样，这两种产品存在着严重的概念上和设计上的差别：Linux的目标是从头开始开发一个完整的Unix系统；386BSD的目标则是对现有的BSD做些修改，以适合80386系统。 Linux和Windows的区别 和Linux一样，Windows系列是完全的多任务操作系统。(MS-DOS是单任务的操作系统)它们支持同样的用户接口、网络和安全性。 Linux事实上是Unix的一种版本，而且来自Unix的贡献非常巨大。 是什么使得Unix如此重要？ 不仅在于对多用户机器来说，Unix是最流行的操作系统，而且在于它是免费软件的基础。在Internet上，大量免费软件都是针对Unix系统编写的。由于有众多的Unix厂商，所以Unix也有许多实现方法。没有一个单独的组织负责Unix的分发。现在，存在一股巨大的力量推动Unix社团以开放系统的形式走向标准化。另一方面Windows系列是专用系统，由开发操作系统的公司控制接口和设计。在这个意义上这种公司利润很高，因为它对程序设计和用户接口设计建立了严格的标准，和那些开放系统社团完全不一样。一些组织正在试图完成标准化Unix程序设计接口的任务。特别要指出的是，Linux完全兼容POSIX.1标准。 Linux 和 OS X 的区别 2001年新推出的OS X，结合BSD Unix、OpenStep和Mac OS 9的元素。它的最底层建基于Unix基础，其核心代码被称为Darwin，实行的是部分开放源代码。 都是基于类Unix的，不过Mac OS X属于Unix的直接衍生产品，OSX的内核是基于FreeBSD的内核。 都有开源部分，Linux自然不必说了，Mac OS X的底层——Darwin也是基于BSD协议开源的。 Linux就是这样一个东西，除了内核的稳定版本，所有的东西都可以任意更改和编写，并组成不同口味的发行包，只要源码公开，谁都可以从中获益，甚至包括收费发行。 二者的差别在系统架构上实际不大，都是类UNIX内核和GUI，但一个封闭一个开放。注意MACOSX也由开放版本，符合GNU。 Linux与其他操作系统的区别 Linux可以与MS-DOS、OS/2、Windows等其他操作系统共存于同一台机器上。它们均为操作系统，具有一些共性，但是互相之间各有特色，有所区别。 目前运行在PC机上的操作系统主要有Microsoft的MS-DOS、Windows、Windows NT、IBM的OS/2等。 早期的PC机用户普遍使用MS-DOS，因为这种操作系统对机器的硬件配置要求不高，而随着计算机硬件技术的飞速发展，硬件设备价格越来越低，人们可以相对容易地提高计算机的硬件配置，于是现在开始使用Windows、Windows NT等具有图形界面的操作系统。 a.Linux与MS－DOS之间: Linux可以直接访问计算机内的所有可用内存，提供完整的Unix接口。而MS-DOS只支持部分Unix的接口。 就使用费用而言，Linux和MS-DOS是两种完全不同的实体。与其他商业操作系统相比，MS-DOS价格比较便宜，而且在PC机用户中有很大的占有率。Linux是免费的，用户可以从internet上或者其他途径获得它的版本，而且可以任意使用，不用考虑费用问题。 就操作系统的功能来说，MS-DOS是单任务的操作系统，一旦用户运行了一个MS-DOS的应用程序，它就独占了系统的资源，用户不可能再同时运行其他应用程序。而Linux是多任务的操作系统，用户可以同时运行多个应用程序。 b.Linux与OS/2、Windows、Windows NT之间的区别 从发展的背景看，Linux与其他操作系统的区别是，Linux是从一个比较成熟的操作系统发展而来的，而其他操作系统，如Windows NT等，都是自成体系，无对应的相依托的操作系统。Linux做为Unix的一个克隆，同样会得到相应的支持和帮助，直接拥有Unix在用户中建立的牢固的地位。 从使用费用上看，Linux与其他操作系统的区别在于Linux是一种开放、免费的操作系统，而其他操作系统都是封闭的系统，需要有偿使用。OS/2和Windows NT等操作系统是具有版权的产品，其接口和设计均由某一公司控制，而且只有这些公司才有权实现其设计，它们是在封闭的环境下发展的。 参考 [1]: LINUX与UNIX区别在哪 [2]: Unix 起源及详细历程 [3]: Linux 和 OS X 的具体差异有哪些？]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
</search>
