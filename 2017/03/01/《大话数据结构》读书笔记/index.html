<!DOCTYPE html>


  <html class="light page-post">


<head>
  <meta charset="utf-8">
  
  <title>《大话数据结构》读书笔记 | JingBin&#39;s Home</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="Android,Books,数据结构与算法," />
  

  <meta name="description" content="如果你有梦想的话，就要去捍卫它。当别人做不到的时候，他们就想要告诉你，你也不能。如果你想要些什么，就得去努力争取。就这样！ – 《当幸福来敲门》">
<meta property="og:type" content="article">
<meta property="og:title" content="《大话数据结构》读书笔记">
<meta property="og:url" content="http://jinbeen.com/2017/03/01/《大话数据结构》读书笔记/index.html">
<meta property="og:site_name" content="JingBin's Home">
<meta property="og:description" content="如果你有梦想的话，就要去捍卫它。当别人做不到的时候，他们就想要告诉你，你也不能。如果你想要些什么，就得去努力争取。就这样！ – 《当幸福来敲门》">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021040316153545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210403161601434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210403161626993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021040316173389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210403161751906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210403162005972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210403161815913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210403161838165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/20210403161859375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:image" content="https://img-blog.csdnimg.cn/2021040316191976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">
<meta property="og:updated_time" content="2021-04-03T08:20:11.888Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="《大话数据结构》读书笔记">
<meta name="twitter:description" content="如果你有梦想的话，就要去捍卫它。当别人做不到的时候，他们就想要告诉你，你也不能。如果你想要些什么，就得去努力争取。就这样！ – 《当幸福来敲门》">
<meta name="twitter:image" content="https://img-blog.csdnimg.cn/2021040316153545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70">

  

  
    <link rel="icon" href="/favicon.ico">
  

  <link href="/css/styles.css?v=c114cbeddx" rel="stylesheet">


  
    <link rel="stylesheet" href="/css/personal-style.css">
  

  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'G-91L2DT6NQB', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?643275289e816ea38d7a840456d91ebd";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>


  
  <script type="text/javascript">
	(function(){
	    var bp = document.createElement('script');
	    var curProtocol = window.location.protocol.split(':')[0];
	    if (curProtocol === 'https') {
	        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
	    }
	    else {
	        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
	    }
	    var s = document.getElementsByTagName("script")[0];
	    s.parentNode.insertBefore(bp, s);
	})();
  </script>



  
    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.3.0/css/font-awesome.min.css">
  

</head>

<body>


  
    <span id="toolbox-mobile" class="toolbox-mobile">盒子</span>
  

  <div class="post-header CENTER">
   
  <div class="toolbox">
    <a class="toolbox-entry" href="/">
      <span class="toolbox-entry-text">盒子</span>
      <i class="icon-angle-down"></i>
      <i class="icon-home"></i>
    </a>
    <ul class="list-toolbox">
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/archives/"
            rel="noopener noreferrer"
            target="_self"
            >
            博客
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/categories/Android"
            rel="noopener noreferrer"
            target="_self"
            >
            分类
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/tags/Android"
            rel="noopener noreferrer"
            target="_self"
            >
            标签
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/link/"
            rel="noopener noreferrer"
            target="_self"
            >
            友链
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/about/"
            rel="noopener noreferrer"
            target="_self"
            >
            关于
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/music.html"
            rel="noopener noreferrer"
            target="_self"
            >
            Music
          </a>
        </li>
      
        <li class="item-toolbox">
          <a
            class="CIRCLE"
            href="/atom.xml"
            rel="noopener noreferrer"
            target="_blank"
            >
            RSS
          </a>
        </li>
      
    </ul>
  </div>


</div>


  <div id="toc" class="toc-article">
    <strong class="toc-title">文章目录</strong>
    <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据结构绪论"><span class="toc-text">数据结构绪论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#算法"><span class="toc-text">算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#算法时间复杂度"><span class="toc-text">算法时间复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#大O记法推导："><span class="toc-text">大O记法推导：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#常用的时间复杂度："><span class="toc-text">常用的时间复杂度：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#算法空间复杂度"><span class="toc-text">算法空间复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线性表"><span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顺序存储结构"><span class="toc-text">顺序存储结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#链式存储结构"><span class="toc-text">链式存储结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#栈与队列"><span class="toc-text">栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#栈的应用"><span class="toc-text">栈的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#知道中缀表达式-→-后缀表达式"><span class="toc-text">知道中缀表达式  → 后缀表达式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#串"><span class="toc-text">串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#树-Tree"><span class="toc-text">树(Tree)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树（Binary-Tree）"><span class="toc-text">二叉树（Binary Tree）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二叉树的存储结构"><span class="toc-text">二叉树的存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#二叉树顺序存储结构"><span class="toc-text">二叉树顺序存储结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#二叉链表"><span class="toc-text">二叉链表</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遍历二叉树"><span class="toc-text">遍历二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线索二叉树"><span class="toc-text">线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#图-Graph"><span class="toc-text">图(Graph)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查找"><span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#顺序查找-O-n"><span class="toc-text">顺序查找 O(n)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#有序表查找"><span class="toc-text">有序表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#二分差找-O-㏒n"><span class="toc-text">二分差找 O(㏒ｎ)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#插值查找-O-㏒n"><span class="toc-text">插值查找 O(㏒ｎ)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#斐波那契差找-O-㏒n"><span class="toc-text">斐波那契差找 O(㏒ｎ)</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#树表查找"><span class="toc-text">树表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#二叉树查找-二叉排序树"><span class="toc-text">二叉树查找(二叉排序树)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#平衡查找树之2-3查找树-2-3Tree-O-㏒n"><span class="toc-text">平衡查找树之2-3查找树(2-3Tree) O(㏒ｎ)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#平衡查找树之红黑树-Red-Black-Tree"><span class="toc-text">平衡查找树之红黑树(Red-Black-Tree)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B树和B-树（B-Tree-B-Tree）"><span class="toc-text">B树和B+树（B Tree/B+ Tree）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分块查找"><span class="toc-text">分块查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#排序"><span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#冒泡排序"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#简单选择排序"><span class="toc-text">简单选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#直接插入排序"><span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#希尔排序"><span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆排序"><span class="toc-text">堆排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#归并排序"><span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#快速排序"><span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#优化："><span class="toc-text">优化：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结-1"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#推荐文章"><span class="toc-text">推荐文章</span></a></li></ol>
  </div>



<div class="content content-post CENTER">
   <article id="post-《大话数据结构》读书笔记" class="article article-type-post" itemprop="blogPost">
  <header class="article-header">
    <h1 class="post-title">《大话数据结构》读书笔记</h1>

    <div class="article-meta">
      <span>
        <i class="icon-calendar"></i>
        <span>2017.03.01</span>
      </span>

      
        <span class="article-author">
          <i class="icon-user"></i>
          <span>JingBin</span>
        </span>
      

      
  <span class="article-category">
    <i class="icon-list"></i>
    <a class="article-category-link" href="/categories/Android/">Android</a>
  </span>



      

      
      <i class="fa fa-eye"></i> 
        <span id="busuanzi_container_page_pv">
           &nbsp热度 <span id="busuanzi_value_page_pv">
           <i class="fa fa-spinner fa-spin"></i></span>℃
        </span>
      
      
    </div>
  </header>

  <div class="article-content">
    
      <blockquote>
<p>如果你有梦想的话，就要去捍卫它。当别人做不到的时候，他们就想要告诉你，你也不能。如果你想要些什么，就得去努力争取。就这样！ – 《当幸福来敲门》</p>
</blockquote>
<a id="more"></a>
<p><a href="https://book.douban.com/subject/6424904/" target="_blank" rel="external">书籍链接点击</a> - 个人觉得可以用来入门，后面的路还很长。简要记录个人认为比较重要的内容。</p>
<h3 id="数据结构绪论"><a href="#数据结构绪论" class="headerlink" title="数据结构绪论"></a>数据结构绪论</h3><p>数据结构：是相互之间存在一种或多种特点关系的数据元素的集合。<br>数据结构是一门研究非数值计算的程序设计问题中的操作对象，以及它们之间的关系和操作等相关问题的学科。</p>
<blockquote>
<p>程序设计 = 数据结构 + 算法</p>
</blockquote>
<h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><p>　　语句的总执行次数<code>T(n)</code>是一个关于问题规模<code>n</code>的函数，进而分析<code>T(n)</code>随<code>n</code>的变化情况并确定<code>T(n)</code>的数量级。时间复杂度，也就是算法的时间量度，记：<code>T(n) = O(f(n))</code>。<br>　　<br>　　它表示随问题规模<code>n</code>的增大，算法执行时间的增长率和<code>f(n)</code>的增长率相同，称作算法的渐进时间复杂度，简称为<strong>时间复杂度</strong>。其中<code>f(n)</code>是问题规模<code>n</code>的某个函数。<br>　　<br>　　这样用大写<code>O(　)</code>来体现算法时间复杂度记法，我们称之为<strong>大O记法</strong>。
　　</p>
<h5 id="大O记法推导："><a href="#大O记法推导：" class="headerlink" title="大O记法推导："></a>大O记法推导：</h5><ul>
<li>1.用常数1取代运行时间中的所有加法常数。</li>
<li>2.在修改后的运行次数函数中，只保留最高阶项。</li>
<li>3.如果最高阶存在且不是1，则去除与这个项相乘的常数。得到的结果就是<strong>大O阶</strong>。</li>
</ul>
<h5 id="常用的时间复杂度："><a href="#常用的时间复杂度：" class="headerlink" title="常用的时间复杂度："></a>常用的时间复杂度：</h5><ul>
<li>常数阶　　–　<code>O(1)</code></li>
<li>线性阶　　–　<code>O(ｎ)</code></li>
<li>对数阶　　–　<code>O(㏒ｎ)</code></li>
<li>平方阶　　–　<code>O(ｎ²)</code></li>
<li>ｎ㏒ｎ阶　　–　<code>O(ｎ㏒ｎ)</code></li>
<li>指数阶　　–　<code>O(2º)</code>(º - n)</li>
</ul>
<p>常用的时间复杂度所耗费的时间从小到大依次是：<br><code>O(1)</code> &lt; <code>O(㏒ｎ)</code> &lt; <code>O(ｎ)</code> &lt; <code>O(ｎ㏒ｎ)</code> &lt; <code>O(ｎ²)</code> &lt; <code>O(ｎ³)</code> &lt; <code>O(2º)</code> &lt; <code>O(n!)</code> &lt; <code>O(ｎº)</code></p>
<p> <code>O(n!)</code>：阶乘阶。<br> <code>O(ｎ)</code>：查找一个有n个随机数字数组中的某个数字。<br> <code>O(㏒ｎ)</code>：</p>
<p> <img src="https://img-blog.csdnimg.cn/2021040316153545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="logn"></p>
<h4 id="算法空间复杂度"><a href="#算法空间复杂度" class="headerlink" title="算法空间复杂度"></a>算法空间复杂度</h4><p>算法的空间复杂度通过计算算法所需的<strong>存储空间</strong>实现，算法空间复杂度的计算公式记作：<strong><em>S(n) = O(f(n))</em></strong>，其中，<code>n</code>为问题的规模，<code>f(n)</code>为语句关于<code>n</code>所占存储空间的函数。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>时间复杂度 → 运行时间的需求<br>空间复杂度 → 运行空间的需求<br>不用限定词使用“复杂度”时，通常指时间复杂度。</p>
<h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><blockquote>
<p>List：零个或多个数据元素的有限序列。(eg：幼儿园接儿子)</p>
</blockquote>
<h4 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h4><p>随着数据的插入，我们的线性表的长度开始变大，不过线性表的当前长度不能超过存储容量，即数组的长度。</p>
<p>线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。</p>
<p>线性表的长度 ≤ 数组的长度</p>
<p><strong>数组</strong> → 读取：<code>O(1)</code>， 插入或删除：<code>O(n)</code></p>
<h4 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h4><p>1.单链表结构：<br>　<strong>链表：</strong> → 读取：<code>O(n)</code>， 插入或删除：<code>O(1)</code><br>还有：2.静态链表结构、3.循环链表、4.双向链表</p>
<h3 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h3><p>　　<strong><em>栈</em></strong>：是限定仅在表尾进行插入和删除操作的线性表。<br>　　<strong><em>队列</em></strong>：是只允许在一端操作、而在另一端进行删除操作的线性表。</p>
<h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><p>四则运算表达式求值：<br>后缀（逆波兰）表示法定义 -&gt; 不需要括号<br><code>&quot;9 + (3 - 1) * 3 + 10 / 2&quot;</code>  →  <code>&quot;931 - 3 *+ 10 2 /+&quot;</code></p>
<h5 id="知道中缀表达式-→-后缀表达式"><a href="#知道中缀表达式-→-后缀表达式" class="headerlink" title="知道中缀表达式  → 后缀表达式"></a>知道中缀表达式  → 后缀表达式</h5><ul>
<li>数字 → 输出</li>
<li>括号 → 等反括号，再输出反括号里的符号</li>
<li><code>* /</code> → 优先级高先出栈</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>它们均可以用线性表的顺序存储结构来实现，但都存在着顺序存储的一些弊端，因此它们各自有各自的技巧来解决这个问题。<br>对于栈来说，如果是两个相同类型的栈，则可以用数组的两端作栈底的方法来让两个栈共享数据，这就可以最大化地利用数组的空间。<br>对于队列来说，为了避免数组插入和删除时需要移动数据，于是就引入了循环队列，是的队头和队尾可以在数组中循环变化。解决了移动数据的时间损耗，是的本来插入和删除是<code>O(n)</code>的时间复杂度变成了<code>O(1)</code>。</p>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><blockquote>
<p>是由零个或多个字符组成的有限序列，又名叫字符串。</p>
</blockquote>
<h3 id="树-Tree"><a href="#树-Tree" class="headerlink" title="树(Tree)"></a>树(Tree)</h3><p>树是n(n≥0)个结点的有限集。n=0时称为空树。在任意一颗非空树中：<br>　　<1> 有且仅有一个特定的称为根(Root)的结点。<br>　　<2>当n &gt; 1时，其余结点可分为m(m&gt;0)个互不相交的有限集T1、T2…、Tm，其中每一个集合本身又是一棵树，并且称为根的子树(SubTree)。
　　</2></1></p>
<h4 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h4><p>二叉树是n(n≥0)个结点的有限集合，该集合或者为空集（称为空二叉树），或者由一个根节点和两棵互不交换的、分别称为根节点的<strong><em>左子树</em></strong>和<strong><em>右子数</em></strong>的二叉树组成。</p>
<p>特殊二叉树：<br>　　1、斜树<br>　　2、满二叉树<br>　　3、完全二叉树</p>
<h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><h5 id="二叉树顺序存储结构"><a href="#二叉树顺序存储结构" class="headerlink" title="二叉树顺序存储结构"></a>二叉树顺序存储结构</h5><p>二叉树的顺序存储结构就是用一维数组存储二叉树中的结点，并且结点的存储位置，也就是数组的下标要能体现结点之间的逻辑关系，比如双亲与孩子的关系，左右兄弟的关系等。<br><img src="https://img-blog.csdnimg.cn/20210403161601434.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="完全二叉树的顺序存储"></p>
<h5 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h5><p>既然顺序存储适用性不强，我们就要考虑链式存储结构。<strong>二叉树每个结点最多有连个孩子，所以为它设计一个数据域和指针域</strong>是比较自然的想法，<strong>我们称这样的链表叫做二叉链表。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">lchild</th>
<th style="text-align:center">data</th>
<th style="text-align:center">rchild</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:center">A</td>
<td style="text-align:center">r</td>
</tr>
</tbody>
</table>
<p>其中dataz是数据域，lchild 和 rchild 都是指针域，分别存放指向左孩子和右孩子的指针。<br><img src="https://img-blog.csdnimg.cn/20210403161626993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="二叉链表结构图"></p>
<h4 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h4><p>二叉树的遍历（traversing binary tree）是指从根节点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问一次且仅访问一次。</p>
<p>遍历方法：<br>　　1、前序遍历<br>　　2、中序遍历<br>　　3、后序遍历<br>　　4、层序遍历<br>　　<br>知道：前序：ABCDEF 中序：CBAEDF<br>推出：后序：CBEFDA<br>过程：<br>　　前序：可知[A]是根节点<br>　　中序：[CB]知道C是B的左孩子<br>　　<br>知道：中序：ABCDEFG  后序：BDCAFGE<br>推出：前序：EACBDGF<br>过程：<br>　　后序：[E]在尾端，知[E]为根节点。<br>　　…</p>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><h3 id="图-Graph"><a href="#图-Graph" class="headerlink" title="图(Graph)"></a>图(Graph)</h3><p>是由定点的有穷非空集合和顶点之间的集合组成，通常表示为G(V,E)，其中，G表示一个图，V是图G中顶点的集合，E是图G中边的集合。</p>
<p>多对多的情况 → eg:人际关系</p>
<p>无向边：若顶点Vi到Vj之间的边没有方向，则称这条边为无向边(Edge)，用无序偶对(Vi，Vj)来表示。<br>任意两个顶点之间的边都是无向的，则称该图为<strong>无向图</strong>。</p>
<p>有向边：若顶点Vi到Vj之间的边有方向，则称这条边为有向边，也称为弧(Arc)。<br>任意两个顶点之间的边都是有向边，则称该图为<strong>有向图</strong>。</p>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="顺序查找-O-n"><a href="#顺序查找-O-n" class="headerlink" title="顺序查找 O(n)"></a>顺序查找 O(n)</h4><h4 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h4><blockquote>
<p>三者的区别是：中间数取的不一样。<br>具有n个结点的完全二叉树的深度为[log2n]+1。→ ㏒ｎ</p>
</blockquote>
<h5 id="二分差找-O-㏒n"><a href="#二分差找-O-㏒n" class="headerlink" title="二分差找 O(㏒ｎ)"></a>二分差找 O(㏒ｎ)</h5><h5 id="插值查找-O-㏒n"><a href="#插值查找-O-㏒n" class="headerlink" title="插值查找 O(㏒ｎ)"></a>插值查找 O(㏒ｎ)</h5><h5 id="斐波那契差找-O-㏒n"><a href="#斐波那契差找-O-㏒n" class="headerlink" title="斐波那契差找 O(㏒ｎ)"></a>斐波那契差找 O(㏒ｎ)</h5><h4 id="树表查找"><a href="#树表查找" class="headerlink" title="树表查找"></a>树表查找</h4><h5 id="二叉树查找-二叉排序树"><a href="#二叉树查找-二叉排序树" class="headerlink" title="二叉树查找(二叉排序树)"></a>二叉树查找(二叉排序树)</h5><p>插入和查找的时间复杂度为<code>O(㏒ｎ)</code>，最坏(长条)为<code>O(n)</code>。<br>优化：<br>　　平衡二叉树，为了避免上述最差的情况(<code>O(n)</code>)，构建时，让这棵二叉排序树是平衡二叉树，此时，查找、插入和删除都是<code>O(㏒ｎ)</code>。
　　</p>
<h5 id="平衡查找树之2-3查找树-2-3Tree-O-㏒n"><a href="#平衡查找树之2-3查找树-2-3Tree-O-㏒n" class="headerlink" title="平衡查找树之2-3查找树(2-3Tree) O(㏒ｎ)"></a>平衡查找树之2-3查找树(2-3Tree) O(㏒ｎ)</h5><blockquote>
<p>属于二叉树查找优化。</p>
</blockquote>
<p><strong>性质：</strong><br>　　1、中序遍历2-3查找树，就可以得到好序的序列。<br>　　2、在一个完全平衡的2-3查找树中，根节点到每一个为空节点的距离都相同。</p>
<p>最坏：所有都是2-node节点，时间复杂度：㏒ｎ<br>最好：所有都是3-node节点，时间复杂度：0.631㏒ｎ</p>
<h5 id="平衡查找树之红黑树-Red-Black-Tree"><a href="#平衡查找树之红黑树-Red-Black-Tree" class="headerlink" title="平衡查找树之红黑树(Red-Black-Tree)"></a>平衡查找树之红黑树(Red-Black-Tree)</h5><p>2-3树实现起来比较复杂，于是有了一种简单实现的2-3树的数据结构 – 红黑树。</p>
<p>红黑树中将节点之间的链接分为两种不同的类型：<br>　　红色链接：用来链接两个2-nodes节点来表示一个3-nodes节点。<br>　　黑色链接：用来链接普通的2-3节点。</p>
<p>特性：<br>　　1、红色链接向左倾斜。<br>　　2、一个节点不可能有两个红色链接。<br>　　3、整个树完全黑色平衡。<br>　　<br>Java：TreeMap和TreeSet都是基于红黑二叉树。</p>
<h5 id="B树和B-树（B-Tree-B-Tree）"><a href="#B树和B-树（B-Tree-B-Tree）" class="headerlink" title="B树和B+树（B Tree/B+ Tree）"></a>B树和B+树（B Tree/B+ Tree）</h5><p>用于：文件系统和数据库系统中（硬盘里的文件）。</p>
<h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><p>哈希表查找： Map的本质是Hash表 → 以空间换时间。<br>key - indexed 键 - 值<br>时间复杂度：<code>O(1)</code></p>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>算法的复杂性：算法本身的复杂度，而不是指算法的时间负责度。</p>
<p>内排序：插入排序、交换排序、选择排序、归并排序<br><strong>简单算法：</strong><br>　　　　冒泡排序：O(ｎ²)<br>　　　　简单选择排序：O(ｎ²)<br>　　　　直接插入排序：O(ｎ²)<br><strong>改进算法：</strong><br>　　　　希尔排序：O(ｎ³/²)  不稳定<br>　　　　堆排序：O(ｎ㏒ｎ) 不稳定<br>　　　　归并排序：O(ｎ㏒ｎ) 稳定<br>　　　　快速排序：
　　　　</p>
<h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>挨个比较，设置flag(优化)</p>
<h4 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h4><p>比较n次，最小交换到第1位<br>比较n-1次，最小交换到第2位<br>比较n-2次，最小交换到第3位</p>
<p>性能略高于冒泡排序</p>
<h4 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h4><p>一个记录的辅助空间，比上两种性能好一些。向前插入依次向后移动。（适用于：基本有序、少数）</p>
<h4 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h4><blockquote>
<p>改进的直接插入排序。</p>
</blockquote>
<p>条件：基本有序（通过希尔排序达到基本有序）<br>将相隔某个“增量”的记录组成一个子序列，实现<strong><em>跳跃式的移动</em></strong>，使得排序的效率提高。<br><strong><em>跳跃式的移动</em></strong>：导致了不稳定。</p>
<p>增量： increment = increment/3 + 1;</p>
<h4 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h4><blockquote>
<p>改进的简单选择排序。<br>不适合排序序列较少的情况。</p>
</blockquote>
<p>定义：根节点一定是堆中所有节点最大(小)值。<strong>大</strong>：大顶堆。<strong>小</strong>：小顶堆。<br>比较与交换跳跃式进行：导致了不稳定。</p>
<p>先将无序序列构建成一个堆（大顶堆），根节点为最大值，移走，将剩余的<code>n-1</code><strong><em>重新构造</em></strong>成一个堆，再移走，反复执行。<br><strong>重新构造</strong>：调整的是非终端结点（非叶结点）</p>
<blockquote>
<p>堆排序操作的是完全二叉树（有两个子结点或无子结点），不必左小又大。<br>ps:平衡二叉树：高度一致，左大右小。</p>
</blockquote>
<p>运行时间主要消耗在初始构建堆和在重建堆时的反复筛选上。</p>
<p>构建堆<code>O(n)</code>，重建堆<code>O(ｎ㏒ｎ)</code>，得到时间复杂度：<code>O(ｎ㏒ｎ)</code>。远远好于简单算法的时间复杂度。</p>
<h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><blockquote>
<p>两两比较不跳跃（稳定）<br>时间复杂度：<code>O(ｎ㏒ｎ)</code>，空间复杂度：<code>O(ｎ+㏒ｎ)</code></p>
</blockquote>
<p>n个有序的子序列，长度为1，两两合并，得到[n/2]。然后再两两合并….<br>一个无序序列，先分散我一个个单个序列，然后再合并。<br><img src="https://img-blog.csdnimg.cn/2021040316173389.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="归并排序"></p>
<p><strong><em>比较占用内存，但却效率高且稳定的算法</em></strong><br>使用此算法时，尽量考虑非递归方法。</p>
<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><blockquote>
<p>直接插入排序的升级。不稳定<br>时间复杂度：<br>　　　平均和最好：<code>O(ｎ㏒ｎ)</code>；<br>　　　最坏：<code>O(ｎ²)</code>；<br>空间复杂度：<br>　　　平均和最好：<code>O(㏒ｎ)</code>；　　　<br>　　　最坏：<code>O(ｎ)</code>；</p>
</blockquote>
<p>基本思想是：通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到有序的目的。</p>
<p>Partition函数：<br> 　　取一个关键字（pivot枢轴）。先定一个关键字，然后想尽办法让，左边的值都比它小，右边的值都比它大。<br><img src="https://img-blog.csdnimg.cn/20210403161751906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="快速排序_1"></p>
<blockquote>
<p>50&gt;20 → 交换内容<br>交换后 20&lt;pivotkey，low++<br>high里的值为50，不大于50，high不动</p>
</blockquote>
<p>交换之后：<br><img src="https://img-blog.csdnimg.cn/20210403162005972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="快速排序_2"></p>
<blockquote>
<p>到角标为3时：<br>low的值为90 &gt; high的值为50 → 交换内容<br>交换后 high里的值为90 &gt; 50, → high–</p>
</blockquote>
<p><img src="https://img-blog.csdnimg.cn/20210403161815913.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="快速排序_3"><br><img src="https://img-blog.csdnimg.cn/20210403161838165.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="快速排序_4"><br><img src="https://img-blog.csdnimg.cn/20210403161859375.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="快速排序_5"><br><img src="https://img-blog.csdnimg.cn/2021040316191976.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ppbmdiaW5f,size_16,color_FFFFFF,t_70" alt="快速排序_6"></p>
<h5 id="优化："><a href="#优化：" class="headerlink" title="优化："></a>优化：</h5><ul>
<li>1、优化选取枢轴（三数取中，九数取中）</li>
<li>2、优化不必要的交换（先备份在L.r[0]中(头中)，再直接替换，省掉中间交换）</li>
<li>3、优化小数组时的排序方案（如只有7个或50个，用直接插入排序，大于则快速排序）</li>
<li>4、优化递归操作（递归要时间，减少，使用<strong>尾递归</strong>）</li>
</ul>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul>
<li><strong>插入排序类</strong>：<br>　　　直接插入排序<br>　　　希尔排序</li>
<li><strong>选择排序类</strong>：<br>　　　简单选择排序<br>　　　堆排序</li>
<li><strong>交换排序类</strong>：<br>　　　冒泡排序<br>　　　快速排序</li>
<li><strong>归并排序类</strong>：<br>　　　归并排序
　　　</li>
</ul>
<h3 id="推荐文章"><a href="#推荐文章" class="headerlink" title="推荐文章"></a>推荐文章</h3><ul>
<li><a href="http://www.cnblogs.com/liuling/archive/2013/04/14/suanfa.html" target="_blank" rel="external">常用的算法的时间复杂度和空间复杂度</a></li>
<li><a href="http://blog.csdn.net/qy1387/article/details/7752973" target="_blank" rel="external">Java常用排序算法/程序员必须掌握的8大排序算法</a></li>
<li><a href="http://www.cnblogs.com/maybe2030/p/4715035.html" target="_blank" rel="external">七大查找算法</a></li>
<li><a href="http://www.jianshu.com/p/159426e2aaf6" target="_blank" rel="external">Android的数据结构与算法—-ArrayList源码解析</a></li>
</ul>

    
  </div>

</article>


   
  <div class="text-center donation">
    <div class="inner-donation">
      <span class="btn-donation">支持一下</span>
      <div class="donation-body">
        <div class="tip text-center">扫一扫，支持我</div>
        <ul>
        
          <li class="item">
            
              <span>微信扫一扫</span>
            
            <img src="https://raw.githubusercontent.com/youlookwhat/CloudReader/master/file/Wechat-admire.jpg" alt="">
          </li>
        
          <li class="item">
            
              <span>支付宝扫一扫</span>
            
            <img src="https://raw.githubusercontent.com/youlookwhat/CloudReader/master/file/alipay-admire.jpg" alt="">
          </li>
        
        </ul>
      </div>
    </div>
  </div>


   
  <div class="box-prev-next clearfix">
    <a class="show pull-left" href="/2017/03/01/《催眠师手记》读书笔记/">
        <i class="icon icon-angle-left"></i>
    </a>
    <a class="show pull-right" href="/2017/03/05/Future/">
        <i class="icon icon-angle-right"></i>
    </a>
  </div>




</div>


  <a id="backTop" class="back-top">
    <i class="icon-angle-up"></i>
  </a>




  <div class="modal" id="modal">
  <span id="cover" class="cover hide"></span>
  <div id="modal-dialog" class="modal-dialog hide-dialog">
    <div class="modal-header">
      <span id="close" class="btn-close">关闭</span>
    </div>
    <hr>
    <div class="modal-body">
      <ul class="list-toolbox">
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/archives/"
              rel="noopener noreferrer"
              target="_self"
              >
              博客
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/categories/Android"
              rel="noopener noreferrer"
              target="_self"
              >
              分类
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/tags/Android"
              rel="noopener noreferrer"
              target="_self"
              >
              标签
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/link/"
              rel="noopener noreferrer"
              target="_self"
              >
              友链
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/about/"
              rel="noopener noreferrer"
              target="_self"
              >
              关于
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/music.html"
              rel="noopener noreferrer"
              target="_self"
              >
              Music
            </a>
          </li>
        
          <li class="item-toolbox">
            <a
              class="CIRCLE"
              href="/atom.xml"
              rel="noopener noreferrer"
              target="_blank"
              >
              RSS
            </a>
          </li>
        
      </ul>

    </div>
  </div>
</div>



  
      <div class="fexo-comments comments-post">
    

    

    
    

    

    
    

    

<!-- Gitalk评论插件通用代码 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js"></script>
<script>
const gitalk = new Gitalk({
  clientID: '2b303b849c8ea65e4051',
  clientSecret: '57fc88550a6d86d10a191bb7b6411072576c00b3',
  repo: 'blog-comment',
  owner: 'youlookwhat',
  // 在这里设置一下截取前50个字符串, 这是因为 github 对 label 的长度有了要求, 如果超过
  // 50个字符串则会报错.
  // id: location.pathname.split('/').pop().substring(0, 49),
  id: md5(location.pathname),
  admin: ['youlookwhat'],
  // facebook-like distraction free mode
  distractionFreeMode: false
})
gitalk.render('gitalk-container')
</script>
<!-- Gitalk代码结束 -->



  </div>

  

  <script type="text/javascript">
  function loadScript(url, callback) {
    var script = document.createElement('script')
    script.type = 'text/javascript';

    if (script.readyState) { //IE
      script.onreadystatechange = function() {
        if (script.readyState == 'loaded' ||
          script.readyState == 'complete') {
          script.onreadystatechange = null;
          callback();
        }
      };
    } else { //Others
      script.onload = function() {
        callback();
      };
    }

    script.src = url;
    document.getElementsByTagName('head')[0].appendChild(script);
  }

  window.onload = function() {
    loadScript('/js/bundle.js?235683', function() {
      // load success
    });
  }
</script>

</body>
</html>
